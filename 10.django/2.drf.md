Django restframework
# 简介
- 在Django框架基础之上，进行二次开发
- 用于构建Restful API
- 简称为DRF框架
## REST API
RESTful 是一种开发理念，是设计风格而不是标准
- 具象状态传输
- 每一个URL代表一种资源（json, text, 图片, 视频等）
- 请求头Content-Type: 指明给服务端的参数类型
- 请求头Accept：指明希望接收服务端的数据类型
## 特性
- 提供强大的Serializer序列器，可以高效进行序列化和反序列化
- 提供了极为丰富的类视图,MiXIN扩展类,ViewSet视图集
- 提供具备可视化的的WebAPI界面
- 多种身份认证和权限认证
- 强大的排序，过滤，分页，搜索，限流等
- 可扩展性，插件丰富
## api设计规则
1. URL
- 尽量用名词复数形式
- 往往与数据库表名相同
2. 过滤条件（查询字符串）
|命令|描述|
|-|-|
|?limit=10|指定返回记录的数最|
|?offset=10|指定返回记录的开始位置|
|?page=2&size=10|指定第几页和每页的数据条数|
|?sort=name|指定返回结果按照哪个属性排序，以及排序顺序|

3. 版本
- 版本号可以放在URL也可以放在请求头

## 一般处理逻辑

1. 校验用户数据
2. 将请求的数据（如json格式）转换为模型类对象
    - 反序列化
        - 将其他格式（json、xml等）转换为程序中的数据类型
        - 将json格式的字符串转换为Django中的模型类对象
3. 操作数据库
4. 将模型类对象转换为响应的数据（如json格式）
    - 序列化
        - 将程序中的数据类型转换为其他格式（json、xml等）
        - 例如将Django中的模型类对象装换为json字符串

## django优劣
1. 代码冗余
2. 数据校验麻烦，复用性差
3. 编码规范不统一
4. 仅支持json格式的返回，不支持其他类型
5. 仅支持json格式的传参，不支持form表单传参
6. 列表页视图没有分页，过滤，排序

## 使用配置

### 安装
`pip install djangorestframework`

### 配置
```py
INSTALLED_APPS = [
    'rest_framework',
]
```

# 序列化器
序列化器的作用
1. 进行数据的校验
2. 对数据对象进行转换

## 字段

字段	|字段构造方式
-|-
BooleanField	|BooleanField()
NullBooleanField	|NullBooleanField()
CharField	|CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)
EmailField	|EmailField(max_length=None, min_length=None, allow_blank=False)
RegexField	|RegexField(regex, max_length=None, min_length=None, allow_blank=False)
SlugField	|SlugField(maxlength=50, min_length=None, allow_blank=False) 
URLField	|URLField(max_length=200, min_length=None, allow_blank=False)
UUIDField	|UUIDField(format='hex_verbose') <br>format: <br>1) 'hex_verbose' 如"5ce0e9a5-5ffa-654b-cee0-1238041fb31a" <br>2） 'hex' 如 "5ce0e9a55ffa654bcee01238041fb31a" <br>3）'int' - 如: "123456789012312313134124512351145145114" <br>4）'urn' 如: "urn:uuid:5ce0e9a5-5ffa-654b-cee0-1238041fb31a"
IPAddressField	|IPAddressField(protocol='both', unpack_ipv4=False, **options)
IntegerField	|IntegerField(max_value=None, min_value=None)
FloatField	|FloatField(max_value=None, min_value=None)
DecimalField	|DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)<br>max_digits: 最多位数<br>decimal_palces: 小数点位置
DateTimeField	|DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None)
DateField	|DateField(format=api_settings.DATE_FORMAT, input_formats=None)
TimeField	|TimeField(format=api_settings.TIME_FORMAT, input_formats=None)
DurationField	|DurationField()
ChoiceField	|ChoiceField(choices) choices与Django的用法相同
MultipleChoiceField	|MultipleChoiceField(choices)
FileField	|FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)
ImageField	|ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)
ListField	|ListField(child=, min_length=None, max_length=None)
DictField	|DictField(child=)


### SerializerMethodField
以`get_` + 字段名,可以设置方法给该字段使用.方法接受一个实例.不支持反序列化(写入)

该方法可以使返回的字段具备更强的逻辑
```py
class HeroSerializer(serializers.Serializer):
    gender = serializers.IntegerField(label="性别", min_value=1)
    status = serializers.SerializerMethodField()


    def get_status(self, obj):
    if obj.gender == 1:
        return "我是男的呀"
    else:
        return "我是女的呀"
```
### 日期字段
时间类型的字段都支持对输入输出时间格式的设置

```py
create_date = serializers.DateTimeField(format="%Y-%m-%d %H:%M:%S", input_formats="%Y-%m-%d %H:%M:%S")
```

### 关系序列化
- PrimaryKeyRelatedField: 显示关联对象的主键
- StringRelatedField: 显示关联对象的`__str__`
- 使用关联对象的序列化器: 显示关联对象的所有数据

tip: 如果字段声明的关联方是`多`的一方,需要传递参数`many=True`

```py
class BookModelSerializer(serializers.ModelSerializer):
    # .... 省略


class HeroModelSerializer(serializers.ModelSerializer):
    # book = serializers.PrimaryKeyRelatedField(label="书本", many=True, queryset=models.Book.baseobjects.all())
    book = serializers.PrimaryKeyRelatedField(label="书本", many=True, read_only=True)
    book_str = serializers.StringRelatedField(label="书本", many=True, read_only=True, source="book")
    book_obj = BookModelSerializer(many=True, read_only=True)

    # .... 省略
```
### 高级字段
#### HiddenField 隐藏字段
作用: 不根据用户输入取值的字段类，而是从默认值或可调用值中取值

常结合`CurrentUserDefault`一起使用
```py
class Suite(DynamicFieldsModelSerializer):
    creator = serializers.HiddenField(default=serializers.CurrentUserDefault())
```
#### CurrentUserDefault 当前请求用户
该类可以返回当前请求的用户, 必须在请求后从视图中调用的序列化器类类才可以使用. 否则将报错
```py
# 常规使用方法
class Suite(DynamicFieldsModelSerializer):
    creator = serializers.HiddenField(default=serializers.CurrentUserDefault())

# 如果单独拿出来使用
def create(self, validated_data):
    # ...
    user = serializers.CurrentUserDefault()(self)
    # ....
    return beat

```


## 字段参数
参数名称	|作用
-|-
max_length	|最大长度
min_lenght	|最小长度
allow_blank	|是否允许为空
trim_whitespace	|是否截断空白字符
max_value	|最小值
min_value	|最大值
|read_only|表明该字段仅用于序列化输出，默认False |
|write_only|表明该字段仅用于反序列化输入，默认False |
|required|表明该字段在反序列化时必须输入，默认True |
|default|反序列化时使用的默认值|
|allow_null|表明该字段是否允许传入None，默认False |
|validators|该字段使用的验证器|
|error_messages|包含错误编号与错误信息的字典label用于HTML展示API页面时，显示的字段名称|
|help_text|用于HTML展示API页面时，显示的字段帮助提示信息|
source|字段来源

### source
声明字段的源,可以声明为 `模型字段` 可以声明为`关联模型字段` 也可以声明为 `方法`

部分source不支持可入,比如声明为`方法`的字段

```py
class ArticleSerializer(serializers.ModelSerializer):
    title = serializers.CharField(source="title")  # 声明为模型中的title
    author = serializers.ReadOnlyField(source="author.username")  # 声明为关联对象author的username字段
    status = serializers.ReadOnlyField(source="get_status_display")  # 声明为choice枚举可视

    class Meta:
        model = Article
        fields = '__all__'
        read_only_fields = ('id', 'author', 'create_date')
```
## Meta类属性
- model: 指明参照哪个模型类
- fields: 指明为模型类的哪些字段生成(元组) 或 `__all__`代表全部
- exclude: 排除掉哪些字段,与`fields`不可同用
- depth: 深度,输入数字,代表显示关联对象信息量的深度(多少)
- read_only_fields: 只读字段(元组/列表)
- extra_kwargs: 额外参数
- validators: 校验器
- list_serializer_class: 列表序列化器类

```py
from rest_framework.validators import UniqueTogetherValidator


class BookModelSerializer(serializers.ModelSerializer):

    class Meta:
        model = models.Book  # 指定模型类
        fields = "__all__"  # 一定要声明这个,或者exclude
        # fields = ["id", "name"]
        # exclude = ["id"]  # Cannot set both 'fields' and 'exclude' options on serializer BookModelSerializer.
        read_only_fields = ["id", "hero_id", "hero_name", "hero"]
        validators = (
            UniqueTogetherValidator(
                queryset=models.Book.baseobjects.get_not_null(),
                fields=("price", "name"),
                message="已存在"
            )
        ,)  # 两两组合独一无二
        extra_kwargs = {  # 如果定义了字段,则此处的定义无效.
            "name": {
                "validators": [UniqueValidator(model.baseobjects.all(), "书名不可重复噢")],
                "max_length": 30,
                "label": "书名",
                "min_length": 5,
                "help_text": "书名"
            },
            "price": {
                "help_text": "价格",
                "min_value": 0.01,
                "max_value": 10000,
                "error_messages": {"min_value": "价格要大于0元噢",
                                   "max_value": "价格要小于10000元噢"}
            }
        }
```
## 使用
1. 用于序列化时，将模型类对象传入instance参数
2. 用于反序列化时，将要被反序列化的数据传入data参数
3. 除了instance和data参数外，在构造Serializer对象时，还可通过context参数额外添加数据，如

`serializer = AccountSerializer(account, context={'request': request})`

1. 通过context参数附加的数据，可以通过Serializer对象的`context`属性获取。
2. 如果数据模型对象是含有多个对象的话,需要在实例化时`many=True`
```py
from booktest.models import BookInfo
from booktest.serializers import BookInfoSerializer


book = BookInfo.objects.get(id=2)
serializer = BookInfoSerializer(book)
serializer.data  # {'id': 2, 'btitle': '天龙八部', 'bpub_date': '1986-07-24', 'bread': 36, 'bcomment': 40, 'image': None}

book_qs = BookInfo.objects.all()
serializer = BookInfoSerializer(book_qs, many=True)
serializer.data  # # [OrderedDict([('id', 2), ('btitle', '天龙八部'), ('bpub_date', '1986-07-24'), ('bread', 36), ('bcomment', 40), ('image', N]), OrderedDict([('id', 3), ('btitle', '笑傲江湖'), ('bpub_date', '1995-12-24'), ('bread', 20), ('bcomment', 80), ('image'ne)]), OrderedDict([('id', 4), ('btitle', '雪山飞狐'), ('bpub_date', '1987-11-11'), ('bread', 58), ('bcomment', 24), ('ima None)]), OrderedDict([('id', 5), ('btitle', '西游记'), ('bpub_date', '1988-01-01'), ('bread', 10), ('bcomment', 10), ('im', 'booktest/xiyouji.png')])]
```

## 校验
序列化器实例调用`is_valid`时会进行下列的校验器调用
### 内置校验器
`rest_framework.validators`模块中提供了一些校验器
- UniqueValidator: 用于单字段唯一校验
- UniqueTogetherValidator: 用于多字段唯一校验

```py
class HeroSerializer(serializers.Serializer):
    name = serializers.CharField(label="姓名", max_length=30,
                                 validators=[UniqueValidator(
                                                 queryset=models.Hero.baseobjects.all(),
                                                 message="姓名不可重复噢!")])
    class Meta:
        validators = [  # 不能元组
        UniqueTogetherValidator(
            queryset=models.Book.objects.all(),  # 比对的查询集
            fields=("price", "name"),  # 需要比对的字段
            message="已存在"  # 错误消息
        )

```
### 单字段校验
通过 `validate` + `_` + 需要验证的字段名. 可以自定义单字段校验
```py
class HeroSerializer(serializers.ModelSerializer):

    # .... 省略

    def validate_gender(self, validate):  # validate就是gender字段的数据
        print(validate)
        if validate in (1, 2):
            return validate
        else:
            raise serializers.ValidationError("性别应该是1/2")
```
### 对象级校验
通过重写在序列化类中`validate`方法,可以对序列化器进行对象级校验

`validate`方法接受的`attrs`是字典,里面以键值对的形式存储序列化器类的字段
```py
class HeroSerializer(serializers.ModelSerializer):

    # .... 省略
    def validate(self, attrs):
        print(attrs)
        if attrs["name"].startswith("a"):
            return attrs
        else:
            raise serializers.ValidationError("名字开头应该为a")
```
### 自定义校验器
drf自带的校验器不够用时,可以自定义适合的校验器使用.成功返回验证的值,失败直接报错

使用时在字段的`validators`中声明方法名即可
```py
def custom_validate(validate):
    if validate.endswith("s"):
        return validate
    else:
        raise serializers.ValidationError("名字要以S结尾")

class HeroSerializer(serializers.Serializer):
    name = serializers.CharField(label="姓名", max_length=30,
                                 validators=[custom_validate,  # 直接填写方法名即可
                                             UniqueValidator(
                                                 queryset=models.Hero.baseobjects.all(),
                                                 message="姓名不可重复噢!")])

    # ....省略
```
### 校验顺序
1. 在序列化器字段定义时，通过validators选项添加校验器
2. 单字段校验和多字段校验
3. 序列化器字段校验顺序
- 字段定义时的限制（包含validators列表条目从左到右进行校验）→ 单字段校验（validate_*） → 多字段校验（validate）
- 如果有设置`list_serializer_class`,则继续执行指定类的`validate`



## Serializer
`rest_framework.serializers.Serializer`继承于`BaseSerializer, metaclass=SerializerMetaclass`

`Serializer`中并没有对`create`,`update`这两个函数进行重写,使用该序列化类进行序列化,必须要重写两个函数,否则无法使用

```py
class HeroSerializer(serializers.Serializer):
    name = serializers.CharField(label="姓名", max_length=30,
                                 validators=[custom_validate,
                                             UniqueValidator(
                                                 queryset=models.Hero.baseobjects.all(),
                                                 message="姓名不可重复噢!")])
    gender = serializers.IntegerField(label="性别", min_value=1)
    full_gender = serializers.ReadOnlyField(source="get_gender_display")
    book = serializers.PrimaryKeyRelatedField(label="书本", many=True, read_only=True)
    status = serializers.SerializerMethodField()
    create_date = serializers.DateTimeField(format="%Y-%m-%d %H:%M:%S", input_formats="%Y-%m-%d %H:%M:%S")

    def create(self, validated_data):  # 不支持多对多
        instance = models.Hero.baseobjects.create(**validated_data)
        return instance

    def update(self, instance, validated_data):  # 不支持多对多
        for k, y in validated_data.items():
            setattr(instance, k, y)
        instance.save()
        return instance
```
## ModelSerializer
`ModelSerializer`继承于`Serializer`做了更加完善的实现,提供了
- 基于模型类自动生成一系列字段
- 基于模型类自动为`Serializer`生成`validators`，比如`unique_together`
- 包含默认的`create()`和`update()`的实现

tip: `model`和`fields`字段为必填字段.

如果在没有其他特殊需求的情况下,简简单单就实现了一个完整的序列化器
```py
# 最简序列化器
from django.contrib.auth.models import Permission


class PermissionSerializer(ModelSerializer):
    class Meta:
        model = Permission
        fields = "__all__"
```
### 自定义
如果有需要进行部分自定义,也可以如下述代码,做二次开发
```py
# 从表模型
class ProjectModelSerializer(serializers.ModelSerializer):

    # 1. 显示创建序列化器字段（支持不是meta类中指定model的字段）
    name = serializers.CharField(label='项目名称', max_length=200, help_text='',  # 自定义的字段会cover自动创建的字段,
                                 validators=[UniqueValidator(queryset=Interfaces.objects.all(), message="name不能重复"),
                                             is_unique_project_name])  # 当有校验器失败后,会继续校验全部指定的校验器(类的校验器不会)，通过后才会运行类校验器

    # 外键 source默认为变量名，当变量名与外键字段名不同时，需指定source到外键字段名
    # 1. 数据库模型中的外键字段，默认会生成PrimaryKeyRelatedField序列化器类型，序列化输出的值为外键ID值
    project_str = serializers.StringRelatedField(source='project')
    # 2. 当设置为StringRelatedField类型的时候，将被序列化为关联对象字符串表达形式（__str__方法）
    project_slug = serializers.SlugRelatedField(slug_field='leader', source='project', queryset=Projects.objects.all())
    # 3. SlugRelatedField此字段将被序列化为关联对象的指定字段数据
    project_obj = XiProjectModelSerializer(read_only=True, source='project')  # 通常设置为只读
    # 4. 使用关联对象的序列化器

    # 自动创建create update
    class Meta:
        model = Interfaces
        fields = "__all__"
        # fields = ('id', 'name')
        # exclude = ('',)  # 排除项
        read_only_fields = ('id', '')  # 指定read_only字段
        extra_kwargs = {  # 自动添加的才可以, 在该变量内可定制化字段，嵌套字典格式
            'method': {  # 字段参数
                # 'write_only': True,
                'error_messages': {
                    'max_length': '不能大于200字数', 
                    'min_length': '不能小于6位数'
                    }
            },
            'url': {
                # 'write_only': True,
                'validators': [UniqueValidator(queryset=Interfaces.objects.all(), message="name不能重复"),
                               is_unique_project_name]
            }
        }

    def validate_name(self, value):
        if not value.endswith('项目'):
            raise serializers.ValidationError('项目名称必须以项目结尾')
        # 当校验成功的时候一定要返回value
        return value

    def validate(self, attrs):  # 会将所有的反序列化对象传入attrs参数
        if 'icon' not in (attrs['url'], attrs['path']):
            raise serializers.ValidationError('tester||leader错误')
        return attrs

```
## 自定义 输入&输出
除了重写`create`&`update`还可以通过重写
- to_internal_value: 对输入的数据进行修改,在调用`is_valid`内运行,在运行`validate`之前运行
- to_representation: 对输出的数据进行修改,在`.data`时调用
```py
def custom_validate(validate):
    print(validate)
    if validate.endswith("s"):
        return validate
    else:
        raise serializers.ValidationError("名字要以S结尾")


# 基础序列化类
class HeroSerializer(serializers.Serializer):
    name = serializers.CharField(label="姓名", max_length=30,
                                 validators=[custom_validate,
                                             UniqueValidator(
                                                 queryset=models.Hero.baseobjects.all(),
                                                 message="姓名不可重复噢!")])
    gender = serializers.IntegerField(label="性别", min_value=1)
    full_gender = serializers.ReadOnlyField(source="get_gender_display")
    # book = serializers.PrimaryKeyRelatedField(label="书本", many=True, queryset=models.Book.baseobjects.all())
    book = serializers.PrimaryKeyRelatedField(label="书本", many=True, read_only=True)
    book_str = serializers.StringRelatedField(label="书本", many=True, read_only=True, source="book")
    book_obj = BookModelSerializer(many=True)
    status = serializers.SerializerMethodField()
    create_date = serializers.DateTimeField(format="%Y-%m-%d %H:%M:%S", input_formats="")

    def create(self, validated_data):  # 不支持多对多
        instance = models.Hero.baseobjects.create(**validated_data)
        return instance

    def update(self, instance, validated_data):  # 不支持多对多
        for k, y in validated_data.items():
            setattr(instance, k, y)
        instance.save()
        return instance

    def validate(self, attrs):
        print(attrs)
        if attrs["name"].startswith("a"):
            return attrs
        else:
            raise serializers.ValidationError("名字开头应该为a")

    def validate_gender(self, validate):
        print(validate)
        if validate in (1, 2):
            return validate
        else:
            raise serializers.ValidationError("性别应该是1/2")

    def get_status(self, obj):
        if obj.gender == 1:
            return "我是男的呀"
        else:
            return "我是女的呀"

    def to_internal_value(self, data):  # 在调用 is_valid内运行,在validate之前
        print(data, "=======")
        return super().to_internal_value(data)

    def to_representation(self, instance):  # 在.data时调用
        print(instance)
        return super().to_representation(instance)
```

## list_serializer_class 列表显示
列表显示常用于有多个对象的数据`(many=True)`需要序列化/反序列化时使用.如果没有在序列化器类中指定额外的`list_serializer_class`列表序列化器类,则序列化时默认使用当前序列化器类展示

`list_serializer_class`指定的列表序列化器类必须为`ListSerializer`及其子集.并且需要对列表类进行二次开发

在列表类中, 通过`self.child`可以调用原序列化类(指定类)的实例方法

`validate`的验证顺序: 先指定类的`validate`方法, 后列表类的`validate`方法
```py
class FilterListSerializer(ListSerializer):

    def to_representation(self, data):  # 在列表类中data为查询集,可以使用查询集的相关函数. 例如筛选软删除的数据
        data = data.filter(delete_date__isnull=True)
        return super().to_representation(data)

    def update(self, instance, validated_data):  # update方法需要二次开发, 编写更新逻辑. 
    # 例如以下逻辑是 通过判断反序列化数据是否携带id,如果携带id则修改该id的数据,如果没有携带就新建数据,并且将原有数据但未在数据中携带id的软删除
        instance = instance.filter(delete_date__isnull=True)
        instance_mapping = {var.id: var for var in instance}

        ret = []
        for data in validated_data:
            pk = data.pop("id", "")
            if pk in instance_mapping:  # 更新
                var = instance_mapping.pop(pk)
                ret.append(self.child.update(var, data))  # 调用原序列化器类
            else:  # 创建
                ret.append(self.child.create(data))

        for i in instance_mapping.values():
            i.delete_date = now()
            i.save()

        return ret


class SubCase(DynamicFieldsModelSerializer):
    class Meta:
        model = models.SubCases
        fields = "__all__"
        extra_kwargs = deepcopy({
            "source": {
                "required": True
            },
            "id": {
                "read_only": False,
                "required": False
            }
        })
        list_serializer_class = FilterListSerializer
        only_once_fields = ("stage",)
        list_fields = ("status", "source", "id", "order")



class Stage(DynamicFieldsModelSerializer):
    sub_cases = SubCase(many=True, required=False)  # 在类属性中声明另外一个序列化器类

    class Meta:
        model = models.Stage
        fields = "__all__"
        read_only_fields = ("suite",)
        extra_kwargs = deepcopy({
            "id": {
                "read_only": False,
                "required": False
            }
        })
        list_serializer_class = FilterListSerializer  # 指定列表序列化
        only_once_fields = ("suite",)
        list_fields = ("id", "sub_cases", "stage_type", "status", "custom", "order", "case", "suite_step")

    def validate(self, attrs):
        stage_type = attrs.get("stage_type")
        case = attrs.get("case", "")
        suite = attrs.get("suite_step", "")
        custom = attrs.get("custom", "")
        sub_cases = attrs.get("sub_cases", "")
        if stage_type == 1:
            if not case or suite or custom:
                raise ValidationError({"case": "Type 'case' parameter error"})
        elif stage_type == 2:
            if not suite or case:
                raise ValidationError({"suite": "Type 'suite' parameter error"})
            if custom and not (custom and sub_cases):
                raise ValidationError({"suite": "Type 'suite' parameter error"})
        else:
            raise ValidationError({"type": "Type is error!"})

        if sub_cases:
            suite_stages = suite.stages.all()
            for sub in sub_cases:
                source = sub.get("source", None)
                if source not in suite_stages:
                    raise ValidationError({"source": "sub_cases must be in reference suite "})
        return attrs

    def create(self, validated_data):  # 含有另外一个序列化器类的需要二次开发创建方法
        sub_cases = validated_data.pop("sub_cases", {})  # 提取出另外一个序列化器类的值
        instance = super().create(validated_data)
        if sub_cases:
            sub = SubCase(many=True, data=sub_cases)
            sub._validated_data = sub_cases  # 为了避免二次校验, 所以直接赋值, 不再调用is_valid方法
            sub.save(stage=instance)
        return instance

    def update(self, instance, validated_data):  # 含有另外一个序列化器类的需要二次开发修改方法
        sub_cases = validated_data.pop("sub_cases", [])
        sub = SubCase(many=True, instance=instance.sub_cases, data=sub_cases)
        sub._validated_data = sub_cases
        sub.save(stage=instance)
        return super().update(instance, validated_data)
```

# 视图 view
![](./image/inherit_chain.jpg)
## APIView
`APIView`继承自`View`.类方法名跟请求方法名一致即可通过该请求方法访问到该类方法

- 继承Django中的View
- APIView与View的不同之处
    - 传入到视图方法中的是Request对象，而不是Django的HttpRequeset对象
    - 视图方法可以返回Response对象，会为响应数据处理（render）为符合前端要求的格式
    - 任何APIException异常都会被捕获到，并且处理成合适的响应信息
    - 在进行dispatch()分发前，会对请求进行身份认证、权限检查、流量控制
- 常用类属性
    - authentication_classes列表或元祖，身份认证类
    - permissoin_classes列表或元祖，权限检查类
    - throttle_classes 列表或元祖，流量控制类


```py
from rest_framework import status
from rest_framework.response import Response


class BookAPIView(APIView):

    def get(self, request, format=None):
        book = Book.objects.all()
        serializer = BookSerializer(book, many=True)
        return Response(serializer.data)

    def post(self, request, format=None):
        serializer = BookSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
```
## GenericAPIView
`GenericAPIView`继承自`APIView`,相较`APIView`新增了查询集 序列化类 查询关键字 过滤 分页等属性和方法

属性: 
- queryset: 查询集,用于给`get_queryset`和`get_queryset`使用
- serializer_class: 序列化器类, 用于给`get_serializer`
- lookup_field: 主键名(常用键名),用于`get_queryset`提取唯一对象使用
- lookup_url_kwarg: 路由(url)中传递关键字的key
- filter_backends: 过滤器后端(元组)
- pagination_class: 分页器

方法:
- get_queryset
- get_object
- get_serializer

```py
#使用开源的过滤引擎
#pip install django-filter
from django_filters.rest_framework import DjangoFilterBackend

class View(GenericAPIView):
    # 1. 视图类中自定过滤引擎
    filter_backends = (filters.OrderingFilter,)
    # 2. 指定需要排序的字段
    ordering_fields = ('id', 'name', 'url')  # 查询字符串：path?ordering=-name
    # 3. 指定查询集
    queryset = Interfaces.objects.all()  # 实例时仅会请求一次，不能在方法中直接self.queryset进行使用
    # 4. 指定序列化器
    serializer_class = ProjectModelSerializer
    # 5. 设置主键字段
    lookup_field = 'pk'
    # 6. 指定分页引擎
    pagination_class = PageNumberPaginationManual
```
### GenericView & mixins
- RetrieveAPIView
    - 提供get方法I
    - 继承：RetrieveModelMixin、GenericAPIView
- UpdateAPIView。提供put和patch方法
    - 继承：UpdateModelMixin、GenericAPIView
- DestroyAPIView
    - 提供delete方法
    - 继承：DestoryModelMixin、GenericAPIView
- ListAPIView
    - 提供get方法
    - 继承：ListModelMixin、GenericAPIView
- CreateAPIView
    - 提供post方法
    - 继承：CreateModelMixin、GenericAPIView
- ListCreateAPIView
    - 提供post.get方法
    - 继承：ListModelMixin、CreateModelMixin、GenericAPIView
- RetrieveUpdateAPIView
    - 提供get、put、patch方法
    - 继承：RetrieveModelMixin、UpdateModelMixin、GenericAPIView
- RetrieveDestroyAPIViewI
    - 提供get、delete方法
    - 继承：RetrieveModelMixin、DestroyModelMixin、GenericAPIView
- RetrieveUpdateDestroyAPIView
    - 提供get、put、patch、delete方法
    - 继承：RetrieveModelMixin.UpdateModelMixin、DestroyModelMixin、GenericAPIView
## ModelMixin
`rest_framework.mixins`模块中,提供了五个通用的类.涵盖`增删改查(单/多)`.mixins模块中的类与继承自`GenericAPIView`的视图类都可以很好的结合使用.

- CreateModelMixin: 新增类,提供了新增的方法
    - create: 方法中提供了反序列化,调用`perform_create`及响应
    - perform_create: 提供反序列化保存
- ListModelMixin
    - list: 进行序列化+分页+响应 
- RetrieveModelMixin
    - retrieve: 序列化+响应
- UpdateModelMixin
    - update: 进行反序列化+模型实例+调用`perform_update`+响应
    - perform_update: 序列化实例保存
    - partial_update: 部分更新,调用`update`传入`partial=True`
- DestroyModelMixin
    - destroy: 获取单个对象,调用`perform_destroy`
    - perform_destroy: 删除

```py
from django import mixins


class DemoMiXinGenericAPIView(
    GenericAPIView,
    mixins.ListModelMixin,
    mixins.CreateModelMixin,
    mixins.RetrieveModelMixin,
    mixins.UpdateModelMixin,
    mixins.DestroyModelMixin):

    # 1. 视图类中自定过滤引擎
    filter_backends = [filters.OrderingFilter, DjangoFilterBackend]
    # 2. 指定需要排序的字段
    ordering_fields = ['id', 'name', 'url']  # 查询字符串：path?ordering=-name
    # 3. 指定查询集
    queryset = Interfaces.objects.all()  # 实例时仅会请求一次，不能在方法中直接self.queryset进行使用
    # 4. 指定序列化器
    serializer_class = ProjectModelSerializer
    # 5. 设置主键字段
    lookup_field = 'pk'
    # 6. 指定需要过滤的字段
    filterset_fields = ['name', 'url']  # 查询字符串：path?name=user
    # 7. 指定分页引擎
    pagination_class = PageNumberPaginationManual

    def post(self, request, *args, **kwarg):
        return self.create(request, *args, **kwarg)

    def get_list(self, request, *args, **kwargs):  # 进行过滤 排序 分页后，输出列表
        return self.list(request, *args, **kwargs)

    def get(self, request, *args, **kwargs):  # 输出模型数据
        return self.retrieve(request, *args, **kwargs)  #

    def put(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)

    def delete(self, request, *args, **kwargs):
        return self.destroy(request, *args, **kwargs)
```
### 重写
通过重写mixin中提供的`perform_create`, `perform_update`, `perform_destroy`可以修改逻辑

通过重写`perform_destroy`方法,实现软删除
```py
def perform_destroy(self, instance):
    instance.is_delete = True
    instance.save()
```
## ViewSetMixin
主要是重写`as_view()`方法, 将原本 `method` 映射为 `类方法`改成通过在`as_view`中传入映射,实现根据`method`匹配类方法

视图集重点就在`ViewSetMixin`上,`ViewSetMixin`重写了`as_view`方法,使 `method` 与类方法可以自由绑定.增删改查(单/多)都可以在同一个视图集里面.设置路由更加方便
1. 在设置路由时指定 请求方法和类方法
2. 通过`Router`注册视图集自动生成路由
3. 通过`action`可以添加自定义方法


## ViewSet
`ViewSet`继承自`ViewSetMixin`和`APIView`.

## GenericViewSet

`ViewSetMixin`结合`GenericAPIView`生成了`GenericViewSet`.

## ModelViewSet & ReadOnlyModelViewSet

`GenericViewSet`与`Mixins`结合又生成了
- ReadOnlyModelViewSet: 只支持查看单个和查看多个
- ModelViewSet: 支持增删改(部分/全部)查(单/多)


### 路由 Router
手动绑定请求方法与类方法,注意`detail`不能使用该类名
```py
urlpatterns = [
    path('hero', views.HeroViewSet.as_view({'get': 'list', 'post': "create"})),
    path('hero/<int:pk>', views.HeroViewSet.as_view({'get': 'retrieve', 'put': 'update'}))
]
```

实例化`Router`,对视图进行注册.详情可见`Router`章节
```py
router = SimpleRouter()
router.register(r"book", views.BookModelViewSet, basename="book")
urlpatterns += router.urls

router.urls
"""
自动生成的路由
[
    <URLPattern '^book/$' [name='book-list']>, 用于get/post 查看(多)和新建
    <URLPattern '^book/(?P<pk>[^/.]+)/$' [name='book-detail']>, 用于put patch delete get 删改查(单) 
    <URLPattern '^book/(?P<pk>[^/.]+)/custom/$' [name='book-custom']>  这个路由是用action新增的 也会自动添加
]
"""
```

使用`Router`注册路由时, 将会按以下规则映射
|请求方法|方法(action)|描述|
|-|-|-|
|GET|retriever|获取详情数据（单条）|
|GET|list|获取列表数据（多条）|
|POST|create|创建数据|
|PUT|update|更新数据|
|PATCH|partial_update|部分更新|
|DELETE|destroy|删除数据|

tip: 如果视图集内没有`queryset`,就不可以用 `router`进行注册路由

### action
`from rest_framework.decorators import action`

action(methods=None, detail=None, url_path=None, url_name=None, **kwargs)
- methods：用于指定动作支持的请求方法 列表/元组
- detail：用于指定动作要处理的是否为详情资源对象(url中是否需要传递查询字符串)
- url_path: path部分名字， 默认为方法名
- url_name: 设置reserve的端口名， 默认为 `类_方法名`

tip:
1. 如果detail=True, 则路由为`路由注册时的名字/路由参数(lookup_field)/方法名或url_path`组成
2. 如果detail=False, 则路由为`路由注册时的名字/方法名或url_path`组成

```py
class BookModelViewSet(ModelViewSet):
    # ...省略

    @action(methods=["get", "post"], detail=True)
    def custom(self, request, pk, **kwargs):
        return Response({"return": pk, "action": self.action, "kwargs": kwargs})
```

### ModelViewSet
```py
from rest_framework.viewsets import ModelViewSet


class BookModelViewSet(ModelViewSet):
    """
    list:
    返回图书列表数据

    retrieve:
    返回图书详情数据

    latest:
    返回最新的图书数据

    read:
    修改图书的阅读量

    """
    queryset = models.Book.baseobjects.get_not_null()
    serializer_class = serializers.BookModelSerializer
    throttle_scope = "book"
    # authentication_classes = (BasicAuthentication, SessionAuthentication, TokenAuthentication)
    permission_classes = (IsAuthenticated,)
    # throttle_classes = (UserRateThrottle, )
    throttle_classes = (ScopedRateThrottle, )
    throttle_scope = "book"
    # pagination_class = PageNumberPagination
    pagination_class = PagePagination
    filter_backends = (DjangoFilterBackend, OrderingFilter, SearchFilter)
    filterset_fields = ("name", "price")  # 过滤字段
    search_fields = ('name', )  # 查询匹配过滤字段, 只可以用于 CharField/TextField
    ordering_fields = ('id', 'name', 'price')  # 也可以使用__all__
    ordering = ("-id", )  # 默认排序

    @action(methods=["get", "post"], detail=True)
    def custom(self, request, pk, **kwargs):
        return Response({"return": pk, "action": self.action, "kwargs": kwargs})
```

## Example
### 用户系统
用户系统通过对部分函数的重写实现软删除及注册功能
- `perform_destroy`: 删除时将用户改为 冻结 状态,实现软删除
- `perform_update`和`perform_create`: 先 创建/获得 用户对象再使用`set_password`对密码进行加密并保存
```py
class UserViewSet(ModelViewSet):
    queryset = User.objects.all()
    serializer_class = UserModelSerializer
    raise_exception = True
    ordering = ("-id",)

    def perform_destroy(self, instance):  # 冻结用户
        instance.is_active = False
        instance.save()

    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        if instance != request.user and request.user.is_staff:
            self.perform_destroy(instance)
            return Response({"success": True}, status.HTTP_200_OK)
        else:
            raise PermissionDenied("无权操作!")

    def update(self, request, *args, **kwargs):  # username 不可以修改
        if "partial" in kwargs:
            return super().update(request, *args, **kwargs)
        raise MethodNotAllowed("不允许使用该method")

    def partial_update(self, request, *args, **kwargs):
        keywords = ("username", )
        for keyword in keywords:  # 过滤不允许再次修改的值
            request.data.pop(keyword, "")

        if request.user.id == int(kwargs[self.lookup_field]) or request.user.is_staff:  # 自己不可以改自己,除了超管
            user = super().partial_update(request, *args, **kwargs)

        else:
            raise PermissionDenied("请不要改其他人啊!")
        return user

    def perform_update(self, serializer):
        user = serializer.save()
        password = serializer.validated_data.pop("password", None)
        if password:
            user.set_password(password)
            user.save()

    def perform_create(self, serializer):
        user = serializer.save()
        user.set_password(serializer.validated_data["password"])
        user.save()
```
# 权限 permission
drf已经实现了基础的权限以请求用户是否为`认证用户` `匿名` `管理员`进行基础鉴权

和搭配django原生权限(增删改查)实现对象级的鉴权

文档: 
1. drf: https://www.django-rest-framework.org/api-guide/permissions/
2. django: https://docs.djangoproject.com/zh-hans/3.2/topics/auth/default/
## django自带权限
django项目中每次执行数据迁移时`migrate`都会通过`post_migrate`信号为首次迁移的model创建四个权限.

默认产生的权限与`ContentType`关联.也可以与`User`和`Group`进行绑定,实现个人权限/组权限

假设你有一个名为 `foo` 应用程序和一个名为 `Bar` 的模型
- 添加：foo.add_bar
- 修改：foo.change_bar
- 删除：foo.delete_bar
- 查看：foo.view_bar

权限表结构
id|name|content_type_id|codename
-|-|-|-
1|Can add permission|2|add_permission

content_type_id 与 content_type表关联

### 使用

#### 与user(用户)类搭配使用

不管是用户自定义的用户类还是系统自带的user(用户)类都应该是继承于`AbstractUser`类.

`AbstractUser`又继承了`AbstractBaseUser, PermissionsMixin`这两个类,前者如字面意思一样主要是一些用户类基础,这个有兴趣了解详见user模块.我们的重点在`PermissionsMixin`,这个类是提供关于权限的函数/属性等,在该类主要提供了以下几个函数
- get_user_permissions(self, obj=None): 返回用户具有的权限
- get_group_permissions(self, obj=None): 返回用户关联的组具有的权限
- get_all_permissions(self, obj=None): 返回用户+组具有的全部权限
- has_perm(self, perm, obj=None): perm传入权限,如果用户具有权限返回True,没有则False
- has_perms(self, perm_list, obj=None): perm传入权限列表,如果用户具有传入的全部权限返回True,没有则False
- has_module_perms(self, app_label): app_label传入模型的app_label,判断是否是被该模型的权限

tip: 
1. 如果没有对认证后端做二次开发,请不要传obj的,该参数入口只是预留使用的.如果传了obj,将返回`set()`空集合
2. 如果是`is_superuser`用户将获得全部权限

以默认认证后端(AUTHENTICATION_BACKENDS)举例
```py
class ModelBackend(BaseBackend):
    # .... 传入obj最终就会走到以下这个方法,并且在校验的时候就直接返回 set()
    def _get_permissions(self, user_obj, obj, from_name):
        """
        ...
        """
        # 判断用户是否为活跃,是否为匿名,obj是否为None
        if not user_obj.is_active or user_obj.is_anonymous or obj is not None:
            return set()

        # ....
```

```py
user.has_perm('app.add_person')  # False
user.has_perms(('app.add_student', 'app.can_deliver_pizzas'))  # True
user.get_all_permissions()  # {'app.change_hero', 'sessions.view_session', 'users.view_user'}
```

#### CBV中使用

tip: 
1. 在视图类必须在首位继承`PermissionRequiredMixin`类,否则将不会调用`PermissionRequiredMixin`的`dispatch`函数,导致鉴权无效
2. 不能与drf的认证(`DEFAULT_AUTHENTICATION_CLASSES`)一起使用,因为drf的认证是在视图层进行的,视图类按照前来后到顺序,会先进行鉴权,但此时并没有进行认证,所以此时用户为匿名用户,鉴权失败
```py
from django.contrib.auth.mixins import PermissionRequiredMixin


class UserViewSet(PermissionRequiredMixin, View):
    permission_required = ("users.view_user", "users.add_user", "users.change_user", "users.delete_user",)
    # ....
```


创建权限的序列化器
```py
from django.contrib.auth.models import Permission
from rest_framework.serializers import ModelSerializer


class PermissionSerializer(ModelSerializer):
    class Meta:
        model = Permission
        fields = "__all__"
```

创建视图
- 本人在设计权限时,只希望使用django提供的增删改查,不想额外添加权限,所以使用了只读视图集.
```py
from rest_framework.viewsets import ReadOnlyModelViewSet
from django.contrib.auth.models import Permission
from .serializers import PermissionSerializer


class PermissionViewSet(ReadOnlyModelViewSet):
    queryset = Permission.objects.all()
    serializer_class = PermissionSerializer
    ordering = ("-id",)
```

## drf
drf提供了几个权限,有四个只做了基础鉴权,有三个需要搭配上述django提供的权限做鉴权

tip:
1. drf的权限都在视图层进行,视图必须继承`APIView`类实现的才可以.
2. 与django权限类搭配的三个权限(`DjangoModelPermissions`)只能应用于具有`.queryset`属性或`get_queryset()`方法的视图(即继承于`GenericAPIView`类的视图)
3. `DjangoObjectPermissions`类 只是调用了对象级鉴权的操作,但鉴权需要backend.而默认的backend不支持对象级鉴权.所以该类需要搭配`django-guardian`使用.

`rest_framework.permissions`模块
- AllowAny: 任意用户都可以访问(如果使用了鉴权,建议填上)效果与权限为空一样
- IsAuthenticated: 只要鉴权通过,就可以访问
- IsAdminUser: is_staff为True的管理员才可以访问
- IsAuthenticatedOrReadOnly: 只读(SAFE_METHODS)可以访问,经过鉴权的也可以访问

---
- DjangoModelPermissions: 搭配permission模型使用(需要用户绑定权限),只做了普通权限
- DjangoModelPermissionsOrAnonReadOnly: 同上,但是匿名只读也可以访问
- DjangoObjectPermissions: 同上,但做了对象层鉴权

tip: `permissions`模块中有`SAFE_METHODS`属性,归纳了所有安全访问方法类型(只读类型)
### 使用
使用这几个鉴权类需要在`setting.py`中进行全局配置/在类中以类属性进行局部配置

1. 如果配置了多个鉴权类,访问该视图时需要满足任一个类的鉴权,否则将失败
2. 如果同时配置了全局与局部,将使用局部配置
#### 全局配置
在配置文件中全局配置后,所有父类为`APIView`的视图都会进行鉴权

setting.py
```py
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': (
        'AllowAny',
        'DjangoModelPermissions'
    )
}
```
#### 局部配置
如果同时配置了全局与局部,将使用局部配置.
```py
class UserViewSet(ModelViewSet):
    permission_classes = (IsAuthenticated, )
    # ....
```
### 自定义权限类
#### 权限类介绍
`rest_framework.permissions.BasePermission`为drf所有自带权限类的基类

在`BasePermission`类中主要是对以下2个函数进行重写
- has_permission(self, request, view): 用于对所有访问进行鉴权
- has_object_permission(self, request, view, obj): 用于对访问单个对象的请求进行鉴权

如果使用的视图不是使用`genericAPIView`及其子类,需要手动调用`self.check_object_permissions(request，obj)`. `genericAPIView`在调用`get_object`时会调用

返回True即为通过鉴权,返回False为失败
```py
from rest_framework.permissions import BasePermission


class Permission(BasePermission):

    def has_permission(self, request, view):
        return True

    def has_object_permission(self, request, view, obj):
        return True
```

#### 自定义完善原生权限类
因为drf的3个需要搭配django权限类使用的三个类并没有对只读做详细的鉴权,所以在常规使用时,需要对只读的几个权限做鉴权.主要是补全`GET`,`OPTIONS`,`HEAD`这三个请求方法
```py
class ModelPermission(DjangoModelPermissions):

    perms_map = {
        'GET': ['%(app_label)s.view_%(model_name)s'],
        'OPTIONS': ['%(app_label)s.view_%(model_name)s'],
        'HEAD': ['%(app_label)s.view_%(model_name)s'],
        'POST': ['%(app_label)s.add_%(model_name)s'],
        'PUT': ['%(app_label)s.change_%(model_name)s'],
        'PATCH': ['%(app_label)s.change_%(model_name)s'],
        'DELETE': ['%(app_label)s.delete_%(model_name)s'],
    }
```
### django-guardian
django-guardian 提供了对象级权限的关联和鉴权.

此处不详细展开

官方文档: https://django-guardian.readthedocs.io/

# 限流 Throttling
用于限制用户与视图之间的访问频率,对超过访问频率的请求进行限制

drf自带的限流支持三种模式
- AnonRateThrottle: 对匿名用户进行限流,通过`X-Forwarded-For`(如果没有则用`REMOTE_ADDR`)进行唯一性判别,`rate`标签为: `anon`
- UserRateThrottle: 对已认证的用户进行限流, `rate`标签为: `user`
- ScopedRateThrottle: 通过在视图类属性中设置标签(`throttle_scope`),从而以视图级进行限流

限流单位:
- second: 每秒
- minute: 每分
- hour: 每时
- day: 每天

限流格式: `数量/单位`, 如: `100/day` 每天100次请求

文档: https://www.django-rest-framework.org/api-guide/throttling/

## 配置
### 全局配置
```py
REST_FRAMEWORK = {
    'DEFAULT_THROTTLE_CLASSES': (
        'rest_framework.throttling.AnonRateThrottle',
        'rest_framework.throttling.UserRateThrottle'
    ),
    'DEFAULT_THROTTLE_RATES': {
        'anon': '100/day',
        'user': '1000/day',
        "book": '5/second'  # 类属性中key设置为book
    }
}
```
### 局部配置
```py
class BookModelViewSet(ModelViewSet):
    throttle_classes = (ScopedRateThrottle, )
    throttle_scope = "book"  # 限流的key设置为book
```

# 分页 pagination
drf自带三个分页类
- LimitOffsetPagination: 限制偏置分页器,默认以查询字符串`limit`和`offset`进行分页
    - `http://localhost:8000/v1/book/?limit=10&offset=6`: 每页10条从第6条查起
- CursorPagination: 游标分页器,详可见大江狗文章
- PageNumberPagination: 页面分页器,默认不支持以查询字符串设置每页显示条数,以查询字符串`page`进行分页,如果需要通过查询字符串对条数进行控制,需要进行自定义,详情见自定义模块
    - `http://127.0.0.1:5000/user/user/?page=2`: 第2页


文档: https://www.django-rest-framework.org/api-guide/pagination/

大江狗: https://pythondjango.cn/django/rest-framework/8-pagination/

## 使用
在`GenericViewSet`的子类视图中
- paginate_queryset(queryset): 获取经过分页后的查询集
- get_paginated_response(data): 给字典添加分页信息

```py
class InterfacesViewSet(viewsets.GenericViewSet):
    # ....省略
    
    def list(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())

        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)

```

## 配置

### 全局配置
```py
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',  # 设置分页器类
    'PAGE_SIZE': 10  # 全局默认条数
}
```
### 局部配置
```py
from rest_framework.pagination import PageNumberPagination


class BookModelViewSet(ModelViewSet):
    pagination_class = PageNumberPagination
```
## 自定义分页
继承`PageNumberPagination`实现以 查询字符串的参数`page_size`来控制页面显示行数.在全局配置/局部配置中需要改成修改后的类
```py
from rest_framework.pagination import PageNumberPagination


class PagePagination(PageNumberPagination):
    page_query_param = "page"  # page关键字 (默认为page)
    page_size_query_param = "page_size"  # PageNumberPagination 默认为None不使用,如果需要使用,需要重新定义
    max_page_size = 30  # 最大条数
    page_size = 10  # 正常条数
    page_query_description = '第几页'  # 在接口文档中的中文描述
    page_size_query_description = '每页几条'

    def get_paginated_response(self, data):  # 添加总页数和当前页数
        response = super().get_paginated_response(data)
        response.data["total_pages"] = self.page.paginator.num_pages
        response.data["current_page_num"] = self.page.number
        return response
```
`http://127.0.0.1:5000/user/user/?page=2&page_size=20`: 第二页每页20条

# 令牌 simple-jwt
因为`djangorestframework-jwt`已经在17年停止维护了,所以使用推荐使用`djangorestframework-simplejwt`

官方文档: https://django-rest-framework-simplejwt.readthedocs.io/en/latest/

大江狗: https://pythondjango.cn/django/rest-framework/7-jwt-token-authentication/#simple-jwt%E7%9A%84%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE

可以通过该网址进行解密
https://jwt.io/
## token结构
`eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoyLCJ1c2VybmFtZSI6ImFlZ2lzIiwiZXhwIjoxNTk3NDI2NjA3LCJlbWFpbCI6ImFlZ2lzQDEyMy5jb20ifQ.m_S_dNIXqi_BzpxJz3AOoej2keiVYhT55XPwfJ3wV2Q`

jwt由三部分组成：`header`, `playload`, `signature`
- header
    - 声明类型
    - 声明signature的加密算法，默认为HS256
    - 采用base64加密，可以解密
```py
import base64

print(base64.b64decode("eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9"))
Out[2]: b'{"typ":"JWT","alg":"HS256"}'

```
- playload(载荷)
    - 存放过期时间、签发用户等
    - 可以添加用户的非敏感信息
    - base64加密，可以解密
```py
base64.urlsafe_b64decode("eyJ1c2VyX2lkIjoyLCJ1c2VybmFtZSI6ImFlZ2lzIiwiZXhwIjoxNTk3NDI2NjA3LCJlbWFpbCI6ImFlZ2lzQDEyMy5jb20ifQ==")  # 用=补足3的倍数
Out[8]: b'{"user_id":2,"username":"aegis","exp":1597426607,"email":"aegis@123.com"}'
```
- signature
    - 由三部分组成
    - 使用base64加密之后的header +.+ 使用base64加密之后的playload + 使用HS256算法加密，同时secret加盐处理

![](./image/jwt结构.png)
![](./image/认证流程.png)

## 安装
`pip install djangorestframework-simplejwt`

## 配置
### 认证配置
要在setting.py文件 drf认证配置中声明
```py
REST_FRAMEWORK = {
    ...
    'DEFAULT_AUTHENTICATION_CLASSES': (
        ...
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    )
    ...
}
```
### jwt配置
simplejwt也自带一些配置,以下是一些常用的关键字
- ACCESS_TOKEN_LIFETIME: access令牌有效期, 默认为5分钟
- REFRESH_TOKEN_LIFETIME: refresh令牌有效期,默认为24小时
- UPDATE_LAST_LOGIN: 更新最后一次登录时间,默认关闭
- AUTH_HEADER_NAME: 认证头key,默认为`Authorization`
- AUTH_HEADER_TYPES: 认证头类型,默认为 `Bearer`

```py
from datetime import timedelta


SIMPLE_JWT = {
    # "ROTATE_REFRESH_TOKENS": True
    "UPDATE_LAST_LOGIN": True,
    "ACCESS_TOKEN_LIFETIME": timedelta(days=1)
}
```
## 视图
simplejwt自带两个视图,一个是用于获取token,一个是用于更新token使用.两个视图都可以直接使用

```py
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)

urlpatterns = [
    ...
    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    ...
]
```

### 获取token
需要进行账号密码登录, 返回两个token
```json
{
  "access":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiY29sZF9zdHVmZiI6IuKYgyIsImV4cCI6MTIzNDU2LCJqdGkiOiJmZDJmOWQ1ZTFhN2M0MmU4OTQ5MzVlMzYyYmNhOGJjYSJ9.NHlztMGER7UADHZJlxNG0WSi22a2KaYSfd1S-AuT7lU",
  "refresh":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImNvbGRfc3R1ZmYiOiLimIMiLCJleHAiOjIzNDU2NywianRpIjoiZGUxMmY0ZTY3MDY4NDI3ODg5ZjE1YWMyNzcwZGEwNTEifQ.aEoAYkSJjoWH1boshQAaTkf8G3yn0kapko6HFRt7Rh4"
}
```

### 更新token
需要post请求body中携带`refresh token`,返回新的访问token

request:
```json
{
    "refresh":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImNvbGRfc3R1ZmYiOiLimIMiLCJleHAiOjIzNDU2NywianRpIjoiZGUxMmY0ZTY3MDY4NDI3ODg5ZjE1YWMyNzcwZGEwNTEifQ.aEoAYkSJjoWH1boshQAaTkf8G3yn0kapko6HFRt7Rh4"
}
```

response:
```json
{
    "access":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiY29sZF9zdHVmZiI6IuKYgyIsImV4cCI6MTIzNTY3LCJqdGkiOiJjNzE4ZTVkNjgzZWQ0NTQyYTU0NWJkM2VmMGI0ZGQ0ZSJ9.ekxRxgb9OKmHkfy-zs1Ro_xs1eMLXiR17dIDBVxeT-w"
}
```
### 正常访问
需要通过鉴权的访问,需要在请求头中携带`Authorization`,在该key的value前面需要带`Bearer `
```json
{
"Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiY29sZF9zdHVmZiI6IuKYgyIsImV4cCI6MTIzNDU2LCJqdGkiOiJmZDJmOWQ1ZTFhN2M0MmU4OTQ5MzVlMzYyYmNhOGJjYSJ9.NHlztMGER7UADHZJlxNG0WSi22a2KaYSfd1S-AuT7lU"
}
```
## 处理逻辑
1. 请求头中携带token的请求,直接走`DEFAULT_AUTHENTICATION_CLASSES`中设置好的认证类

2. 获取token/更换token
    1. 视图通过`is_valid`进入序列化器的`validate`
    2. 序列化器
        1. 调用父类的`validate`,获得账号密码然后调用`authenticate`方法对账号密码进行校验,返回空字典
        2. `get_token`方法中构造`token`,保存`token`数据
        3. 在空字典中添加`access`和`refresh`这两个token
        4. 返回字典

默认token解析后内容

header
```json
{
  "typ": "JWT",
  "alg": "HS256"
}
```
payload:
- token_type: 令牌类型
- exp: jwt的过期时间戳
```json
{
  "token_type": "access",
  "exp": 1621938053,
  "jti": "30b1567ce55f4aedac44eb55eb1ffa71",
  "user_id": 12,
  "username": "admin11"
}
```


## 自定义
### 自定义获取token
我们可以将获取token的视图当做登录接口使用,但是返回回来的信息太少了.所以我们要对该视图的序列化器进行二次开发,将url配置中的视图改成二次开发后的视图类即可

以下例子对响应做了修改,并对登录时需要的字段进行了增加
- `get_token`中,通过对token这个字典添加内容,可以增加payload中的内容
- `validate`中,通过修改返回值,可以增加响应内容
- `__init__`中,通过添加字段,可以试请求的字段增加,并可以利用序列化器字段做一些限制

序列化器
```py
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer


class TokenSerializer(TokenObtainPairSerializer):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields["sms_code"] = CharField(min_length=4, max_length=4)

    @classmethod
    def get_token(cls, user):
        token = super().get_token(user)
        token["username"] = user.username
        return token

    def validate(self, attrs):
        data = super().validate(attrs)
        data["user_info"] = {  # 添加返回信息
            "name": self.user.get_full_name(),
            "id": self.user.id,
            "last_login": self.user.last_login,
            "is_superuser": self.user.is_superuser,
            "user_permission": self.user.get_all_permissions(),
            "mobile_no": self.user.mobile_no,
            "is_staff": self.user.is_staff,
            "groups": self.user.groups.values("id"),
        }

        return data

    def validate_sms_code(self, data):
        # 对短信验证的校验
        return data
```
视图
```py
class TokenView(TokenObtainPairView):
    serializer_class = TokenSerializer

    def post(self, request, *args, **kwargs):
        response = super().post(request, *args, **kwargs)
        return response
```

### 自定义认证系统
在某些时候我们也可能需要对jwt的认证校验逻辑做一些改造,比如增加ip黑名单功能,在认证的过程中就将用户请求拒绝

以下是一个示范,原意是判断用户是否为激活状态,如果是非激活状态就拒绝,但实际上`JWTAuthentication`在内部已经做了该功能了.但是用来做一个示范还是可以的
```py
from rest_framework_simplejwt.authentication import JWTAuthentication


class TokenAuthentication(JWTAuthentication):

    def authenticate(self, request):
        # (<User: admin11>, {'token_type': 'access', 'exp': 1621501989, 'jti': 'd361f7c6d16e4ceb9e9e6d01a9ba93c1', 'user_id': 12, 'username': 'admin11'})
        obj = super().authenticate(request)
        if obj:  # 父类authenticate已经做了非活跃验证了, 所以逻辑走不到这里
            user, token = obj  # 如果鉴权成功则返回user用户类和token
            if user.is_active is False:
                raise PermissionDenied("用户已被冻结")
            return user, token

        else:
            return obj
```
# 用户系统 User
django默认的User类自带以下字段,但有时候我们需要增加一些字段等,就需要对用户类进行二次开发

如果需要复用django的用户系统就需要继承`AbstractUser`进行二次开发.并且在`setting`中设置新的用户系统

tip: 需要在项目一开始就配置好新的用户类,否则需要手动修改数据,非常麻烦

## 用户模型
```py
from django.db import models
from django.contrib.auth.models import AbstractUser


class User(AbstractUser):
    update_at = models.DateTimeField(auto_now=True)
    mobile_no = models.CharField(max_length=11, unique=True)
```
## 配置设置
当设置这个时,原来的用户类将不会进行创建
```py
AUTH_USER_MODEL = 'users.User'  # 格式: 应用.模型类
```

## 序列化器

```py
class UserModelSerializer(ModelSerializer):
    name = CharField(source="get_full_name", label="姓名", read_only=True)
    permissions = ReadOnlyField(source="get_all_permissions", label="权限")

    class Meta:
        fields = ("id", "username", "password", "last_login", "is_superuser", "email",
                  "is_active", "mobile_no", "groups", "name", "is_staff", "permissions")
        read_only_fields = ["id", "last_login", "is_superuser"]
        model = User
        extra_kwargs = {
            "mobile_no": {
                "min_length": 11,
                "max_length": 11
            },
            "password": {
                "write_only": True
            },
            "is_active": {
                "default": True
            },
            "last_login": {
                "format": "%Y-%m-%d %H:%M:%S",
                "read_only": True
            }
        }
```
## 视图
在实际使用中,用户类基本上都要使用增删改查功能,所以直接继承`ModelViewSet`会更加方便.

但需要对一些功能进行限制,所以又重写了一些函数
- 删除: 
1. 只进行软删除,将用户调整为非激活状态.不进行硬性删除
2. 只有管理员与本人才有权利删除
- 更新:
1. 创建用户后,`username`之类的是不允许修改的,所以需要对请求数据进行限制
2. `update`方法会导致没办法部分修改,所以将`update`方法屏蔽了
3. 只有超管与本人才有权利修改
4. 如果有更新密码就先将其他保存,再通过`user.set_password`对用户的密码进行加密.并保存
- 创建:
1. 先创建用户,再用`user.set_password`对用户的密码进行加密.并保存


除了以上所述,其实还有非常多逻辑需要写,比如修改密码需要二次校验等等
```py
class UserViewSet(ModelViewSet):
    queryset = User.objects.all()
    serializer_class = UserModelSerializer
    # permission_classes = (IsAuthenticated, )


    def perform_destroy(self, instance):  # 冻结用户
        instance.is_active = False
        instance.save()

    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        if instance != request.user and request.user.is_staff:
            self.perform_destroy(instance)
            return Response({"success": True}, status.HTTP_200_OK)
        else:
            raise PermissionDenied("无权操作!")

    def update(self, request, *args, **kwargs):  # username 不可以修改
        if "partial" in kwargs:
            return super().update(request, *args, **kwargs)
        raise MethodNotAllowed("不允许使用该method")

    def partial_update(self, request, *args, **kwargs):
        keywords = ("username", )
        for keyword in keywords:  # 过滤不允许再次修改的值
            request.data.pop(keyword, "")

        if request.user.id == int(kwargs[self.lookup_field]) or request.user.is_staff:  # 自己不可以改自己,除了超管
            user = super().partial_update(request, *args, **kwargs)

        else:
            raise PermissionDenied("请不要改其他人啊!")
        return user

    def perform_update(self, serializer):
        user = serializer.save()
        password = serializer.validated_data.pop("password", None)
        if password:
            user.set_password(password)
            user.save()

    def perform_create(self, serializer):
        user = serializer.save()
        user.set_password(serializer.validated_data["password"])
        user.save()
```
## 用户方法
用户类自带了一些方法
- get_full_name: first name +last name
- get_short_name: first_name
- email_user: 发送邮件
- get_username: 获取用户名
- is_anonymous: 是否匿名用户
- is_authenticated: 是否认证用户
- set_password: 设置密码(加密)
- check_password: 校验密码
- get_user_permissions: 获取用户权限
- get_group_permissions: 获取组权限
- get_all_permissions: 获取 用户+组 权限
- has_perm: 匹配权限
- has_perms: 匹配权限列表
```py
from django.contrib.auth import get_user_model


get_user_model()  # 获取用户类
```
# 系统认证 authentication

## django
django的系统认证在django原生程序中不会主动调用,需要开发者自行调用.

通过`authenticate`方法,会去遍历调用`AUTHENTICATION_BACKENDS`配置的系统认证,任意一个通过就返回请求的用户模型对象.如果开发者没有自定义则默认为`['django.contrib.auth.backends.ModelBackend']`
```py
from django.contrib.auth import authenticate

authenticate()  # 如果校验成功,返回user对象
```
### 自定义
#### 自定义认证
自定义认证,建议要继承于`ModelBackend`去实现

可以重写以下两个函数,以实现自定义
- `authenticate`: 认证逻辑,如果认证通过则返回user对象
- `user_can_authenticate`: 判断用户是否能进入认证(默认非激活用户直接拒绝),返回布尔值.由`authenticate`调用
```py
from django.contrib.auth.backends import ModelBackend


class AuthenticationBackend(ModelBackend):

    def authenticate(self, request, username=None, password=None, **kwargs):
        user = super().authenticate(request, username, password, **kwargs)
        return user
```
#### 配置
setting.py
```py
AUTHENTICATION_BACKENDS = (
    "utils.authentication.AuthenticationBackend"
)
```

## drf
drf的系统认证,在路由调用视图类的`dispatch`方法时,就会调用`initialize_request`进行实例化`Request`对象,

此时在`Request`中就会对`DEFAULT_AUTHENTICATION_CLASSES`中配置的所有系统认证进行调用,直至有一个验证成功

默认使用`BasicAuthentication`和`SessionAuthentication`, 但在实际中我们更多使用JWT做为系统认证,详细可见`simple-jwt`章节


配置
```py
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework.authentication.BasicAuthentication',
        'rest_framework.authentication.SessionAuthentication',
    )
}
```

### 自定义
需要自定义系统认证的可以继承`BaseAuthentication`.通过修改以下2个函数进行实现
- authenticate(self, request): 认证校验逻辑,成功需要以元组形式返回(用户对象,token)
- authenticate_header(self, request): 存在请求头中的标签名 如`Bearer`
```py
from rest_framework.authentication import BaseAuthentication

class MyAuthentication(BaseAuthentication):

    def authenticate(self, request):
        # do...something
        return super().authenticate(request)
```

tip: 如果自定义的系统认证需要使用,需要将其添加到配置中,才会生效
## django认证与drf认证的区别
django自带系统认证,drf也自带了系统认证.这两者有什么区别呢?

django层认证:
1. 在`AUTHENTICATION_BACKENDS`中配置
2. 需要主动通过`django.contrib.auth.authenticate`调用才会使用
3. django自带的认证系统多用来进行登录校验,调用`django.contrib.auth.authenticate`时会遍历`AUTHENTICATION_BACKENDS`中设置的认证系统,直至有一个成功时停止.
4. 如果使用jwt, jwt将在登录认证时,调用`validate`, `validate`将调用`authenticate`进行认证.确认无误后再返回token

drf层认证:
1. 在`REST_FRAMEWORK`的`DEFAULT_AUTHENTICATION_CLASSES`中配置
2. 被动调用,只要视图的父类为`APIView`就会运行认证,但父类非`APIView`将不会运行
    - 调用链: dispatch -> initialize_request -> get_authenticators -> Request
3. 多用来校验后续的认证,如token等.


# 路由器 router
针对`ViewSet`视图集,因为还需要对method进行一一映射配置,较为麻烦

因此drf提供了简单的路由配置方法

在`rest_framework.routers`模块中提供了2个便于进行路由配置的路由器类
- SimpleRouter: 仅注册视图类相关路由,一个方法映射一个路由
- DefaultRouter: 一个方法映射两个路由(增加了format的路由),并且提供了根路由

tip: 在日常使用中,使用`SimpleRouter`即可

`router = SimpleRouter(trailing_slash=False)`:
- `trailing_slash`:用于路由最后是否添加`/`,如果为`True`则需要,为`False`则不需要

通过`ViewSet`中的几个类属性可以修改路由
- `lookup_url_kwarg = 'my_model_id'`: 默认与`lookup_field`,用于路由中需要传参的变量名
- `lookup_value_regex = '[0-9a-f]{32}'`: 传参变量的规则,支持正则表达式

![simplerouter](./image/simplerouter.png)
![defaultrouter](./image/defaultrouter.png)

## 使用
1. 实例化路由器类
2. 注册视图 `register(self, prefix, viewset, basename=None)`
    - prefix: 用于这组路由的URL前缀
    - viewset: 视图集类
    - basename: 可选,用于创建的URL名称,默认为`queryset`的模型名
3. 添加`url`到`urlpatterns`中

路由名
- 默认为`basename`+`-`+list/detail
- 如果是`action`增加的方法,`basename`+`-`+方法名

```py
from rest_framework.routers import SimpleRouter, DefaultRouter

urlpatterns = []

simple = SimpleRouter()
simple.register("book_1", BookModelViewSet)
urlpatterns += simple.urls

simple.urls 
"""
[
    <URLPattern '^book/$' [name='book-list']>, 
    <URLPattern '^book/(?P<pk>[^/.]+)/$' [name='book-detail']>, 
    <URLPattern '^book/(?P<pk>[^/.]+)/custom/$' [name='book-custom']>
    ]
"""

default = DefaultRouter()
default.register("book_2", BookModelViewSet)
urlpatterns += simple.urls

"""
[
    <URLPattern '^$' [name='book-list']>, 
    <URLPattern '^\.(?P<format>[a-z0-9]+)/?$' [name='book-list']>, 
    <URLPattern '^(?P<pk>[^/.]+)/$' [name='book-detail']>, 
    <URLPattern '^(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='book-detail']>, <URLPattern '^(?P<pk>[^/.]+)/custom/$' [name='book-custom']>, 
    <URLPattern '^(?P<pk>[^/.]+)/custom\.(?P<format>[a-z0-9]+)/?$' [name='book-custom']>, 
    <URLPattern '^$' [name='api-root']>, <URLPattern '^\.(?P<format>[a-z0-9]+)/?$' [name='api-root']>
    ]
"""
```
# 过滤&查询&排序 filter
在实际使用中,我们需要对查询的结果进行过滤和排序.drf的filter模块中只提供了`排序`和`查询`功能.对一些需要过滤的请求,虽然我们可以通过重写`get_queryset`的形式进行实现,但这不够方便,所以在过滤上我们需要使用`django-filter`这个第三方库实现


在`GenericAPIView`的子类视图中可以调用`self.filter_queryset(self.get_queryset())`调用过滤器,返回查询集(queryset)

```py
class ViewSet(viewsets.GenericViewSet):
    # ....省略
    
    def list(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())

        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)
```

## 简单实现过滤
在父类为`GenericAPIView`的视图类中我们通过重写`get_queryset`函数就可以实现简单的过滤
```py
class DemoGenericAPIView(GenericAPIView):
    # ...
    def get_queryset(self):  # 根据是否有查询字符串决定返回的查询集
        keyword = self.request.query_params.get('q')
        if not keyword:
            queryset = Article.objects.all()
        else:
            queryset = Article.objects.filter(title__icontains=keyword)
        return queryset
```


## 第三方过滤 django-filter
因为drf并没有提供用于过滤的过滤器,所以在过滤这个功能上面我们需要使用一个第三方库,他能使我们更方便的进行过滤

官方文档: https://django-filter.readthedocs.io/en/stable/
### 安装
`pip install django-filter`

### 注册应用
如果不需要在drf的html中使用,可不注册
```py
INSTALLED_APPS = [
    # ...,
    django_filters,
]
```
### 配置过滤backend
在配置中,如果两者都配置了,具有局部配置的视图类将只使用局部配置

#### 全局配置
在`setting.py`中
```py
REST_FRAMEWORK = {
    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend']
}
```

#### 局部配置
在需要使用的视图类中
```py
from django_filters import rest_framework

class ArticleList(generics.ListCreateAPIView):
  
    filter_backends = (rest_framework.DjangoFilterBackend,)
```
### 配置过滤字段
在需要使用过滤功能的视图类中声明`filterset_fields`类属性,以元组/列表的形式,声明支持过滤的字段(要与数据模型中字段名相同)

tip: 默认声明的都是绝对匹配的!
```py
class BookModelViewSet(ModelViewSet):
    filterset_fields = ("name", "price") 
    # ....
```
### 使用
以查询字符串的形式传递需要过滤的字段,以上方视图配置为例.

可以使用一个字段查询,也可以使用多个.也可以不使用查询

`http://127.0.0.1:5000/book/?name=西游记&price=22.33`: 只要名字为西游记,价格为22.33的书

### 自定义
通过声明`filterset_fields`的字段,过滤规则都是绝对匹配`exact`.

如果我们需要模糊匹配,或者需要对数字大小进行匹配.那么就必须要自定义一个过滤器类了

tip: 自定义的过滤器类需要在类视图中以`filterset_class`为类属性名进行声明,`filterset_class`与`filterset_fields`不可一起使用
```py
from rest_framework import generics
from django_filters import rest_framework as filters
from myapp import Product


class ProductFilter(filters.FilterSet):
    min_price = filters.NumberFilter(field_name="price", lookup_expr='gte')
    max_price = filters.NumberFilter(field_name="price", lookup_expr='lte')
    data = filter.DateTimeFilter(field_name="create_date", method="range_data")

    class Meta:
        model = Product
        fields = ['category', 'in_stock']  # 可以使用的查询字段 fields中的 + 上面声明的三个字段

    def range_data(self, queryset, name, value):  # 自定义字段的方法
        lookup = name + "__range"
        return queryset.filter(lookup=value)


class ProductList(generics.ListAPIView):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = (filters.DjangoFilterBackend,)
    filterset_class = ProductFilter  # 声明使用的过滤器类
```
过滤器字段:
- CharFilter
- BooleanFilter
- RangeFilter
```py
class F(FilterSet):
    """Filter for Books by Price"""
    price = RangeFilter()

    class Meta:
        model = Book
        fields = ['price']

qs = Book.objects.all().order_by('title')

# Range: Books between 5€ and 15€
f = F({'price_min': '5', 'price_max': '15'}, queryset=qs)

# Min-Only: Books costing more the 11€
f = F({'price_min': '11'}, queryset=qs)

# Max-Only: Books costing less than 19€
f = F({'price_max': '19'}, queryset=qs)
```
- TimeRangeFilter
```py
class Comment(models.Model):
    date = models.DateField()
    time = models.TimeField()

class F(FilterSet):
    time = TimeRangeFilter()

    class Meta:
        model = Comment
        fields = ['time']

# Range: Comments added between 8:00 and 10:00
f = F({'time_after': '8:00', 'time_before': '10:00'})

# Min-Only: Comments added after 8:00
f = F({'time_after': '8:00'})

# Max-Only: Comments added before 10:00
f = F({'time_before': '10:00'})
```
- DateFromToRangeFilter
```py
class Comment(models.Model):
    date = models.DateField()
    time = models.TimeField()

class F(FilterSet):
    date = DateFromToRangeFilter()

    class Meta:
        model = Comment
        fields = ['date']

# Range: Comments added between 2016-01-01 and 2016-02-01
f = F({'date_after': '2016-01-01', 'date_before': '2016-02-01'})

# Min-Only: Comments added after 2016-01-01
f = F({'date_after': '2016-01-01'})

# Max-Only: Comments added before 2016-02-01
f = F({'date_before': '2016-02-01'})
```

过滤器类选项: `Filter(field_name=None, lookup_expr=None, *, label=None, method=None, distinct=False, exclude=False)`
- field_name: 过滤依据的模型字段的名称,默认以变量名作为模型字段名.也可以使用联表符`__`, 例如 `hero__name`:过滤关联表的name字段
- lookup_expr: 查找表达式,默认为`exact`绝对匹配,同样支持联表符`__`.他会自动帮你与`field_name`拼接,也就是说如果要查日期中年份大于某年,那么应该填`year_gt`,其会拼接为`field_name`字段名+`__`+`year_gt`
- label: 标签,用于接口文档或者html中显示
- method: 声明该字段需要使用那个函数,如果函数在过滤器类内可以以字符串形式声明,如果在类外则直接传函数对象
- distinct: 去重, 默认为False
- exclude: 除外,默认为False,如果开启后,则不显示命中条件的查询集

https://docs.djangoproject.com/zh-hans/3.2/ref/models/querysets/#field-lookups
## 查询 search
drf的`rest_framework.filters`中提供了`SearchFilter`查询过滤器类.

### 全局配置
同其他过滤器一样,可以在`setting.py`中全局配置. 可以在配置中配置默认过滤器,也可以通过`SEARCH_PARAM`配置 查询过滤器在查询字符串中的`key`, 默认是`search`
```py
REST_FRAMEWORK = {
    'DEFAULT_FILTER_BACKENDS': (
        'rest_framework.filters.SearchFilter'
    ),
    'SEARCH_PARAM': "search"  # 默认是search
}
```
### 局部配置
也可以在视图类中配置
```py
class PermissionViewSet(ReadOnlyModelViewSet):
    queryset = Permission.objects.all()
    serializer_class = PermissionSerializer
    filter_backends = (SearchFilter, )
    search_fields = ("^name", "^codename", "user__username", "group__user__username")
```
### 使用
如果要使用查询功能,必须在视图类中设置`search_fields`类属性,声明支持查询的字段,否则查询无效(也不会报错)

查询时,需要以查询字符串的形式默认以`search`为key传递查询的value,
`search_fields`中声明的每一个字段都是或的意思.即 `name`查到的结果 + `codename`的结果 再去重

`search`中可以以`,`逗号分隔,将查询多个值的交集

tip: `search_fields`声明的字段也支持 联表查询,如上述代码demo
- `user__username`: 权限模型关联的用户模型的username; 
- `group__user__username`: 权限模型关联的组模型关联的用户模型的username

`search_fields`字段还支持下面四种模式,在字段前加上即可,默认是包含匹配
- `^` 开头匹配
- `=` 完全匹配
- `@` 全文搜索,暂时只支持使用`PostgreSQL`数据库
- `$` 正则表达式搜索

e.g `http://127.0.0.1:5000/user/permission/?search=add_book,view`
### 自定义
通过重写`get_search_fields`方法,可以灵活返回需要查询的字段
```py
from rest_framework import filters

class CustomSearchFilter(filters.SearchFilter):
    def get_search_fields(self, view, request):
        if request.query_params.get('title_only'):
            return ['title']
        return super().get_search_fields(view, request)
```

## 排序 ordering
drf的`rest_framework.filters`中提供了`OrderingFilter`排序过滤器类.

### 全局配置
在`setting.py`中设置默认过滤器类,全局基于`genericAPIView`的类都会使用.

通过`DEFAULT_FILTER_BACKENDS`字段以元组/列表的形式可以声明多个过滤器类

通过`ORDERING_PARAM`可以修改排序过滤器类在查询字符串中的key,默认是`ordering`
```py
REST_FRAMEWORK = {
    'DEFAULT_FILTER_BACKENDS': (
        'rest_framework.filters.OrderingFilter'
    ),
    'ORDERING_PARAM': "ordering"  # 默认是ordering
}
```
### 局部配置
- ordering_fields: 用来声明支持排序的字段,如果没有声明则 默认序列化器上的任何可读字段
- ordering: 用来声明 默认的排序字段, `-`代表倒序

```py
class PermissionViewSet(ReadOnlyModelViewSet):
    queryset = Permission.objects.all()
    serializer_class = PermissionSerializer
    filter_backends = (OrderingFilter, )
    ordering_fields = ('id', 'name')  # 声明支持排序的字段,如果没有声明则默认序列化器上的任何可读字段
    ordering = ("-id",)  # 默认排序
```
### 使用
在url中以查询字符串key `ordering`传递需要过滤的字段,如果有多个字段可以用`,`逗号隔开

`http://127.0.0.1:5000/user/user/?ordering=-id,name`: 以倒序排序id字段,再以正序排序name字段

# 异常捕获 exception
drf提供了全局捕获异常的配置,默认使用`rest_framework.views.exception_handler`进行捕获处理.但默认只捕获`APIException`及子类的错误

如果我们需要对异常捕获进行自定义捕获,需要在`setting`中配置`EXCEPTION_HANDLER`
```py
REST_FRAMEWORK = {
    # 默认使用rest_framework.views.exception_handler
    'EXCEPTION_HANDLER': 'utils.exception_handler.catch_exception',  
}
```
## 自定义
```py
from django import db
from rest_framework.views import exception_handler
from rest_framework.response import Response
from rest_framework import status


def catch_exception(exc, context):
    # exc 为异常对象
    # context 为字典, {视图对象, 请求对象, 参数}
    response = exception_handler(exc, context)  # 复用原异常处理, 但只能处理APIException
    if isinstance(exc, db.DatabaseError):  # 判断是否是数据库错误
        response = Response({"err_msg": "数据库错误！"})
        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR
    return response
```
exc context response
```py
# exc:
print(exc)

{
    'detail': ErrorDetail(string='Given token not valid for any token type', code='token_not_valid'), 
    'code': ErrorDetail(string='token_not_valid', code='token_not_valid'), 
    'messages': 
    [
    {
        'token_class': ErrorDetail(string='AccessToken', code='token_not_valid'), 
        'token_type': ErrorDetail(string='access', code='token_not_valid'), 
        'message': ErrorDetail(string='Token is invalid or expired', code='token_not_valid')
        }
    ]
}

print(exc.detail)

{
    'detail': ErrorDetail(string='Given token not valid for any token type', code='token_not_valid'), 
    'code': ErrorDetail(string='token_not_valid', code='token_not_valid'), 
    'messages': [
        {
            'token_class': ErrorDetail(string='AccessToken', code='token_not_valid'), 
            'token_type': ErrorDetail(string='access', code='token_not_valid'), 
            'message': ErrorDetail(string='Token is invalid or expired', code='token_not_valid')
            }
        ]
    }

# context
print(context)

{
    'view': <users.views.UserViewSet object at 0x7fbb12d171d0>, 
    'args': (), 
    'kwargs': {}, 
    'request': <rest_framework.request.Request: GET '/user/user/'>
    } 

# response
print(response)

<Response status_code=401, "text/html; charset=utf-8">
```
# 接口文档 documentation
## 自带接口文档
1. 安装 `pip install coreapi`
2. 全局配置
```py
REST_FRAMEWORK = {
    'DEFAULT_SCHEMA_CLASS': 'rest_framework.schemas.coreapi.AutoSchema'
}
```
3. 路由配置
```py
from rest_framework.documentation import include_docs_urls


urlpatterns = [
    path('docs/', include_docs_urls(title="接口文档")),
]
```
### 注释
通过在类的doc中可以进行注释
```py
class BookModelViewSet(ModelViewSet):  # 最简单实现
    """
    list:
    返回图书列表数据

    retrieve:
    返回图书详情数据

    latest:
    返回最新的图书数据

    read:
    修改图书的阅读量

    """
```


## swagger文档
安装：`pip install drf-yasg`
```py
# 1. setting
INSTALLED_APPS = ['drf_yasg',]

# 2. project的urls中
from drf_yasg.views import get_schema_view
from drf_yasg import openapi

schema_view = get_schema_view(
    openapi.Info(
        title='测试平台接口文档',
        default_version='v1',
        description="详细信息",
        terms_of_service="服务器路径",
        contact=openapi.Contact(email="fungageis@gmail.com"),
        license=openapi.License(name="Test license")
    ),
    public=True,
    # permission_classes=(permissions.AllowAny)
)


urlpatterns = [
    re_path(r'^swagger(?P<format>\.json|\.yaml)$', schema_view.without_ui(cache_timeout=0), name='schema-json'),
    path('swagger/', schema_view.with_ui('swagger', cache_timeout=0), name='swagger-ui'),
    path('redoc/', schema_view.with_ui('redoc', cache_timeout=0), name='swagger-redoc'),
]
```
# 请求 request
继承`from rest_framework.views import APIView`视图类
- Request对Django中的HttpRequest进行了拓展
    - 会根据请求头中的Content-Type，自动进行解析
    - 无论前端发送的哪种格式的数据，都可以以相同的方式读取
- request.data
    - 类似于Django中的`request.POST`和`request.FILES`
    - 可以对POST、PUT、PATCH的请求体参数进行解析
    - 不仅支持form传参，也支持json格式传参
- request.query_params
    - 类似于Django中的`request.GET`
    - 获取查询字符串参数
- 支持Django HttpRequest中所有的对象和方法

以下是request对象的属性
```py
request.query_param  # 查询字符串 
request.data  # 请求体
request.headers  # 请求头 
request.method  # 请求方法
request.META["REMOTE_ADDR"] # 访问ip request.auth 是否认证通过 request.user 用户对象/anon
request.META  # 元数据
request.auth  # 返回任何其他身份验证上下文
request.user  # 用户对象
request.content_type  # 返回代表HTTP请求正文的媒体类型的字符串对象
request.stream  # 返回表示请求正文内容的流
```

# 响应 response
`from rest_framework.response import Response`

`Response(data=None, status=None,template_name=None, headers=None,exception=False, content_type=None)`
- data
    - 序列化处理后的数据
    - 一般为serializer.data（python基本数据类型，字典，嵌套字典的列表）
- status
    - 状态码，默认为200
    - 可以使用`from rest_framework import status`中的常量设置
- template_name
    - 模板名称，使用HTMLRenderer渲染时需指明
- headers
    - 用于存放响应头信息的字典
- content_type
    - 响应头中的Content-Type
    - 通常此参数无需设置，会自动根据前端所需类型数据来设置该参数
# 日志 log
官方推荐日志设置
```py
from pathlib2 import Path

# 给ADMINS发送邮件需要配置
ADMINS = (
 ('admin_name','your@gmail.com'),
)
MANAGERS = ADMINS

# 创建log文件的文件夹
Path(BASE_DIR+"logs").mkdir(parents=True, exist_ok=True)

# 基本配置，可以复用的
LOGGING = {
    "version": 1,
    "disable_existing_loggers": False, # 禁用已经存在的logger实例
    "filters": {"require_debug_false": {"()": "django.utils.log.RequireDebugFalse"}},
    "formatters": { # 定义了两种日志格式
        "verbose": { # 详细
            "format": "%(levelname)s %(asctime)s %(module)s "
            "%(process)d %(thread)d %(message)s"
        },
        'simple': { # 简单
            'format': '[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s'
        },
    },
    "handlers": { # 定义了三种日志处理方式
        "mail_admins": { # 只有debug=False且Error级别以上发邮件给admin
            "level": "ERROR",
            "filters": ["require_debug_false"],
            "class": "django.utils.log.AdminEmailHandler",
        },
        'file': { # 对INFO级别以上信息以日志文件形式保存
            'level': "INFO", 
            'class': 'logging.handlers.RotatingFileHandler',  # 滚动生成日志，切割
            'filename': os.path.join(LOG_DIR,'django.log'),  # 日志文件名
            'maxBytes': 1024 * 1024 * 10,  # 单个日志文件最大为10M
            'backupCount': 5,  # 日志备份文件最大数量
            'formatter': 'simple', # 简单格式
            'encoding': 'utf-8', # 放置中文乱码
        },
        "console": { # 打印到终端console
            "level": "DEBUG",
            "class": "logging.StreamHandler",
            "formatter": "verbose",
        },
    },
    "root": {"level": "INFO", "handlers": ["console"]},
    "loggers": {
        "django.request": { # Django的request发生error会自动记录
            "handlers": ["mail_admins"],
            "level": "ERROR",
            "propagate": True,  # 向不向更高级别的logger传递
        },
        "django.security.DisallowedHost": { # 对于不在 ALLOWED_HOSTS 中的请求不发送报错邮件
            "level": "ERROR",
            "handlers": ["console", "mail_admins"],
            "propagate": True,
        },
    },
}
```
## 使用
使用logging产生的日志都会被捕获
```py
import logging
# 获得logger实例
logger = logging.getLogger(__name__)
def my_view(request, arg1, arg2):
    ...
    if error_happens:
        # 如发生错误，记录错误信息
        logger.error('Something went wrong!')
```
## 其他
也可以搭配 sentry 使用

https://pythondjango.cn/django/advanced/14-logging/

# 跨域 cors
tip: 本段说明写于2021-08-13. 版本为 3.7.0 较之前有部分配置名已经改变,本文以目前最新的配置名编写


官方文档: https://github.com/adamchainz/django-cors-headers
## 安装&注册
1. `pip install django-cors-headers`: 安装
2. 在`setting.py`的`INSTALLED_APPS`中注册
```py
INSTALLED_APPS = [
    # 注册跨域app
    'corsheaders',
]
```
3. 在中间件中注册
要放在`django.middleware.common.CommonMiddleware`前
```py
MIDDLEWARE = [
    # 加入中间件
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware'  # 放在此中间件前
]
```
## 配置
以下三个配置必须选一个进行配置!!
1. `CORS_ALLOWED_ORIGINS`：授权发出跨站点 HTTP 请求的源列表。默认为[]
2. `CORS_ALLOWED_ORIGIN_REGEXES`： 一个字符串列表，表示与被授权发出跨站点 HTTP 请求的 Origins 匹配的正则表达式。默认为[] (当有大量子域名时可以使用)
3. `CORS_ALLOW_ALL_ORIGINS`: 如果True，则允许所有来源。其他限制允许来源的设置将被忽略。默认为False.

以下为可选配置(绝大部分情况下使用默认配置即可, 如果不设置就是默认配置)
1. `CORS_URLS_REGEX`: 限制将发送 CORS 标头的 URL 的正则表达式。默认为`r'^.*$'`，即匹配所有 URL.(用于只允许部分接口进行跨域时). 例如: `/api/` 匹配的规则 `r"^/api/.*$"` 仅支持`/api/`的接口进行跨域
2. `CORS_ALLOW_METHODS`: 允许用于实际请求的 HTTP method列表
3. `CORS_ALLOW_HEADERS`: 支持自定义http请求头信息
4. `CORS_EXPOSE_HEADERS`: 对外暴露的请求头
5. `CORS_PREFLIGHT_MAX_AGE`: 浏览器缓存时间
6. `CORS_ALLOW_CREDENTIALS`: 如果`True`，将允许 cookie 包含在跨站点 HTTP 请求中。默认为`False`

```py
INSTALLED_APPS = [
    # 注册跨域app
    'corsheaders',
]

MIDDLEWARE = [
    # 加入中间件
    'corsheaders.middleware.CorsMiddleware',
]


# 配置白名单
CORS_ALLOWED_ORIGINS  = [
     "https://example.com" ,
     "https://sub.example.com" ,
     "http://localhost:8080" ,
     "http://127.0.0.1:9000" ,
]

# 允许cookie
CORS_ALLOW_CREDENTIALS = True  # 指明在跨域访问中，后端是否支持对cookie的操作

# 允许的请求方式(默认)
CORS_ALLOW_METHODS = (
 'DELETE',
 'GET',
 'OPTIONS',
 'PATCH',
 'POST',
 'PUT',
 'VIEW',
)
# 允许的请求头(默认)
CORS_ALLOW_HEADERS = (
 'XMLHttpRequest',
 'X_FILENAME',
 'accept-encoding',
 'authorization',
 'content-type',
 'dnt',
 'origin',
 'user-agent',
 'x-csrftoken',
 'x-requested-with',
 'Pragma',
)
```

## 流程
1. 浏览器会第一次先发送options请求询问后端是否允许跨域，后端查询白名单中是否有这两个域名
2. 如过域名在白名单中则在响应结果中告知浏览器允许跨域
3. 浏览器第二次发送post请求，携带用户登录数据到后端，完成登录验证操作