Django restframework
# 简介
- 在Django框架基础之上，进行二次开发
- 用于构建Restful API
- 简称为DRF框架
## REST API
RESTful 是一种开发理念，是设计风格而不是标准
- 具象状态传输
- 每一个URL代表一种资源（json, text, 图片, 视频等）
- 请求头Content-Type: 指明给服务端的参数类型
- 请求头Accept：指明希望接收服务端的数据类型
## 特性
- 提供强大的Serializer序列器，可以高效进行序列化和反序列化
- 提供了极为丰富的类视图,MiXIN扩展类,ViewSet视图集
- 提供具备可视化的的WebAPI界面
- 多种身份认证和权限认证
- 强大的排序，过滤，分页，搜索，限流等
- 可扩展性，插件丰富
## api设计规则
1. URL
- 尽量用名词复数形式
- 往往与数据库表名相同
2. 过滤条件（查询字符串）
|命令|描述|
|-|-|
|?limit=10|指定返回记录的数最|
|?offset=10|指定返回记录的开始位置|
|?page=2&size=10|指定第几页和每页的数据条数|
|?sort=name|指定返回结果按照哪个属性排序，以及排序顺序|

3. 版本
- 版本号可以放在URL也可以放在请求头

## 一般处理逻辑

1. 校验用户数据
2. 将请求的数据（如json格式）转换为模型类对象
    - 反序列化
        - 将其他格式（json、xml等）转换为程序中的数据类型
        - 将json格式的字符串转换为Django中的模型类对象
3. 操作数据库
4. 将模型类对象转换为响应的数据（如json格式）
    - 序列化
        - 将程序中的数据类型转换为其他格式（json、xml等）
        - 例如将Django中的模型类对象装换为json字符串

### 错误处理
DRF能自动处理以下异常：
- APIException类或者子类
- Http404
- PermissionDenied

### 数据处理流程
1. 增
- 校验请求参数->反序列化->保存数据->将保存的对象序列化并返回
2. 删
- 判断要删除的数据是否存在->执行数据库删除
3. 改
- 判断要修改的数据是否存在->校验请求参数->反序列化->保存数据->将保存的对象序列化并返回
4. 查
- 查询数据库->将数据序列化并返回

## django优劣
1. 代码冗余
2. 数据校验麻烦，复用性差
3. 编码规范不统一
4. 仅支持json格式的返回，不支持其他类型
5. 仅支持json格式的传参，不支持form表单传参
6. 列表页视图没有分页，过滤，排序

# 使用

## 安装
`pip install djangorestframework`

## 配置
```py
INSTALLED_APPS = [
    'rest_framework',
]
```

## 序列化器
```py
# 建立序列化器类
from rest_framework import serializer

class ProjectSerializer(serializer.Serializer):
    name = serializer.CharField(max_length=200)

# -----------------独立模块---------------------------------
# 视图
from .model import Interfaces
from .serializer import ProjectSerializer
from django.http import JsonResponse

def view_1(request, pk):
    object = Interfaces.object.get(id=pk)
    serializer = ProjectSerializer(instance=object)  # 序列化输出
    return JsonResponse(serializer.data)

def view_2(request):
    object = Interfaces.object.all()
    serializer = ProjectSerializer(instance=object, many=True)  # 如果是查询集对象，需要设置many参数
    return JsonResponse(serializer.data, safe=True)  # 如果是多个数组嵌套，需要开启safe
```
---
```py
# 视图类
class ProjectDetail(View):

    @staticmethod  # 提取公用的方法
    def get_object(pk):
        try:
            project = Interfaces.objects.get(id=pk)
        except project.DoesNotExist:
            return Http404
        return project

    def post(self, request, pk):
        # 反序列化
        json_data = request.body.decode('utf-8')
        dict_data = json.loads(json_data, encoding='utf-8')

        serializer = ProjectSerializer2(data=dict_data)
        # 开始校验前端参数
        try:
            serializer.is_valid(raise_exception=True)  # 如果失败抛出异常
        # 当调用is_valid方法后，才可以调用errors属性，获取错误提示
        except Exception as e:
            return JsonResponse(serializer.errors)
        # 1. 如果在创建序列化器对象的时候，只给data传参，那么调用save()方法，实际调用就是序列化器对象的create()
        project_id = Projects.objects.get(name=dict_data.get("project"))
        serializer.save(project_id=project_id)  # 在save中传参会和合并到validated_data中

        return JsonResponse(serializer.data)

    def put(self, request, pk):
        # 反序列化
        json_data = request.body.decode('utf-8')
        dict_data = json.loads(json_data, encoding='utf-8')
        project = self.get_object(pk)
        serializer = ProjectSerializer2(instance=project, data=dict_data)
        try:
            serializer.is_valid(raise_exception=True)
        except Exception as e:
            return JsonResponse(serializer.errors)
        project_obj = Projects.objects.get(name=dict_data.get("project"))
        serializer.save(project=project_obj)
        # 创建序列化器对象时，同时给instance和data传参，在调用save方法时，实际调用序列化器内的update函数
        return JsonResponse({"success": True})


# -------------------------序列化器


# 自定义校验器
def is_unique_project_name(name):
    if '项目' not in name:
        raise serializers.ValidationError("项目名格式错误")


# 序列化器类
class ProjectSerializer2(serializers.Serializer):
    """demo2
        需要输出什么字段就在序列化器中定义什么
    """
    # label选项相当于verbose_name, help_text
    id = serializers.IntegerField(label='ID', read_only=True)
    # read_only=True指定该字段，只能做序列化输出;write_only=True指定该字段只进行反序列化输入，但不进行序列化输出
    name = serializers.CharField(label='项目名称', max_length=200, help_text='',
                                 validators=[UniqueValidator(queryset=Interfaces.objects.all(), message="name不能重复"),
                                             is_unique_project_name], error_messages={'max_length': '长度不能超过200'})  
                                             # 自定义错误提示 # validators校验器
    leader = serializers.CharField(label='领导', max_length=200)
    tester = serializers.CharField(label='测试', max_length=200)
    programer = serializers.CharField(label='开发', max_length=200)
    publish_app = serializers.CharField(label='发布备注', max_length=200)
    desc = serializers.CharField(label="概述", allow_blank=True, allow_null=True)

    # project = serializers.CharField(max_length=200)  # 外键可不用

    # 字段校验器顺序：在字段定义中从左到右校验 → 校验内置校验器(validate_*) → 多字段联合校验(validate)
    # 单字段的校验,无需在字段中注册,自动识别。
    # start with一定要为validate
    def validate_name(self, value):
        if not value.endswith('项目'):
            raise serializers.ValidationError('项目名称必须以项目结尾')
        # 当校验成功的时候一定要返回value
        return value

    # 多字段校验只能用这个方法名
    def validate(self, attrs):  # 会将所有的反序列化对象传入attrs参数
        if 'icon' not in (attrs['tester'], attrs['leader']):
            raise serializers.ValidationError('tester||leader错误')
        return attrs

    # 当实例化对象时仅传入【instance=模型对象】时在序列化器类对象调用.save()方法时调用该方法
    def create(self, validated_data):
        print(validated_data)
        project = Interfaces.objects.create(**validated_data)
        return project  # 要返回模型对象

    # 当实例化对象时传入【instance=模型对象】和【data=反序列化数据】时在序列化器类对象调用.save()方法时调用该方法
    def update(self, instance, validated_data):  # 在序列化器类对象调用.save()方法时调用该方法
        instance.name = validated_data['name']
        instance.leader = validated_data['leader']
        instance.tester = validated_data['tester']
        instance.programer = validated_data['programer']
        instance.publish_app = validated_data['publish_app']
        instance.desc = validated_data['desc']
        instance.project = validated_data['project']
        instance.save()
        return instance  # 要返回模型对象
```
### CharField等类型限制
|参数|说明|
|-|-|
|max_length|最大长度|
|min_length|最小长度|
|allow_blank|是否允许为空|
|trim_whitespace|是否截断空白字符|
|max_value|最小值|
|min_value|最大值|
### 字段通用限制
|参数|说明|
|-|-|
|read_only|表明该字段仅用于序列化输出，默认False |
|write_only|表明该字段仅用于反序列化输入，默认False |
|required|表明该字段在反序列化时必须输入，默认True |
|default|反序列化时使用的默认值|
|allow_null|表明该字段是否允许传入None，默认False |
|validators|该字段使用的验证器|
|error_messages|包含错误编号与错误信息的字典label用于HTML展示API页面时，显示的字段名称|
|help_text|用于HTML展示API页面时，显示的字段帮助提示信息|

### 7. 反序列化
- 演示反序列化操作：
- 数据校验
    - 在序列化器字段定义时，通过validators选项添加校验器
    - 单字段校验和多字段校验
    - 序列化器字段校验顺序
        - 字段定义时的限制（包含validators列表条目从左到右进行校验）→ 单字段校验（validate_*） → 多字段校验（validate）
- 保存或更新数据库模型

### 8. ModelSerializer 模型序列化器
- 为了简化序列化器类的定义
- 功能
    - 基于模型类自动生成一系列字段
    - 基于模型类自动为Serializer生成validators，比如unique_together
    - 包含默认的create()和update()的实现
```py
# 从表模型
class ProjectModelSerializer(serializers.ModelSerializer):

    # 1. 显示创建序列化器字段（支持不是meta类中指定model的字段）
    name = serializers.CharField(label='项目名称', max_length=200, help_text='',  # 自定义的字段会cover自动创建的字段,
                                 validators=[UniqueValidator(queryset=Interfaces.objects.all(), message="name不能重复"),
                                             is_unique_project_name])  # 当有校验器失败后,会继续校验全部指定的校验器(类的校验器不会)，通过后才会运行类校验器

    # 外键 source默认为变量名，当变量名与外键字段名不同时，需指定source到外键字段名
    # 1. 数据库模型中的外键字段，默认会生成PrimaryKeyRelatedField序列化器类型，序列化输出的值为外键ID值
    project_str = serializers.StringRelatedField(source='project')
    # 2. 当设置为StringRelatedField类型的时候，将被序列化为关联对象字符串表达形式（__str__方法）
    project_slug = serializers.SlugRelatedField(slug_field='leader', source='project', queryset=Projects.objects.all())
    # 3. SlugRelatedField此字段将被序列化为关联对象的指定字段数据
    project_obj = XiProjectModelSerializer(read_only=True, source='project')  # 通常设置为只读
    # 4. 使用关联对象的序列化器

    # 自动创建create update
    class Meta:
        model = Interfaces
        fields = "__all__"
        # fields = ('id', 'name')
        # exclude = ('',)  # 排除项
        read_only_fields = ('id', '')  # 指定read_only字段
        extra_kwargs = {  # 自动添加的才可以, 在该变量内可定制化字段，嵌套字典格式
            'method': {  # 字段参数
                # 'write_only': True,
                'error_messages': {'max_length': '不能大于200字数', 'min_length': '不能小于6位数'}
            },
            'url': {
                # 'write_only': True,
                'validators': [UniqueValidator(queryset=Interfaces.objects.all(), message="name不能重复"),
                               is_unique_project_name]
            }
        }

    def validate_name(self, value):
        if not value.endswith('项目'):
            raise serializers.ValidationError('项目名称必须以项目结尾')
        # 当校验成功的时候一定要返回value
        return value

    def validate(self, attrs):  # 会将所有的反序列化对象传入attrs参数
        if 'icon' not in (attrs['url'], attrs['path']):
            raise serializers.ValidationError('tester||leader错误')
        return attrs

```
```py
# 父表模型
class XiProjectModelSerializer(serializers.ModelSerializer):

    # 父表默认不生成关联字段，可以手动指定，字段名默认为 "关联子表模型类_set"
    # 反向查询
    interfaces_set = serializers.StringRelatedField(many=True)  # 因为父表查子表为结果集，所以要many=True

    class Meta:
        model = Projects
        fields = "__all__"

```
## 请求&响应
```py
#project/settings.py 文件中
#DRF框架所有的全局配置都放在REST_FRAMEWORK这个字典中
REST_FRAMEWORK = {
    #默认响应渲染类
    'DEFAULT_RENDERER_CLASSES':(
        #json渲染器为第优先级
        'rest_framework.renderers.JSONRenderer',
        #可浏览的API渲染器为第二优先级
        'rest_framework.renderers.BrowsableAPIRenderer',
    )
}
```
### 11. DRF的Request
`from rest_framework.views import APIView`视图类继承
- Request对Django中的HttpRequest进行了拓展
    - 会根据请求头中的Content-Type，自动进行解析
    - 无论前端发送的哪种格式的数据，都可以以相同的方式读取
- request.data
    - 类似于Django中的request.POST和request.FILES
    - 可以对POST、PUT、PATCH的请求体参数进行解析
    - 不仅支持form传参，也支持json格式传参
- request.query_params
    - 类似于Django中的request.GET
    - 获取查询字符串参数
- 支持Django HttpRequest中所有的对象和方法

### 12. DRF的Response
`from rest_framework.response import Response`
`Response(data=None, status=None,template_name=None, headers=None,exception=False, content_type=None)`
- data
    - 序列化处理后的数据
    - 一般为serializer.data（python基本数据类型，字典，嵌套字典的列表）
- status
    - 状态码，默认为200
    - 可以使用`from rest_framework import status`中的常量设置
- template_name
    - 模板名称，使用HTMLRenderer渲染时需指明
- headers
    - 用于存放响应头信息的字典
- content_.type
    - 响应头中的Content-Type
    - 通常此参数无需设置，会自动根据前端所需类型数据来设置该参数


## 类视图
### 1. APIView
- 继承Django中的View
- APIView与View的不同之处
    - 传入到视图方法中的是Request对象，而不是Django的HttpRequeset对象
    - 视图方法可以返回Response对象，会为响应数据处理（render）为符合前端要求的格式
    - 任何APIException异常都会被捕获到，并且处理成合适的响应信息
    - 在进行dispatch()分发前，会对请求进行身份认证、权限检查、流量控制
- 常用类属性
    - authentication_classes列表或元祖，身份认证类
    - permissoin_classes列表或元祖，权限检查类
    - throttle_classes 列表或元祖，流量控制类


### 2. GenericAPIView
- 继承APIView
- 支持的类属性
    - 必须指定的属性
        - queryset
        - Iserializer_class
- 支持的类方法
    - get_queryset（self）
        - 返回视图使用的查询集对象
    - get_object（self）
        - 返回详情视图所需的模型类对象
        - 默认使用lookup_field（pk）参 数来过滤
        - 如果访问的模型类对象不存在，会返回404
    - get_serializer（self，*args，**kwargs）
        - 返回序列化器对象
    - get_serializer_class（self）
        - 返回序列化器类，默认返回serializer_class
        - 可以重写

#### 字段
```py
#使用开源的过滤引擎
#pip install django-filter
from django_filters.rest_framework import DjangoFilterBackend


# 1. 视图类中自定过滤引擎
filter_backends = [filters.OrderingFilter, DjangoFilterBackend]
# 2. 指定需要排序的字段
ordering_fields = ['id', 'name', 'url']  # 查询字符串：path?ordering=-name
# 3. 指定查询集
queryset = Interfaces.objects.all()  # 实例时仅会请求一次，不能在方法中直接self.queryset进行使用
# 4. 指定序列化器
serializer_class = ProjectModelSerializer
# 5. 设置主键字段
lookup_field = 'pk'
# 6. 指定需要过滤的字段
filterset_fields = ['name', 'url']  # 查询字符串：path?name=user
# 7. 指定分页引擎
pagination_class = PageNumberPaginationManual
```


#### 排序
- filter_backends
- ordering_fields
```py
# 1. 在类中设置
from rest_framework import filters

# 2. 设置类属性
filter_backends = [filters.OrderingFilter]
# 指定需要排序的字段
ordering_fields = ['-name', 'leader']  # 查询字符串：path?ordering=-name  -为倒序

# ---------------------------

# 3. 在setting中全局设置
REST_FRAMEWORK{
    # 在全局指定过滤引擎
    'DEFAULT_FILTER_BACKENDS': ['rest_framework.filters.OrderingFilter'],
}

```

demo.py

```py
from rest_framework.generics import GenericAPIView
from rest_framework import filters  # 过滤引擎


class InterfacesTitle(GenericAPIView):
    # 常量设置：
    # 1. 视图类中自定过滤引擎
    filter_backends = [filters.OrderingFilter]
    # 2. 指定需要排序的字段
    ordering_fields = ['name', 'leader']
    # 3. 指定查询集
    queryset = Projects.objects.all()  # 实例时仅会请求一次，不能在方法中直接self.queryset进行使用
    # 4. 指定序列化器
    serializer_class = ProjectModelSerializer

    def get(self, request):
        # project = Interfaces.objects.all()
        project = self.get_queryset()
        cleaned_data = self.filter_queryset(project)
        # serializer = ProjectModelSerializer(instance=project, many=True)
        serializer = self.get_serializer(instance=cleaned_data, many=True)
        return Response(serializer.data)

```
#### 过滤
- filter_backends
- ordering_fields

安装 django-filter库：`pip install django-filter` 过滤库
```py
# 1. 安装后需要在setting中设置
INSTALLED_APPS = [
    #...
    'django_filters'
]


# 2. 在类中设置
filter_backends = [DjangoFilterBackend]
# 指定需要过滤的字段
filterset_fields = ['name', 'leader']  # 查询字符串：path?name=user

# ---------------------------

# 3. 在setting中全局设置
REST_FRAMEWORK{
    # 在全局指定过滤引擎
    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.backends.DjangoFilterBackend'],
}
```

#### 分页
```py
# 在setting文件的
REST_FRAMEWORK{
    # 在全局指定分页的引擎
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    # 每页条数
    'PAGE_SIZE': 3,
}
    
```

### MiXins

- RetrieveModelMixin
    - 提供retrieve（request，*args，**kwargs）方法
    - 获取已存在的详情数据（一 条记录）
    - 获取成功，则返回200 OK
    - 如果不存在，则返回404 Not Found
- UpdateModelMixin
    - 提供update（request，*args，**kwargs）方法，用于全更新
    - 提供partial_update（request，*args，**kwargs）方法，用于部分更新，支持PATCH方法
    - 更新已存在的模型实例（更新一条记录）
    - 更新成功，则返回200 OK
    - 如果请求参数有误，则返回400 Bad Request
    - 如果不存在，则返回404 Not Found
- DestroyModelMixin
    - 提供destroy（request，*args，**kwargs）方法
    - 删除-条已存在的数据（删除一 条记录）
    - 删除成功，则返回204 No Content。如果不存在，则返回404 Not Found
- CreateModelMixin
    - 提供create（request，*args，**kwargs）方法
    - 创建新的模型实例（创建新的记录）
    - 创建成功，则返回201 Created
    - 如果请求参数有误，则返回400 Bad Request
 - ListModelMixin
    - 提供list（request，*args，**kwargs）方法
    - 获取已存在的列表数据（获取多条记录）
    - 获取成功，则返回200 OK.

```py
from django import mixins


class InterfacesTitleMiXinDemo(
    GenericAPIView,
    mixins.ListModelMixin,
    mixins.CreateModelMixin,
    mixins.RetrieveModelMixin,
    mixins.UpdateModelMixin,
    mixins.DestroyModelMixin):

    # 1. 视图类中自定过滤引擎
    filter_backends = [filters.OrderingFilter, DjangoFilterBackend]
    # 2. 指定需要排序的字段
    ordering_fields = ['id', 'name', 'url']  # 查询字符串：path?ordering=-name
    # 3. 指定查询集
    queryset = Interfaces.objects.all()  # 实例时仅会请求一次，不能在方法中直接self.queryset进行使用
    # 4. 指定序列化器
    serializer_class = ProjectModelSerializer
    # 5. 设置主键字段
    lookup_field = 'pk'
    # 6. 指定需要过滤的字段
    filterset_fields = ['name', 'url']  # 查询字符串：path?name=user
    # 7. 指定分页引擎
    pagination_class = PageNumberPaginationManual

    def post(self, request, *args, **kwarg):
        return self.create(request, *args, **kwarg)

    def get_list(self, request, *args, **kwargs):  # 进行过滤 排序 分页后，输出列表
        return self.list(request, *args, **kwargs)

    def get(self, request, *args, **kwargs):  # 输出模型数据
        return self.retrieve(request, *args, **kwargs)  #

    def put(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)

    def delete(self, request, *args, **kwargs):
        return self.destroy(request, *args, **kwargs)
```
### Concrete Generic view
- RetrieveAPIView
    - 提供get方法I
    - 继承：RetrieveModelMixin、GenericAPIView
- UpdateAPIView。提供put和patch方法
    - 继承：UpdateModelMixin、GenericAPIView
- DestroyAPIView
    - 提供delete方法
    - 继承：DestoryModelMixin、GenericAPIView
- ListAPIView
    - 提供get方法
    - 继承：ListModelMixin、GenericAPIView
- CreateAPIView
    - 提供post方法
    - 继承：CreateModelMixin、GenericAPIView
- ListCreateAPIView
    - 提供post.get方法
    - 继承：ListModelMixin、CreateModelMixin、GenericAPIView
- RetrieveUpdateAPIView
    - 提供get、put、patch方法
    - 继承：RetrieveModelMixin、UpdateModelMixin、GenericAPIView
- RetrieveDestroyAPIViewI
    - 提供get、delete方法
    - 继承：RetrieveModelMixin、DestroyModelMixin、GenericAPIView
- RetrieveUpdateDestroyAPIView
    - 提供get、put、patch、delete方法
    - 继承：RetrieveModelMixin.UpdateModelMixin、DestroyModelMixin、GenericAPIView

### ViewSet
|请求方法|方法(action)|描述|
|-|-|-|
|GET|retriever|获取详情数据（单条）|
|GET|list|获取列表数据（多条）|
|POST|create|创建数据|
|PUT|update|更新数据|
|PATCH|partial_update|部分更新|
|DELETE|destroy|删除数据|

```py
# ViewSet 不再支持get post等请求方法，只支持action动作
# 但该父类未提供generic的get_serializer、get_object等方法
# 继承GenericViewSet类可以解决
class InterfacesViewSet(viewsets.GenericViewSet):
    # 1. 视图类中自定过滤引擎
    filter_backends = [filters.OrderingFilter, DjangoFilterBackend]
    # 2. 指定需要排序的字段
    ordering_fields = ['id', 'name', 'url']  # 查询字符串：path?ordering=-name
    # 3. 指定查询集
    queryset = Interfaces.objects.all()  # 实例时仅会请求一次，不能在方法中直接self.queryset进行使用
    # 4. 指定序列化器
    serializer_class = ProjectModelSerializer
    # 5. 设置主键字段
    lookup_field = 'pk'
    # 6. 设置url中查询字符串的关键字key名
    lookup_url_kwarg = 'pk'  # 默认与lookup_field相同
    # 7. 指定需要过滤的字段
    filterset_fields = ['name', 'url']  # 查询字符串：path?name=user
    # 8. 指定分页引擎
    pagination_class = PageNumberPaginationManual
    # 9. 设置url中查询字符串页数条数key名
    page_size_query_param = "page_size"

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    def list(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())

        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)

    def retrieve(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(instance)
        return Response(serializer.data)

    def update(self, request, *args, **kwargs):
        partial = kwargs.pop('partial', False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=request.data, partial=partial)
        serializer.is_valid(raise_exception=True)
        serializer.save()

        return Response(serializer.data)

    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        instance.delete()
        return Response(data={"success": True}, status=status.HTTP_204_NO_CONTENT)
```
↓
```py
from rest_framework.decorators import action


# class InterfacesMiXinViewSets(viewsets.ViewSet,
#                               mixins.ListModelMixin,
#                               mixins.DestroyModelMixin,
#                               mixins.UpdateModelMixin,
#                               mixins.RetrieveModelMixin,
#                               mixins.CreateModelMixin):
class InterfacesMiXinViewSets(viewsets.ModelViewSet):
    # 1. 视图类中自定过滤引擎
    filter_backends = [filters.OrderingFilter, DjangoFilterBackend]
    # 2. 指定需要排序的字段
    ordering_fields = ['id', 'name', 'url']  # 查询字符串：path?ordering=-name
    # 3. 指定查询集
    queryset = Interfaces.objects.all()  # 实例时仅会请求一次，不能在方法中直接self.queryset进行使用
    # 4. 指定序列化器
    serializer_class = ProjectModelSerializer
    # 5. 设置主键字段
    lookup_field = 'pk'
    # 6. 设置url中查询字符串的关键字key名
    lookup_url_kwarg = 'pk'  # 默认与lookup_field相同
    # 7. 指定需要过滤的字段
    filterset_fields = ['name', 'url']  # 查询字符串：path?name=user
    # 8. 指定分页引擎
    pagination_class = PageNumberPaginationManual
    # 9. 设置url中查询字符串页数条数key名
    page_size_query_param = "size"

    # 1. 可以使用action装饰器来声明自定义的动作
    # 默认情况下，实例方法名就是动作名
    # methods：用于指定动作支持的请求方法
    # detail：用于指定动作要处理的是否未详情资源对象(url中是否需要传递查询字符串)
    # url_path: path部分名字， 默认为方法名
    # url_name: 设置reserve的端口名， 默认为 类_方法名
    @action(methods=['get'], detail=False, url_path="nm", url_name='get_interfaces_name')
    def names(self, request, *args, **kwargs):
        queryset = self.get_queryset()
        queryset = self.filter_queryset(queryset)
        page = self.paginate_queryset(queryset)
        if page:
            serializer = InterfacesNameSerializer(instance=page, many=True)
            return self.get_paginated_response(serializer.data)
        serializer = InterfacesNameSerializer(instance=queryset, many=True)
        return Response(serializer.data)

    @action(methods=['get'], detail=True, url_path='get_api_id', url_name='get_interfaces_id')
    def project_get_interfaces(self, request, *args, **kwargs):
        queryset = Projects.objects.get(id=kwargs["pk"])
        serializer = InterfacesByProjectIdSerializer(instance=queryset)
        return Response(serializer.data)
```
### 视图集注册路由
```py
from rest_framework import routers


# 方法二,自动注册路由
# 1. 创建simplerouter路由对象
router = routers.SimpleRouter()
# 2. 注册路由
# 第一个参数prefix为路由前缀, 第二个参数viewset为视图集
router.register(r'projects', views.InterfacesMiXinViewSets)

# 方法一(不推荐)
urlpatterns = [
    path('setview/', views.InterfacesViewSet.as_view({
        'get': 'list',
        'post': 'create',
    })),
    path('setview/<int:pk>/', views.InterfacesViewSet.as_view({
        'get': 'retrieve',
        'put': 'update',
        'delete': 'destroy'
    })),
    path('setview/names/', views.InterfacesMiXinViewSets.as_view({
        "get": "names"
    })),
    path('setview/<int:pk>/interfaces/', views.InterfacesMiXinViewSets.as_view({
        "get": "get_id"
    })),
    # 写入映射
    path('', include(router.urls))

]
# 方法三
urlpatterns += router.urls
```
以下为自动生成的url
```
interfaces/ ^projects/$ [name='interfaces-list']
interfaces/ ^projects/nm/$ [name='interfaces-get_interfaces_name']
interfaces/ ^projects/(?P<pk>[^/.]+)/$ [name='interfaces-detail']
interfaces/ ^projects/(?P<pk>[^/.]+)/get_api_id/$ [name='interfaces-get_interfaces_id']
```
### 14. status
```py
from rest_framework import status


Response(serializer.data, status=status.HTTP_200_OK)  # 通过常量展示更加明显
```
### 生成接口文档
#### 简介
1. 生成API文档平台
2. 自动生成测试代码
3. 支持接口测试
#### 安装
1. coreapi
2. pygments
3. markdown

##### coreapi
```py
# 1. 要在setting中注册
REST_FRAMEWORK = {
    'DEFAULT_SCHEMA_CLASS': 'rest_framework.schemas.coreapi.AutoSchema',  # 设置自定导出api文档
}
# 2. 在project的urls中
from rest_framework.documentation import include_docs_urls


urlpatterns = [
    path('docs/', include_docs_urls(title='XX接口文档', description='这个是个接口文档'))
]

# 3. 注释

class InterfacesMiXinViewSets(viewsets.ModelViewSet):
    """
    项目视图集
    project_get_interfaces:  # 具体方法注释
    通过项目ID获取该项目全部接口
    """

# 4. 数据模型中的help_text会显示在具体字段的description
```
##### swagger文档(推荐)
安装：`pip install drf-yasg`
```py
# 1. setting
INSTALLED_APPS = ['drf_yasg',]

# 2. project的urls中
from drf_yasg.views import get_schema_view
from drf_yasg import openapi

schema_view = get_schema_view(
    openapi.Info(
        title='测试平台接口文档',
        default_version='v1',
        description="详细信息",
        terms_of_service="服务器路径",
        contact=openapi.Contact(email="fungageis@gmail.com"),
        license=openapi.License(name="Test license")
    ),
    public=True,
    # permission_classes=(permissions.AllowAny)
)


urlpatterns = [
    re_path(r'^swagger(?P<format>\.json|\.yaml)$', schema_view.without_ui(cache_timeout=0), name='schema-json'),
    path('swagger/', schema_view.with_ui('swagger', cache_timeout=0), name='swagger-ui'),
    path('redoc/', schema_view.with_ui('redoc', cache_timeout=0), name='swagger-redoc'),
]
```

# 测试平台实践

- 架构模式
    - 前后端分离
- 前端架构
    - vue + elementui + vue router + axios
- 后端架构
    - Django + Django restframework + mysql + swagger
- 分析用到的技术点
- 选择哪种数据库
- 如何管理源代码

- 测试平台结构
    - 项目模块
    - 接口模块
    - 用例模块
    - 配置模块
    - 内置函数模块
    - 环境变量模块
    - 套件模块
    - 报告模块
    - 用户模块


## 准备工作
1. setting.py中 `ALLOWED_HOSTS = ["*"]` 允许任意地址访问，否则只能在本机访问

2. setting.py设置日志模块
```py
# 判断是否存在文件夹
log_dir = os.path.join(BASE_DIR, os.path.join("logs", time.strftime("%Y-%m")))
if not os.path.exists(log_dir):
    os.makedirs(log_dir)


LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'simple': {
            'format': '%(asctime)s - [%(levelname)s] - [msg]%(message)s'
        },
        'verbose': {
            'format': '%(asctime)s - [%(levelname)s] - %(name)s - [msg]%(message)s - [%(filename)s:%(lineno)d]'
        },
    },
    'filters': {
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
    },
    'handlers': {
        'console': {
            'level': 'DEBUG',
            'filters': ['require_debug_true'],
            'class': 'logging.StreamHandler',
            'formatter': 'simple'
        },
        'file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': os.path.join(BASE_DIR, os.path.join(log_dir, f"{time.strftime('%Y-%m-%d')}.log")),  # 日志存放位置
            'maxBytes': 100 * 1024 * 1024,  # 单个文件100m
            'backupCount': 10,  # 最多10个文件
            'formatter': 'verbose'
        },
    },
    'loggers': {
        'mytest': {  # 定义日志器
            'handlers': ['console', 'file'],
            'propagate': True,  # 是否允许轮转
            'level': 'DEBUG',
        }
    }
}
```

# 认证和鉴权
## 1. Browsable API页面认证
- 指定permission_classes
- 添加rest_framework.urls路由
```py
from rest-framework import permission


# 1. 在ApiView类中设置属性
permission_classes = [permissions.IsAuthenticated]  # 
# 2. 在setting.py中设置属性
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': ["rest_framework.permissions.IsAuthenticated"] 
}
```
## 2. Json Web Token认证
- 最常用的认证机制.
    - Session认证
    - Token认证
- Session认证
    - 保持在服务端，增加服务器开销
    - 分布式架构中，难以维持Session会话同步
    - CSRF攻击风险
- Token认证(服务端只验不存)
    - 保存在客户端
    - 跨语言、跨平台
    - 拓展性强
    - 鉴权性能高.



### 推荐使用：djangorestframework-jwt
安装： `pip install djangorestframework-jwt`
*drf自带原生token认证，但是不安全不建议使用 authtoken*
```py
# 初始化设置
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [  # 优先级
        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',  # token认证
        'rest_framework.authentication.SessionAuthentication',  # 会话认证
        'rest_framework.authentication.BasicAuthentication',  # 基础认证
    ]
}
```
请求格式，token需在请求头中
```py
http://127.0.0.1:8001/interfaces/projects/

header = {"Authorization": "jwt eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoyLCJ1c2VybmFtZSI6ImFlZ2lzIiwiZXhwIjoxNTk3MzM3NjM0LCJlbWFpbCI6ImFlZ2lzQDEyMy5jb20ifQ.MH9xhMZ1pAWmK3fPnHqdHTeh9aP51yKN7hU-osRpjYg"}  # value中 'jwt + " " + token' key默认为Authorization
```
#### 自定义配置 
在`rest_framework-jwt.setting` 存放着相关配置参数

自定义时在工程`setting.py`文件中
```py
JWT_AUTH = {
    'JWT_EXPIRATION_DELTA': datetime.timedelta(days=1),  # 默认为5分钟
    'JWT_AUTH_HEADER_PREFIX': "xixi",  # 请求前缀
    'JWT_RESPONSE_PAYLOAD_HANDLER': 'utils.jwt_handler.jwt_response_payload_handler',  # 重写方法，返回更多
}
```
新建utils文件夹，jwt_handler.py中
```py
# 重写rest_framework_jwt.utils.jwt_response_payload_handler方法
def jwt_response_payload_handler(token, user=None, request=None):
    return {
    'token': token,
    'user': user.id,
    'username': user.username
    }
```
#### token结构
    eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoyLCJ1c2VybmFtZSI6ImFlZ2lzIiwiZXhwIjoxNTk3NDI2NjA3LCJlbWFpbCI6ImFlZ2lzQDEyMy5jb20ifQ.m_S_dNIXqi_BzpxJz3AOoej2keiVYhT55XPwfJ3wV2Q

jwt由三部分组成：header, playload, signature
- header
    - 声明类型
    - 声明signature的加密算法，默认为HS256
    - 采用base64加密，可以解密
```py
import base64

print(base64.b64decode("eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9"))
Out[2]: b'{"typ":"JWT","alg":"HS256"}'

```
- playload(载荷)
    - 存放过期时间、签发用户等
    - 可以添加用户的非敏感信息
    - base64加密，可以解密
```py
base64.urlsafe_b64decode("eyJ1c2VyX2lkIjoyLCJ1c2VybmFtZSI6ImFlZ2lzIiwiZXhwIjoxNTk3NDI2NjA3LCJlbWFpbCI6ImFlZ2lzQDEyMy5jb20ifQ==")  # 用=补足3的倍数
Out[8]: b'{"user_id":2,"username":"aegis","exp":1597426607,"email":"aegis@123.com"}'
```
- signature
    - 由三部分组成
    - 使用base64加密之后的header +.+ 使用base64加密之后的playload + 使用HS256算法加密，同时secret加盐处理

![](./image/jwt结构.png)
![](./image/认证流程.png)

#### 生成token
```py
from rest_framework_wjt.settings import api_settings


jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER

payload = jwt_payload_handler(user)  # user为用户模型对象
token = jwt_encode_handler(payload)
```
### 注册功能
接口文档
|参数|输入/输出|说明|
|-|-|-|
|用户名|输入输出|6-20位，不能重复|
|密码|输入|6-20位，不能重复|
|确认密码|输入|6-20位，不能重复|
|邮箱|输入|符合邮箱格式|
|token|输出||
```py
# serializer.py
from diango.contrib.auth.models import User
from rest_framwork import serializer
from rest_framwork.validators import UniqueValidator
from rest_framework_wjt.settings import api_settings


class RegisterSerializer(serializer.ModelSerializer):
    password_confirm = serializers.CharField(label="二次确认密码", help_text="二次确认密码",
                                             max_length=20, min_length=6, write_only=True,
                                             error_messages={"max_length": "密码应该小于等于20位字符",
                                                             "min_length": "密码应该大于等于6位字符"})

    token = serializers.CharField(label="令牌", read_only=True)

    class Meta:
        model = User
        fields = ("username", "password", "password_confirm", "email", "token")
        extra_kwargs = {
            "username": {
                "label": "用户名",
                "help_text": "用户名",
                "min_length": 6,
                "max_length": 20,
                "error_messages": {
                    "max_length": "用户名应该小于等于20位字符",
                    "min_length": "用户名应该大于等于6位字符"
                }
            },
            "password": {
                "label": "密码",
                "help_text": "密码",
                "write_only": True,
                "min_length": 6,
                "max_length": 20,
                "error_messages": {
                    "max_length": "密码应该小于等于20位字符",
                    "min_length": "密码应该大于等于6位字符"
                }
            },
            "email": {
                "label": "邮箱",
                "help_text": "邮箱",
                "required": True,
                "allow_blank": False,
                "validators": [UniqueValidator(queryset=User.objects.all(), message="email不能重复")]
            }
        }


    def validate(self, attrs):
    # 联合校验，判断两次密码是否一致
    if not attrs["password"] == attrs["password_confirm"]:
        raise serializers.ValidationError("两次密码不一致")
    return attrs

    def create(self, validated_data: dict):
        validated_data.pop("password_confirm")

        # 方法一：
        # user = super(RegisterSerializer, self).create(validated_data)
        # user.set_password(validated_data["password"])  # 不用该方法密码不会加密
        # user.save()

        # 方法二
        user = User.objects.create_user(**validated_data)

        jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
        jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER

        payload = jwt_payload_handler(user)
        token = jwt_encode_handler(payload)

        user.token = token
        return user


```
### 逻辑删除
继承ModelViewSet，重写perform_destroy方法
```py
def perform_destroy(self, instance):
    instance.is_delete = True
    instance.save()



```

### 跨域（cors）
#### 后端
1. `pip install django-cors-headers`
2. 在setting.py中注册
3. 
```py
    'corsheaders.middleware.CorsMiddleware',  # 要放在下方中间件之前
    'django.middleware.common.CommonMiddleware',  #
```
4. 添加白名单
```py
# True位指定所有域名都可以访问后端接口
CORS_ORIGIN_ALLOW_ALL = True
# 指定访问后端接口的白名单
# CORS_ORIGIN_WHITELIST = [
#
# ]
# 允许跨域携带cookie
CORS_ALLOW_CREDENTIALS = True
```

### 收集静态文件
1. 在setting.py文件中
```py
STATIC_ROOT = os.path.join(BASE_DIR, "STATIC_PATH")
```
2. 命令行: `python manager.py collectstatic`

```py



```

## 注意事项

```py
# 视图类关闭csrf验证
# 需要在url中
from django.views.decorators.csrf import csrf_exempt


urlpatterns = [
    path('<int:pk>/', csrf_exempt(views.ProjectDetail.as_view()))
]


# 外键 onetoone manytomany 字段类型
# 第一个参数为关联的模型路径(可以采用字符串路径，也可以引入)
# 第二个参数设置的是，父表删除之后，该字段的处理方式。
# CASCADE 级联删除，子表也会删除
# SET_NULL 当前外键值会被设置为None
# PROJECT 报错
# SET_DEFAULT 设置默认值
```

# 权限
drf已经实现了基础的权限以请求用户是否为`认证用户` `匿名` `管理员`进行基础鉴权

和搭配django原生权限(增删改查)实现对象级的鉴权

文档: 
1. drf: https://www.django-rest-framework.org/api-guide/permissions/
2. django: https://docs.djangoproject.com/zh-hans/3.2/topics/auth/default/
## django自带权限
django项目中每次执行数据迁移时`migrate`都会通过`post_migrate信号`为首次迁移的model创建四个权限.

默认产生的权限与`ContentType`关联.也可以与`User`和`Group`进行绑定,实现个人权限/组权限

假设你有一个名为 `foo` 应用程序和一个名为 `Bar` 的模型
- 添加：foo.add_bar
- 修改：foo.change_bar
- 删除：foo.delete_bar
- 查看：foo.view_bar

权限表结构
id|name|content_type_id|codename
-|-|-|-
1|Can add permission|2|add_permission

content_type_id 与 content_type表关联

### 使用

#### 与user(用户)类搭配使用

不管是用户自定义的用户类还是系统自带的user(用户)类都应该是继承于`AbstractUser`类.

`AbstractUser`又继承了`AbstractBaseUser, PermissionsMixin`这两个类,前者如字面意思一样主要是一些用户类基础,这个有兴趣了解详见user模块.我们的重点在`PermissionsMixin`,这个类是提供关于权限的函数/属性等,在该类主要提供了以下几个函数
- get_user_permissions(self, obj=None): 返回用户具有的权限
- get_group_permissions(self, obj=None): 返回用户关联的组具有的权限
- get_all_permissions(self, obj=None): 返回用户+组具有的全部权限
- has_perm(self, perm, obj=None): perm传入权限,如果用户具有权限返回True,没有则False
- has_perms(self, perm_list, obj=None): perm传入权限列表,如果用户具有传入的全部权限返回True,没有则False
- has_module_perms(self, app_label): app_label传入模型的app_label,判断是否是被该模型的权限

tip: 
1. 如果没有对认证后端做二次开发,请不要传obj的,该参数入口只是预留使用的.如果传了obj,将返回`set()`空集合
2. 如果是`is_superuser`用户将获得全部权限

以默认认证后端(AUTHENTICATION_BACKENDS)举例
```py
class ModelBackend(BaseBackend):
    # .... 传入obj最终就会走到以下这个方法,并且在校验的时候就直接返回 set()
    def _get_permissions(self, user_obj, obj, from_name):
        """
        ...
        """
        # 判断用户是否为活跃,是否为匿名,obj是否为None
        if not user_obj.is_active or user_obj.is_anonymous or obj is not None:
            return set()

        # ....
```

```py
user.has_perm('app.add_person')  # False
user.has_perms(('app.add_student', 'app.can_deliver_pizzas'))  # True
user.get_all_permissions()  # {'app.change_hero', 'sessions.view_session', 'users.view_user'}
```

#### CBV中使用

tip: 
1. 在视图类必须在首位继承`PermissionRequiredMixin`类,否则将不会调用`PermissionRequiredMixin`的`dispatch`函数,导致鉴权无效
2. 不能与drf的认证(`DEFAULT_AUTHENTICATION_CLASSES`)一起使用,因为drf的认证是在视图层进行的,视图类按照前来后到顺序,会先进行鉴权,但此时并没有进行认证,所以此时用户为匿名用户,鉴权失败
```py
from django.contrib.auth.mixins import PermissionRequiredMixin


class UserViewSet(PermissionRequiredMixin, View):
    permission_required = ("users.view_user", "users.add_user", "users.change_user", "users.delete_user",)
    # ....
```


创建权限的序列化器
```py
from django.contrib.auth.models import Permission
from rest_framework.serializers import ModelSerializer


class PermissionSerializer(ModelSerializer):
    class Meta:
        model = Permission
        fields = "__all__"
```

创建视图
- 本人在设计权限时,只希望使用django提供的增删改查,不想额外添加权限,所以使用了只读视图集.
```py
from rest_framework.viewsets import ReadOnlyModelViewSet
from django.contrib.auth.models import Permission
from .serializers import PermissionSerializer


class PermissionViewSet(ReadOnlyModelViewSet):
    queryset = Permission.objects.all()
    serializer_class = PermissionSerializer
    ordering = ("-id",)
```

## drf
drf提供了几个权限,有四个只做了基础鉴权,有三个需要搭配上述django提供的权限做鉴权

tip:
1. drf的权限都在视图层进行,视图必须继承`APIView`类实现的才可以.
2. 与django权限类搭配的三个权限只能应用于具有`.queryset`属性或`get_queryset()`方法的视图(即继承于`GenericAPIView`类的视图)
3. `DjangoObjectPermissions`类 只是调用了对象级鉴权的操作,但鉴权需要backend.而默认的backend不支持对象级鉴权.所以该类需要搭配`django-guardian`使用.

`rest_framework.permissions`模块
- AllowAny: 任意用户都可以访问(如果使用了鉴权,建议填上)效果与权限为空一样
- IsAuthenticated: 只要鉴权通过,就可以访问
- IsAdminUser: is_staff为True的管理员才可以访问
- IsAuthenticatedOrReadOnly: 只读(SAFE_METHODS)可以访问,经过鉴权的也可以访问

- DjangoModelPermissions: 搭配permission模型使用(需要用户绑定权限),只做了普通权限
- DjangoModelPermissionsOrAnonReadOnly: 同上,但是匿名只读也可以访问
- DjangoObjectPermissions: 同上,但做了对象层鉴权

tip: `permissions`模块中有`SAFE_METHODS`属性,归纳了所有安全访问方法类型(只读类型)
### 使用
使用这几个鉴权类需要在`setting.py`中进行全局配置/在类中以类属性进行局部配置

1. 如果配置了多个鉴权类,访问该视图时需要满足任一个类的鉴权,否则将失败
2. 如果同时配置了全局与局部,将使用局部配置
#### 全局配置
在配置文件中全局配置后,所有父类为`APIView`的视图都会进行鉴权

setting.py
```py
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': (
        'AllowAny',
        'DjangoModelPermissions'
    )
}
```
#### 局部配置
如果同时配置了全局与局部,将使用局部配置.
```py
class UserViewSet(ModelViewSet):
    permission_classes = (IsAuthenticated, )
    # ....
```
### 自定义权限类
#### 权限类介绍
`rest_framework.permissions.BasePermission`为drf所有自带权限类的基类

在`BasePermission`类中主要是对以下2个函数进行重写
- has_permission(self, request, view): 用于对所有访问进行鉴权
- has_object_permission(self, request, view, obj): 用于对访问单个对象的请求进行鉴权

返回True即为通过鉴权,返回False为失败
```py
from rest_framework.permissions import BasePermission


class Permission(BasePermission):

    def has_permission(self, request, view):
        return True

    def has_object_permission(self, request, view, obj):
        return True
```

#### 自定义完善原生权限类
因为drf的3个需要搭配django权限类使用的三个类并没有对只读做详细的鉴权,所以在常规使用时,需要对只读的几个权限做鉴权.主要是补全`GET`,`OPTIONS`,`HEAD`这三个请求方法
```py
class ModelPermission(DjangoModelPermissions):

    perms_map = {
        'GET': ['%(app_label)s.view_%(model_name)s'],
        'OPTIONS': ['%(app_label)s.view_%(model_name)s'],
        'HEAD': ['%(app_label)s.view_%(model_name)s'],
        'POST': ['%(app_label)s.add_%(model_name)s'],
        'PUT': ['%(app_label)s.change_%(model_name)s'],
        'PATCH': ['%(app_label)s.change_%(model_name)s'],
        'DELETE': ['%(app_label)s.delete_%(model_name)s'],
    }
```
### django-guardian
django-guardian 提供了对象级权限的关联和鉴权.

此处不详细展开


# 备用
request.META 元数据
request.auth Token数据(或session等其他)
request.user 用户对象



# 限流Throttling
用于限制用户与视图之间的访问频率,对超过访问频率的请求进行限制

drf自带的限流支持三种模式
- AnonRateThrottle: 对匿名用户进行限流,通过`X-Forwarded-For`(如果没有则用`REMOTE_ADDR`)进行唯一性判别,`rate`标签为: `anon`
- UserRateThrottle: 对已认证的用户进行限流, `rate`标签为: `user`
- ScopedRateThrottle: 通过在视图类属性中设置标签(`throttle_scope`),从而以视图级进行限流

限流单位:
- second: 每秒
- minute: 每分
- hour: 每时
- day: 每天

限流格式: `数量/单位`, 如: `100/day` 每天100次请求

文档: https://www.django-rest-framework.org/api-guide/throttling/

## 配置
### 全局配置
```py
REST_FRAMEWORK = {
    'DEFAULT_THROTTLE_CLASSES': (
        'rest_framework.throttling.AnonRateThrottle',
        'rest_framework.throttling.UserRateThrottle'
    ),
    'DEFAULT_THROTTLE_RATES': {
        'anon': '100/day',
        'user': '1000/day',
        "book": '5/second'  # 类属性中key设置为book
    }
}
```
### 局部配置
```py
class BookModelViewSet(ModelViewSet):
    throttle_classes = (ScopedRateThrottle, )
    throttle_scope = "book"  # 限流的key设置为book
```

# 分页pagination
drf自带三个分页类
- LimitOffsetPagination: 限制偏置分页器,默认以查询字符串`limit`和`offset`进行分页
    - `http://localhost:8000/v1/book/?limit=10&offset=6`: 每页10条从第6条查起
- CursorPagination: 游标分页器,祥可见大江狗文章
- PageNumberPagination: 页面分页器,默认不支持以查询字符串设置每页显示条数,以查询字符串`page`进行分页,如果需要通过查询字符串对条数进行控制,需要进行自定义,详情见自定义模块
    - `http://127.0.0.1:5000/user/user/?page=2`: 第2页


文档: https://www.django-rest-framework.org/api-guide/pagination/

大江狗: https://pythondjango.cn/django/rest-framework/8-pagination/

## 配置

### 全局配置
```py
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10
}
```
### 局部配置
```py
from rest_framework.pagination import PageNumberPagination


class BookModelViewSet(ModelViewSet):
    pagination_class = PageNumberPagination
```
## 自定义分页
继承`PageNumberPagination`实现以查询字符串控制页面显示行数.在全局配置/局部配置中需要改成修改后的类
```py
from rest_framework.pagination import PageNumberPagination


class PagePagination(PageNumberPagination):
    page_query_param = "page"  # page关键字 (默认为page)
    page_size_query_param = "page_size"  # PageNumberPagination 默认为None不使用,如果需要使用,需要重新定义
    max_page_size = 30  # 最大条数
    page_size = 10  # 正常条数
    page_query_description = '第几页'  # 在接口文档中的中文描述
    page_size_query_description = '每页几条'

    def get_paginated_response(self, data):  # 添加总页数和当前页数
        response = super().get_paginated_response(data)
        response.data["total_pages"] = self.page.paginator.num_pages
        response.data["current_page_num"] = self.page.number
        return response
```
`http://127.0.0.1:5000/user/user/?page=2&page_size=20`: 第二页每页20条

# 令牌 simple-jwt
因为`djangorestframework-jwt`已经在17年停止维护了,

所以使用推荐使用`djangorestframework-simplejwt`

官方文档: https://django-rest-framework-simplejwt.readthedocs.io/en/latest/

大江狗: https://pythondjango.cn/django/rest-framework/7-jwt-token-authentication/#simple-jwt%E7%9A%84%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE

可以通过该网址进行解密
https://jwt.io/
## 安装
`pip install djangorestframework-simplejwt`

## 配置
### 认证配置
要在setting.py文件 drf认证配置中声明
```py
REST_FRAMEWORK = {
    ...
    'DEFAULT_AUTHENTICATION_CLASSES': (
        ...
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    )
    ...
}
```
### jwt配置
simplejwt也自带一些配置,以下是一些常用的关键字
- ACCESS_TOKEN_LIFETIME: access令牌有效期, 默认为5分钟
- REFRESH_TOKEN_LIFETIME: refresh令牌有效期,默认为24小时
- UPDATE_LAST_LOGIN: 更新最后一次登录时间,默认关闭
- AUTH_HEADER_NAME: 认证头key,默认为`Authorization`
- AUTH_HEADER_TYPES: 认证头类型,默认为 `Bearer`

```py
from datetime import timedelta


SIMPLE_JWT = {
    # "ROTATE_REFRESH_TOKENS": True
    "UPDATE_LAST_LOGIN": True,
    "ACCESS_TOKEN_LIFETIME": timedelta(days=1)
}
```
## 视图
simplejwt自带两个视图,一个是用于获取token,一个是用于更新token使用.两个视图都可以直接使用

```py
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)

urlpatterns = [
    ...
    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    ...
]
```

### 获取token
需要进行账号密码登录, 返回两个token
```json
{
  "access":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiY29sZF9zdHVmZiI6IuKYgyIsImV4cCI6MTIzNDU2LCJqdGkiOiJmZDJmOWQ1ZTFhN2M0MmU4OTQ5MzVlMzYyYmNhOGJjYSJ9.NHlztMGER7UADHZJlxNG0WSi22a2KaYSfd1S-AuT7lU",
  "refresh":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImNvbGRfc3R1ZmYiOiLimIMiLCJleHAiOjIzNDU2NywianRpIjoiZGUxMmY0ZTY3MDY4NDI3ODg5ZjE1YWMyNzcwZGEwNTEifQ.aEoAYkSJjoWH1boshQAaTkf8G3yn0kapko6HFRt7Rh4"
}
```

### 更新token
需要post请求body中携带`refresh token`,返回新的访问token

request:
```json
{
    "refresh":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImNvbGRfc3R1ZmYiOiLimIMiLCJleHAiOjIzNDU2NywianRpIjoiZGUxMmY0ZTY3MDY4NDI3ODg5ZjE1YWMyNzcwZGEwNTEifQ.aEoAYkSJjoWH1boshQAaTkf8G3yn0kapko6HFRt7Rh4"
}
```

response:
```json
{
    "access":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiY29sZF9zdHVmZiI6IuKYgyIsImV4cCI6MTIzNTY3LCJqdGkiOiJjNzE4ZTVkNjgzZWQ0NTQyYTU0NWJkM2VmMGI0ZGQ0ZSJ9.ekxRxgb9OKmHkfy-zs1Ro_xs1eMLXiR17dIDBVxeT-w"
}
```
### 正常访问
需要通过鉴权的访问,需要在请求头中携带`Authorization`,在该key的value前面需要带`Bearer `
```json
{
"Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiY29sZF9zdHVmZiI6IuKYgyIsImV4cCI6MTIzNDU2LCJqdGkiOiJmZDJmOWQ1ZTFhN2M0MmU4OTQ5MzVlMzYyYmNhOGJjYSJ9.NHlztMGER7UADHZJlxNG0WSi22a2KaYSfd1S-AuT7lU"
}
```
## 处理逻辑
1. 请求头中携带token的请求,直接走`DEFAULT_AUTHENTICATION_CLASSES`中设置好的认证类

2. 获取token/更换token
    1. 视图通过`is_valid`进入序列化器的`validate`
    2. 序列化器
        1. 调用父类的`validate`,获得账号密码然后调用`authenticate`方法对账号密码进行校验,返回空字典
        2. `get_token`方法中构造`token`,保存`token`数据
        3. 在空字典中添加`access`和`refresh`这两个token
        4. 返回字典

默认token解析后内容

header
```json
{
  "typ": "JWT",
  "alg": "HS256"
}
```
payload:
- token_type: 令牌类型
- exp: 时间戳
```json
{
  "token_type": "access",
  "exp": 1621938053,
  "jti": "30b1567ce55f4aedac44eb55eb1ffa71",
  "user_id": 12,
  "username": "admin11"
}
```


## 自定义
### 自定义获取token
我们可以将获取token的视图当做登录接口使用,但是返回回来的信息太少了.所以我们要对该视图的序列化器进行二次开发,将url配置中的视图改成二次开发后的视图类即可

以下例子对响应做了修改,并对登录时需要的字段进行了增加
- `get_token`中,通过对token这个字典添加内容,可以增加payload中的内容
- `validate`中,通过修改返回值,可以增加响应内容
- `__init__`中,通过添加字段,可以试请求的字段增加,并可以利用序列化器字段做一些限制

序列化器
```py
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer


class TokenSerializer(TokenObtainPairSerializer):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields["sms_code"] = CharField(min_length=4, max_length=4)

    @classmethod
    def get_token(cls, user):
        token = super().get_token(user)
        token["username"] = user.username
        return token

    def validate(self, attrs):
        data = super().validate(attrs)
        data["user_info"] = {  # 添加返回信息
            "name": self.user.get_full_name(),
            "id": self.user.id,
            "last_login": self.user.last_login,
            "is_superuser": self.user.is_superuser,
            "user_permission": self.user.get_all_permissions(),
            "mobile_no": self.user.mobile_no,
            "is_staff": self.user.is_staff,
            "groups": self.user.groups.values("id"),
        }

        return data

    def validate_sms_code(self, data):
        # 对短信验证的校验
        return data
```
视图
```py
class TokenView(TokenObtainPairView):
    serializer_class = TokenSerializer

    def post(self, request, *args, **kwargs):
        response = super().post(request, *args, **kwargs)
        return response
```

### 自定义认证系统
在某些时候我们也可能需要对jwt的认证校验逻辑做一些改造,比如增加ip黑名单功能,在认证的过程中就将用户请求拒绝

以下是一个示范,原意是判断用户是否为激活状态,如果是非激活状态就拒绝,但实际上`JWTAuthentication`在内部已经做了该功能了.但是用来做一个示范还是可以的
```py
from rest_framework_simplejwt.authentication import JWTAuthentication


class TokenAuthentication(JWTAuthentication):

    def authenticate(self, request):
        # (<User: admin11>, {'token_type': 'access', 'exp': 1621501989, 'jti': 'd361f7c6d16e4ceb9e9e6d01a9ba93c1', 'user_id': 12, 'username': 'admin11'})
        obj = super().authenticate(request)
        if obj:  # 父类authenticate已经做了非活跃验证了, 所以逻辑走不到这里
            user, token = obj  # 如果鉴权成功则返回user用户类和token
            if user.is_active is False:
                raise PermissionDenied("用户已被冻结")
            return user, token

        else:
            return obj
```
# 用户User系统
django默认的User类自带以下字段,但有时候我们需要增加一些字段等,就需要对用户类进行二次开发

如果需要复用django的用户系统就需要继承`AbstractUser`进行二次开发.并且在`setting`中设置新的用户系统

tip: 需要在项目一开始就配置好新的用户类,否则需要手动修改数据,非常麻烦

## 用户模型
```py
from django.db import models
from django.contrib.auth.models import AbstractUser


class User(AbstractUser):
    update_at = models.DateTimeField(auto_now=True)
    mobile_no = models.CharField(max_length=11, unique=True)
```
## 配置设置
当设置这个时,原来的用户类将不会进行创建
```py
AUTH_USER_MODEL = 'users.User'  # 格式: 应用.模型类
```

## 序列化器

```py
class UserModelSerializer(ModelSerializer):
    name = CharField(source="get_full_name", label="姓名", read_only=True)
    permissions = ReadOnlyField(source="get_all_permissions", label="权限")

    class Meta:
        fields = ("id", "username", "password", "last_login", "is_superuser", "email",
                  "is_active", "mobile_no", "groups", "name", "is_staff", "permissions")
        read_only_fields = ["id", "last_login", "is_superuser"]
        model = User
        extra_kwargs = {
            "mobile_no": {
                "min_length": 11,
                "max_length": 11
            },
            "password": {
                "write_only": True
            },
            "is_active": {
                "default": True
            },
            "last_login": {
                "format": "%Y-%m-%d %H:%M:%S",
                "read_only": True
            }
        }
```
## 视图
在实际使用中,用户类基本上都要使用增删改查功能,所以直接继承`ModelViewSet`会更加方便.

但需要对一些功能进行限制,所以又重写了一些函数
- 删除: 
1. 只进行软删除,将用户调整为非激活状态.不进行硬性删除
2. 只有管理员与本人才有权利删除
- 更新:
1. 创建用户后,`username`之类的是不允许修改的,所以需要对请求数据进行限制
2. `update`方法会导致没办法部分修改,所以将`update`方法屏蔽了
3. 只有超管与本人才有权利修改
4. 如果有更新密码就先将其他保存,再通过`user.set_password`对用户的密码进行加密.并保存
- 创建:
1. 先创建用户,再用`user.set_password`对用户的密码进行加密.并保存


除了以上所述,其实还有非常多逻辑需要写,比如修改密码需要二次校验等等
```py
class UserViewSet(ModelViewSet):
    queryset = User.objects.all()
    serializer_class = UserModelSerializer
    raise_exception = True
    # permission_classes = (IsAuthenticated, )
    ordering = ("-id",)

    def perform_destroy(self, instance):  # 冻结用户
        instance.is_active = False
        instance.save()

    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        if instance != request.user and request.user.is_staff:
            self.perform_destroy(instance)
            return Response({"success": True}, status.HTTP_200_OK)
        else:
            raise PermissionDenied("无权操作!")

    def update(self, request, *args, **kwargs):  # username 不可以修改
        if "partial" in kwargs:
            return super().update(request, *args, **kwargs)
        raise MethodNotAllowed("不允许使用该method")

    def partial_update(self, request, *args, **kwargs):
        keywords = ("username", )
        for keyword in keywords:  # 过滤不允许再次修改的值
            request.data.pop(keyword, "")

        if request.user.id == int(kwargs[self.lookup_field]) or request.user.is_staff:  # 自己不可以改自己,除了超管
            user = super().partial_update(request, *args, **kwargs)

        else:
            raise PermissionDenied("请不要改其他人啊!")
        return user

    def perform_update(self, serializer):
        user = serializer.save()
        password = serializer.validated_data.pop("password", None)
        if password:
            user.set_password(password)
            user.save()

    def perform_create(self, serializer):
        user = serializer.save()
        user.set_password(serializer.validated_data["password"])
        user.save()
```
## 用户方法
用户类自带了一些方法
- get_full_name: first name +last name
- get_short_name: first_name
- email_user: 发送邮件
- get_username: 获取用户名
- is_anonymous: 是否匿名用户
- is_authenticated: 是否认证用户
- set_password: 设置密码(加密)
- check_password: 校验密码
- get_user_permissions: 获取用户权限
- get_group_permissions: 获取组权限
- get_all_permissions: 获取 用户+组 权限
- has_perm: 匹配权限
- has_perms: 匹配权限列表
```py
from django.contrib.auth import get_user_model


get_user_model()  # 获取用户类
```
# 系统认证 authentication

## django
django的系统认证在django原生程序中不会主动调用,需要开发者自行调用.

通过`authenticate`方法,会去遍历调用`AUTHENTICATION_BACKENDS`配置的系统认证,任意一个通过就返回请求的用户模型对象.如果开发者没有自定义则默认为`['django.contrib.auth.backends.ModelBackend']`
```py
from django.contrib.auth import authenticate

authenticate()  # 如果校验成功,返回user对象
```
### 自定义
#### 自定义认证
自定义认证,建议要继承于`ModelBackend`去实现

可以重写以下两个函数,以实现自定义
- `authenticate`: 认证逻辑,如果认证通过则返回user对象
- `user_can_authenticate`: 判断用户是否能进入认证(默认非激活用户直接拒绝),返回布尔值.由`authenticate`调用
```py
from django.contrib.auth.backends import ModelBackend


class AuthenticationBackend(ModelBackend):

    def authenticate(self, request, username=None, password=None, **kwargs):
        user = super().authenticate(request, username, password, **kwargs)
        return user
```
#### 配置
setting.py
```py
AUTHENTICATION_BACKENDS = (
    "utils.authentication.AuthenticationBackend"
)
```

## drf
drf的系统认证,在路由调用视图类的`dispatch`方法时,就会调用`initialize_request`进行实例化`Request`对象,此时在`Request`中就会对`DEFAULT_AUTHENTICATION_CLASSES`中配置的所有系统认证进行调用,直至有一个验证成功

默认使用`BasicAuthentication`和`SessionAuthentication`, 但在实际中我们更多使用JWT做为系统认证,详细可见`simple-jwt`章节

配置
```py
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework.authentication.BasicAuthentication',
        'rest_framework.authentication.SessionAuthentication',
    )
}
```

### 自定义
需要自定义系统认证的可以继承`BaseAuthentication`.通过修改以下2个函数进行实现
- authenticate(self, request): 认证校验逻辑,成功需要以元组形式返回(用户对象,token)
- authenticate_header(self, request): 存在请求头中的标签名 如`Bearer`
```py
from rest_framework.authentication import BaseAuthentication

class MyAuthentication(BaseAuthentication):

    def authenticate(self, request):
        # do...something
        return super().authenticate(request)
```

tip: 如果自定义的系统认证需要使用,需要将其添加到配置中,才会生效
## django认证与drf认证的区别
django自带系统认证,drf也自带了系统认证.这两者有什么区别呢?

django层认证:
1. 在`AUTHENTICATION_BACKENDS`中配置
2. 需要主动通过`django.contrib.auth.authenticate`调用才会使用
3. django自带的认证系统多用来进行登录校验,调用`django.contrib.auth.authenticate`时会遍历`AUTHENTICATION_BACKENDS`中设置的认证系统,直至有一个成功时停止.

drf层认证:
1. 在`REST_FRAMEWORK`的`DEFAULT_AUTHENTICATION_CLASSES`key中配置
2. 被动调用,只要视图的父类为`APIView`就会运行认证,但父类非`APIView`将不会运行
3. 多用来校验后续的认证,如token等.

# 视图 view
## APIView
`APIView`继承自`View`.类方法名跟请求方法名一致即可通过该请求方法访问到该类方法

类中主要新增了 限流,系统认证,权限等配置属性和函数(列举三个常用属性)
- authentication_classes: 系统认证
- throttle_classes: 限流
- permission_classes: 权限

一个`get`的逻辑抽象可分为
1. ORM调用
2. 序列化
3. 返回响应

一个`post`的逻辑抽象可分为:
1. 反序列化(实例化 + 校验)
2. 返回响应

```py
from rest_framework import status
from rest_framework.response import Response


class BookAPIView(APIView):

    def get(self, request, format=None):
        book = Book.objects.all()
        serializer = BookSerializer(book, many=True)
        return Response(serializer.data)

    def post(self, request, format=None):
        serializer = BookSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
```
## GenericAPIView
`GenericAPIView`继承自`APIView`,相较`APIView`新增了查询集 序列化类 查询关键字 过滤 分页等属性和方法

属性: 
- queryset
- serializer_class
- lookup_field
- lookup_url_kwarg
- filter_backends
- pagination_class

方法:
- get_queryset
- get_object
- get_serializer

## mixin
`rest_framework.mixins`模块中,提供了五个通用的类.涵盖`增删改查(单/多)`.mixins模块中的类与继承自`GenericAPIView`的视图类都可以很好的结合使用.

- CreateModelMixin: 新增类,提供了新增的方法
    - create: 方法中提供了反序列化,调用`perform_create`及响应
    - perform_create: 提供反序列化保存
- ListModelMixin
    - list: 进行序列化+分页+响应 
- RetrieveModelMixin
    - retrieve: 序列化+响应
- UpdateModelMixin
    - update: 进行反序列化+模型实例+调用`perform_update`+响应
    - perform_update: 序列化实例保存
    - partial_update: 部分更新,调用`update`传入`partial=True`
- DestroyModelMixin
    - destroy: 获取单个对象,调用`perform_destroy`
    - perform_destroy: 删除

## ViewSet
`ViewSet`继承自`ViewSetMixin`和`APIView`.

`ViewSetMixin`结合`GenericAPIView`生成了`GenericViewSet`.

`GenericViewSet`与`mixins`结合又生成了
- ReadOnlyModelViewSet: 只支持查看单个和查看多个
- ModelViewSet: 支持增删改(部分/全部)查(单/多)

视图集重点就在`ViewSetMixin`上,`ViewSetMixin`重写了`as_view`方法,使请求方法与类方法可以自由绑定.增删改查(单/多)都可以在同一个视图集里面.设置路由更加方便
1. 在设置路由时指定 请求方法和类方法
2. 通过`Router`注册视图集自动生成路由
3. 通过`action`可以添加自定义方法

### 路由
手动绑定请求方法与类方法,注意`detail`不能使用该类名
```py
urlpatterns = [
    path('hero', views.HeroViewSet.as_view({'get': 'list', 'post': "create"})),
    path('hero/<int:pk>', views.HeroViewSet.as_view({'get': 'retrieve', 'put': 'update'}))
]
```
---

实例化`Router`,对视图进行注册.详情可见`Router`章节
```py
router = SimpleRouter()
router.register(r"book", views.BookModelViewSet, basename="book")
urlpatterns += router.urls

router.urls
"""
自动生成的路由
[
    <URLPattern '^book/$' [name='book-list']>, 用于get/post 查看(多)和新建
    <URLPattern '^book/(?P<pk>[^/.]+)/$' [name='book-detail']>,   用于put patch delete get 删改查(单) 
    <URLPattern '^book/(?P<pk>[^/.]+)/custom/$' [name='book-custom']>  这个路由是用action新增的 也会自动添加
    ]
"""
```

### action
`from rest_framework.decorators import action`
action(methods=None, detail=None, url_path=None, url_name=None, **kwargs)
- methods：用于指定动作支持的请求方法
- detail：用于指定动作要处理的是否未详情资源对象(url中是否需要传递查询字符串)
- url_path: path部分名字， 默认为方法名
- url_name: 设置reserve的端口名， 默认为 `类_方法名`

tip:
1. 如果detail=True, 则路由为`路由注册时的名字/路由参数(lookup_field)/方法名或url_path`组成
2. 如果detail=False, 则路由为`路由注册时的名字/方法名或url_path`组成

```py
class BookModelViewSet(ModelViewSet):
    # ...省略

    @action(methods=["get", "post"], detail=True)
    def custom(self, request, pk, **kwargs):
        return Response({"return": pk, "action": self.action, "kwargs": kwargs})
```

### ModelViewSet
```py
from rest_framework.viewsets import ModelViewSet


class BookModelViewSet(ModelViewSet):
    """
    list:
    返回图书列表数据

    retrieve:
    返回图书详情数据

    latest:
    返回最新的图书数据

    read:
    修改图书的阅读量

    """
    queryset = models.Book.baseobjects.get_not_null()
    serializer_class = serializers.BookModelSerializer
    throttle_scope = "book"
    # authentication_classes = (BasicAuthentication, SessionAuthentication, TokenAuthentication)
    permission_classes = (IsAuthenticated,)
    # throttle_classes = (UserRateThrottle, )
    throttle_classes = (ScopedRateThrottle, )
    throttle_scope = "book"
    # pagination_class = PageNumberPagination
    pagination_class = PagePagination
    filter_backends = (DjangoFilterBackend, OrderingFilter, SearchFilter)
    filterset_fields = ("name", "price")  # 过滤字段
    search_fields = ('name', )  # 查询匹配过滤字段, 只可以用于 CharField/TextField
    ordering_fields = ('id', 'name', 'price')  # 也可以使用__all__
    ordering = ("-id", )  # 默认排序

    @action(methods=["get", "post"], detail=True)
    def custom(self, request, pk, **kwargs):
        return Response({"return": pk, "action": self.action, "kwargs": kwargs})
```

# 路由 router
针对`ViewSet`视图集,因为还需要对method进行一一映射配置,较为麻烦

因此drf提供了简单的路由配置方法

在`rest_framework.routers`模块中提供了2个便于进行路由配置的路由器类
- SimpleRouter: 仅注册视图类相关路由,一个方法映射一个路由
- DefaultRouter: 一个方法映射两个路由(增加了format的路由),并且提供了根路由

tip: 在日常使用中,使用`SimpleRouter`即可

`router = SimpleRouter(trailing_slash=False)`:
- `trailing_slash`:用于路由最后是否添加`/`,如果为`True`则需要,为`False`则不需要

通过`ViewSet`中的几个类属性可以修改路由
- `lookup_url_kwarg = 'my_model_id'`: 默认与`lookup_field`,用于路由中需要传参的变量名
- `lookup_value_regex = '[0-9a-f]{32}'`: 传参变量的规则,支持正则表达式

![simplerouter](./image/simplerouter.png)
![defaultrouter](./image/defaultrouter.png)

## 使用
1. 实例化路由器类
2. 注册视图 `register(self, prefix, viewset, basename=None)`
    - prefix: 用于这组路由的URL前缀
    - viewset: 视图集类
    - basename: 可选,用于创建的URL名称,默认为`queryset`的模型名
3. 添加`url`到`urlpatterns`中

路由名
- 默认为`basename`+`-`+list/detail
- 如果是`action`增加的方法,`basename`+`-`+方法名

```py
from rest_framework.routers import SimpleRouter, DefaultRouter

urlpatterns = []

simple = SimpleRouter()
simple.register("book_1", BookModelViewSet)
urlpatterns += simple.urls

simple.urls 
"""
[
    <URLPattern '^book/$' [name='book-list']>, 
    <URLPattern '^book/(?P<pk>[^/.]+)/$' [name='book-detail']>, 
    <URLPattern '^book/(?P<pk>[^/.]+)/custom/$' [name='book-custom']>
    ]
"""

default = DefaultRouter()
default.register("book_2", BookModelViewSet)
urlpatterns += simple.urls

"""
[
    <URLPattern '^$' [name='book-list']>, 
    <URLPattern '^\.(?P<format>[a-z0-9]+)/?$' [name='book-list']>, 
    <URLPattern '^(?P<pk>[^/.]+)/$' [name='book-detail']>, 
    <URLPattern '^(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='book-detail']>, <URLPattern '^(?P<pk>[^/.]+)/custom/$' [name='book-custom']>, 
    <URLPattern '^(?P<pk>[^/.]+)/custom\.(?P<format>[a-z0-9]+)/?$' [name='book-custom']>, 
    <URLPattern '^$' [name='api-root']>, <URLPattern '^\.(?P<format>[a-z0-9]+)/?$' [name='api-root']>
    ]
"""
```
# 过滤
在实际使用中,我们经常需要对查询的结果进行过滤和排序


在drf的`GenericAPIView`中我们通过重写`get_queryset`可以实现简单的过滤.但该方式也有他的弊端,复用性不够好.
```py
class DemoGenericAPIView(GenericAPIView):
    # ...
    def get_queryset(self):
        keyword = self.request.query_params.get('q')
        if not keyword:
            queryset = Article.objects.all()
        else:
            queryset = Article.objects.filter(title__icontains=keyword)
        return queryset
```
## django-filter
因此在过滤这个功能上面我们需要使用一个第三方库,他能使我们更方便的进行过滤

### 安装
`pip install django-filter`

### 注册应用
```py
INSTALLED_APPS = [
    # ...,
    django_filters,
]
```
### 配置过滤
全局配置, 在`setting.py`中
```py
REST_FRAMEWORK = {
    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend']
}
```

局部配置, 在需要使用的视图类中
```py
from django_filters import rest_framework

class ArticleList(generics.ListCreateAPIView):
  
    filter_backends = (rest_framework.DjangoFilterBackend,)
```
# 异常捕获

# 接口文档