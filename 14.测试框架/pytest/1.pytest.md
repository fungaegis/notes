# 入门
## 1.常用命令
- `pip install -U pytest`: 安装pytest
- `pytest -V`: 查看pytest版本
- `pytest -h`: 显示命令行及配置文件选项帮助信息
- `pytest --fixtures`: 显示可用的内置方法参数
- `pytest --cache-show`: 查看缓存
- `pytest --collect-only`: 显示用例ID
- `pytest --instafail`: 实时显示报错日志

## 2.运行命令
- `pytest`: 会执行当前目录及子目录下所有符合发现标准的文件
- `pytest test_sample.py`: 指定模块运行
- `pytest testing/`: 指定目录


参数
- `-q` 静默模式 
    - e.g. `pytest -q test_sample.py`
- `-s`: 输出程序输出
- `-v`: 详细模式
- `-x`: 失败就停止
    - e.g. `pytest -x`
- `--maxfail=n`: 第n次失败后停止
    - e.g. `pytest --maxfail=3`


### 1.标记运行

- `pytest -m mark`: 通过标记(mark)运行
    - e.g. `pytest -m smoke` 运行所有带有`@pytest.mark.smoke`装饰器的用例
    - e.g. `pytest -m "not smoke"` 运行带somke标记外的用例
    ```py
    @pytest.mark.smoke
    class TestDemo:
        def test_answer(self):
            assert func(3) == 5
    ```

### 2.按节点运行
`pytest modular::Class::function`按节点id(nodeid)运行: 模块名::类名::函数名::参数
- e.g. `pytest test_sample.py::test_answer` 运行`test_sample.py`模块内的`test_answer`用例
```py
def func(n):
    return n+1


def test_answer(): # 只会运行这个
    assert func(3) == 5


class TestDemo:
    def test_answer(self):
        assert func(3) == 5
```

### 3.按表达式运行
`-k 'expression'`: 运行表达式匹配的用例,包括文件名,类名,函数名作为变量,支持python运算符(`and`和`or`) 运算符
- e.g. `pytest -k "MyClass and not method"` 运行含有 `"MyClass"`的文件名,类名,函数名, 不运行含有`method`的文件名,类名,函数名.例如:将运行`TestMyClass.test_something`但不运行`TestMyClass.test_method_simple`

### 4.指定状态摘要

- `pytest -r`: 指定状态结果摘要(short test summary info) 有的话会显示,如果没有的话完全不显示
    - `pytest -ra`: 除了执行通过(Pass)以外所有的结果
    - `pytest -rf`: 失败的用例
    - `pytest -rE`: 出错的用例
    - `pytest -rs`: 跳过的用例
    - `pytest -rx`: 标记失败的用例
    - `pytest -rX`: 标记成功的用例
    - `pytest -rp`: 成功用例
    - `pytest -rP`: 成功用例并输出信息

也可以进行组合
    - e.g. `pytest -rfs` 只查看失败和跳过的用例

- `--durations=n`: 显示执行最慢的n条用例
    - 默认情况下不展示<0.005的用例, 使用`-vv`可开启 e.g.: `--durations=n -vv`

### 5.根据结果重运行
同状态按文件修改时间排序, 最新的文件首先出现
- `pytest --lf` or `pytest --last-failed`: 只重新运行故障
- `pytest --ff` or `pytest --failed-first`: 先运行故障然后再运行其余的测试
- `pytest --nf` or `pytest --new-first`: 首先运行新的测试,然后是其余的测试
```py
import pytest

@pytest.mark.parametrize("i",range(50))
def test_num(i):
    if i in (17,25):
       pytest.fail("bad luck")
```



## 3.退出code
- exit code 0: 收集并成功通过所有测试用例
- exit code 1: 收集并运行了测试,部分测试用例执行失败
- exit code 2: 测试执行被用户中断
- exit code 3: 执行测试中发生内部错误
- exit code 4: pytest命令行使用错误
- exit code 5: 没有收集到测试用例

## 4.用例收集策略
1. file name：`test_*.py` 或者 `*test.py`
2. class name：`Test*` 且类内没有 `__init__` 函数
3. function name: `test_*`
4. 先按模块名称ascii码去收集，单个py文件里面的用例按从上到下写的顺序收集

e.g. :
```py
# test_sample.py

def func(x):
    return x + 1

def test_answer():
    assert func(3) == 5

class TestDemo:

    def test_answer():
        assert func(3) == 4

```
```sh
dev012@dev012:~/workspace/demo$ pytest
========== test session starts ===========
platform linux -- Python 3.7.5, pytest-6.1.2, py-1.9.0, pluggy-0.13.1
rootdir: /home/dev012/workspace/demo
plugins: allure-pytest-2.8.6
collected 2 items

test_sample.py .F                          [100%]

================ FAILURES ================
__________ TestDemo.test_answer __________

self = <test_sample.TestDemo object at 0x7fdb41554e10>

    def test_answer(self):
>       assert func(3) == 5
E       assert 4 == 5
E        +  where 4 = func(3)

test_sample.py:11: AssertionError
======== short test summary info =========
FAILED test_sample.py::TestDemo::test_answer - assert 4 == 5
====== 1 failed, 1 passed in 0.02s =======
```

## 5.缓存
- 设置缓存: `request.config.cache.set("缓存名", 值)`
- 读取缓存: `request.config.cache.get("缓存名", 默认值)`

```py
@pytest.fixture
def mydata(request):
    val = request.config.cache.get("example/value", None)  # 读取缓存
    if val is None:
        val = "=========42==========="
        request.config.cache.set("example/value", "================")  # 写入缓存
        request.config.cache.set("example/value", val)  # 键值对形式会update成最新的值
        print("running expensive computation...")
    return val
```

命令行: 
- `pytest --cache-show`: 查看缓存
- `pytest --cache-clear`: 清除所有缓存文件和值

缓存中只要运行过用例,未清除的情况下一定会有:上次失败的用例,运行过的用例id

outputs:
```
========================= test session starts ==========================
platform linux -- Python 3.7.5, pytest-6.1.2, py-1.9.0, pluggy-0.13.1
rootdir: /home/qydev012/workspace/demo
plugins: allure-pytest-2.8.6
cachedir: /home/qydev012/workspace/demo/.pytest_cache
----------------------------------------------------- cache values for '*' -----------------------------------------------------
cache/lastfailed contains:
  {'conftest.py::test_function': True,
   'test_foocompare.py::test_compare': True,
   'test_sample.py::TestDemo': True,
   'test_sample.py::TestDemo::test_answer': True,
   'test_sample.py::test_has_atter': True}
cache/nodeids contains:
  ['conftest.py::test_function',
   'test_foocompare.py::test_compare',
   'test_sample.py::TestDemo::test_answer',
   'test_sample.py::TestDemo::test_one[1]',
   'test_sample.py::TestDemo::test_one[2]',
   'test_sample.py::test_module[mod1]',
   'test_sample.py::test_module[mod2]',
   'test_sample.py::test_needsfiles',
   'test_sample.py::test_valid_string[hello]',
   'test_sample.py::test_valid_string[stringinput0]',
   'test_sample.py::test_valid_string[world]']
cache/stepwise contains:
  []
example/value contains:
  '========2========'

======================== no tests ran in 0.01s =======================
```

## 6.pycharm设置pytest
Setting - Tools - Python Integrated Tools

## 7.用例名改成utf-8编码格式
方法一:
```ini
[pytest]
disable_test_id_escaping_and_forfeit_all_rights_to_community_support = True
```

方法二:
```py
def pytest_collection_modifyitems(items):
    for item in items:
        item.name = item.name.encode("utf-8").decode("unicode_escape")
        item._nodeid = item.nodeid.encode("utf-8").decode("unicode_escape")
```
## 8.显示用例运行时间
```sh
>pytest -h

reporting:
  --durations=N         show N slowest setup/test durations (N=0 for all).
```
```sh
pytest --durations=0 # 显示全部用例时间
pytest --durations=3 # 显示最慢的3个用例
```
## 9.显示fixture运行过程
`pytest test_s.py --setup-show`

```cmd
============================= test session starts =============================
collected 2 items

test_s.py
SETUP    S base_url
SETUP    S _verify_url (fixtures used: base_url)
        SETUP    F __pytest_repeat_step_number
        SETUP    F login
        test_s.py::test_01 (fixtures used: __pytest_repeat_step_number, _verify_url, base_url, login).
        TEARDOWN F login
        TEARDOWN F __pytest_repeat_step_number
        SETUP    F __pytest_repeat_step_number
        SETUP    F login
        test_s.py::test_02 (fixtures used: __pytest_repeat_step_number, _verify_url, base_url, login).
        TEARDOWN F login
        TEARDOWN F __pytest_repeat_step_number
TEARDOWN S _verify_url
TEARDOWN S base_url

========================== 2 passed in 0.04 seconds ===========================
```


# 语法
## 4.断言 assert

### 1.assert 断言

支持自定义断言失败消息,但不会显示断言失败的具体对比信息
```py
def test_in():
    x = "this"
    assert "h" in x, "断言消息"
```
#### 万物都可做断言
```py

# in
def test_in():
    x = "this"
    assert "h" in x

# hasattr
def test_has_atter():
    x = "hello"
    print(hasattr(str, x))
    assert hasattr(str, x)  # 如果不存在会raise错误

def is_true(a):
    if a > 0:
        return True
    else:
        return False

def test_01():
    '''断言xx为真'''
    a = 5
    b = -1
    assert is_true(a)
    assert not is_true(b)

def test_02():
    '''断言b 包含 a'''
    a = "hello"
    b = "hello world"
    assert a in b

def test_03():
    '''断言相等'''
    a = "yoyo"
    b = "yoyo"
    assert a == b

def test_04():
    '''断言不等于'''
    a = 5
    b = 6
    assert a != b
```

### 2.pytest.raises异常断言
`with raises(expected_exception: Exception[, match][, message]) as excinfo`:断言代码块/函数调用会引发expected_exception或引发失败异常。
- match- 如果指定,则断言异常与text或regex匹配

在上下文中出现预期异常,异常将被捕获不会被抛出,断言成功
```py
import pytest


def func():
    raise ValueError("test Exception 123 raised")


# @pytest.mark.xfail(raises=RuntimeError)
def test_answer():  # match 可选,支持正则表达式匹配错误信息
    with pytest.raises(ValueError, match=r'.* 123 .*') as e:  # 在此处上下文中出现预期异常,异常将被捕获不会被抛出,断言成功
        func()
    print("==============")
    print(e.value)  # 错误的msg
    print(e.type)  # 错误类型
    print(e.traceback)  # 错误溯源

```




## 3.夹具 fixture
fixture发现顺序: 
1. 从测试类开始
2. 然后是测试模块
3. 然后是`conftest.py`文件
4. 最后是内置和第三方插件

fixture放置位置: 
1. 可放在测试模块内
2. 也可以放在conftest.py内.在conftest.py内,同级及下级目录的测试模块都可以访问

### 1. 参数介绍
```python
@pytest.fixture(scope="function", params=None, autouse=False, ids=None, name=None)
```
- `scope`: 可选参数:`function`(函数),`class`(类),`module`(模块),`package`(包)及 `session`(会话(一次运行算一次会话)), 默认为`function`级别
- `params`: 可以传入列表参数，进行数据驱动测试,使用时需要使用`request.param`
- `autouse`: 是否自动使用该前后置条件
    - autouse fixtures服从scope=关键字参数:如果autouse fixture具有scope='session'它,它将只运行一次,无论它在何处定义。scope='class'意味着它将每班运行一次,等等。
    - 如果在测试模块中定义了autouse fixture,则其所有测试函数都会自动使用它。
    - 如果在conftest.py文件中定义了autouse fixture,那么其目录下所有测试模块中的所有测试都将调用fixture。
- `ids`: 字符串id
- `name`: 装饰器的引用名字, 默认为装饰函数的名称

e.g. :
```py
# yield
@pytest.fixture(scope="module", params=["1", "2"])  # 使用params将运行 len(params) 次
def init_driver(request):
    print("这是个模块级的前置条件")
    print(request.param)  # 使用params的参数
    # 以上是setup
    yield driver
    # 以下是 teardown
    print("这是个模块级的后置条件")
```

### 2. 自定义fixture方法

#### 1. fixture的代码结构
1. 使用`yield`, 若fixture函数在setup时(yield之前)发生异常,则不会调用teardown代码(在yield之后)
2. [使用`addfinalizer`函数注册teardown函数](#request)
    - 可以注册多个teardown函数
    - 无论fixture中setup代码是否异常,始终会调用注册的teardown
    - 如果在执行`addfinalizer`之前发生异常,则一样不会被执行

```py
# addfinalizer
@pytest.fixture
def smtp_connection(request):
    smtp_connection = smtplib.SMTP("smtp.gmail.com",587,timeout=5)
        def fin():  # teardown
            print("teardown smtp_connection")
            smtp_connection.close()
    request.addfinalizer(fin)
    return smtp_connection
```



#### 2. fixture的引用&传参
1. 直接在函数()中写入要引用的函数名,当参数使用
2. 使用装饰器`@pytest.mark.usefixtrue("引用的fixtrue方法名")`
3. 支持多重使用
4. 支持fixture间调用

fixture函数必须在`conftest.py`模块的同级目录或下级目录

直接使用
```python
@pytest.fixture()
def init_driver():
    print("初始化前置")
    yield "数据流"
    print("初始化后置")


@pytest.fixture()
def default_fixture(init_driver):
    print("这是个用例级的前置条件")
    yield init_driver
    print("这是个用例级的后置条件")


def test_fixture(default_fixture):
    print(default_fixture)
```

- fixture函数的传参要放置在生成器 `yield` 后
- 测试用例要使用参数时在函数()中当参数一样填入用例名即可，如果yield后面没有值即返回为 None

使用装饰器
```py
@pytest.fixture()
def msg_notification():
    print("来消息啦")


@pytest.mark.usefixtures("msg_notification")
def test_msg():
    pass
```



#### 3. fixture的工厂方法
为便于一个测试内需要多次使用参数,直接将方法传入
```py
@pytest.fixture
def make_customer_record():
    created_records = []

    def _make_customer_record(name):
        record = models.Customer(name=name,orders=[])
        created_records.append(record)
        return record

    yield _make_customer_record

    for record in created_records:
        record.destroy()

def test_customer_records(make_customer_record):
    customer_1 = make_customer_record("Lisa")
    customer_2 = make_customer_record("Mike")
    customer_3 = make_customer_record("Meredith")
```

#### 4. request对象内省参数
request对象内省“请求”测试函数,类或模块上下文
```py
# conftest.py
import pytest

@pytest.fixture()
def down(request):
    num = getattr(request.module, "num", "default")
    yield num
    print(num)
```
```py
# test_demo.py

num = 20  # 提取模块中num的vlaue

def test_demo(down):
    print(down)
```

#### 5. fixture参数化
`pytest.fixture(params=["param1", "param1", ....], ids=["id1", "id2", ....])`
- 传入params的参数长度有多少便运行多少次(含fixture函数, 关联用例及其他依赖)
- ids用于自定义用例的ID,可用`-k` 指定运行用例,若返回值为`none`则使用pytest自动生成的ID
- 只支持单个参数
- `pytest --collect-only`: 显示用例ID

单参数 e.g.
```py
# test_demo.py
import pytest

@pytest.fixture(params=["第一组数据", "第一组数据"], ids=["one", "two"])  # 运行两次
def demo_single_fixture(request):
    print(request.param)

def test_fixture(demo_single_fixture):
    pass


# outputs:
# <Module test_demo.py>
#   <Function test_fixture[one]>
#   <Function test_fixture[two]>
```

`ids`也可以调用函数生成ID

e.g. :
```py
def idfn(fixture_value):  # 调用时会将当前fixture_value传入
    if fixture_value == 0:
        return "eggs"
    else:
        return None

@pytest.fixture(params=[0,1],ids=idfn)
def b(request):
    return request.param

def test_b(b):
    pass

#outputs:
# <Module test_demo.py>
#   <Function test_b[eggs]>
#   <Function test_b[1]>
```

多参数 e.g. (fixture参数化只支持单参数,但可以用二维数组进行二次解析)
1. `pytest.fixture(params=[[], (), (), ...])`: 
    支持列表元组二维混嵌, 一维为次数, 二维为参数

```py
# test_demo.py
import pytest


@pytest.fixture(params=[(1, 2), [3, 4], (4, 5)])
def demo_many_fixture(request):  # 在fixture函数中使用组合参数并不会如parametrize中可设置解析
    print(request.param)


def test_demo(demo_many_fixture):
    pass


# outputs:
# (1, 2)
# [3, 4]
# (4, 5)
```

2. `pytest.fixture(params=(pytest.param(*values, marks=marks, id=id),))`

tips: 如果要使用该模式需要将`pytest.param()`用元组或列表嵌套起来.否则params会运行三次,一次value,一次marks,一次id
```py
# test_demo.py
import pytest


@pytest.fixture(params=[1, 2, pytest.param(2, marks=pytest.mark.skip), pytest.param(5)])  # 跳过第三个测试
def fixture_demo(request):
    # print(pytest.param(1))  # ParameterSet(values=(1,), marks=(), id=None)
    print(request.param, "=================")


def test_demo(fixture_demo):
    pass


# outputs:
# <Module test_sample.py>
#   <Function test_demo[1]>
#   <Function test_demo[2]>
#   <Function test_demo[xixixi]>  skip
#   <Function test_demo[5]>
# 3 passed, 1 skipped in 0.00s
```

3. 需要将fixture函数进行参数化时需要与`getfixturevalue`搭配使用
```py
import pytest
from selenium import webdriver


@pytest.fixture
def chrome():
    driver = webdriver.Chrome()
    yield driver
    driver.quit()

@pytest.fixture
def firefox():
    driver = webdriver.Firefox()
    yield driver
    driver.quit()


@pytest.fixture(params=['chrome', 'firefox'])
def driver(request):
    '''启动浏览器参数化'''
    return request.getfixturevalue(request.param)


def test_foo(driver):
    '''测试用例'''
    driver.get("https://www.baidu.com")
```
#### 6. fixture调用运行顺序
- 较高范围的fixture(例如`session`会话级) 较 低范围的fixture(例如`function`函数级或`class`类级)优先执行。
- 相同范围的fixture对象的按引入的顺序及fixtures之间的依赖关系按顺序调用

```py
@pytest.fixture(scope="session")
def s1():
    pass

@pytest.fixture(scope="module")
def m1():
    pass

@pytest.fixture
def f1(tmpdir):
    pass

@pytest.fixture
def f2():
    pass

def test_foo(f1,m1,f2,s1):
    pass

# 范围层面: s1 > m1 > f1 = f2
# 引用层面: f1 > f2
# 依赖层面: tmpdir > f1
# 故 运行顺序:  s1 > m1 > tmpdir > f1 > f2
```
1. s1:是最高范围的fixture(会话级)
2. m1:是第二高的fixture(模块级)
3. tmpdir:是一个函数级的fixture,f1依赖它,因此它需要在f1前调用
4. f1:是test_foo参数列表中第一个函数范围的fixture。
5. f2:是test_foo参数列表中最后一个函数范围的fixture。

多重装饰使用时pytest依旧采取最小活动范围的策略
```py
@pytest.mark.usefixture("1")
@pytest.mark.usefixture("2", "3")
def test_demo():
    pass
```

#### 7. fixture运行顺序实例

运行e.g.
```py
import pytest


@pytest.fixture(scope="module", params=["mod1", "mod2"])
def modarg(request):
    param = request.param
    print("  模块级前置 %s" % param)
    yield param
    print("  模块级后置 %s" % param)


@pytest.fixture(scope="function", params=[1, 2])
def otherarg(request):
    param = request.param
    print("  函数级前置 %s" % param)
    yield param
    print("  函数级后置 %s" % param)


def test_function(otherarg):
    print("  RUN function fixture %s" % otherarg)


def test_module(modarg):
    print("  RUN module fixture %s" % modarg)


def test_func_module(otherarg, modarg):
    print("  RUN func_module with function %s and module %s" % (otherarg, modarg))
```
outputs:
```py
test_sample.py::test_function[1]   函数级前置 1
  RUN function fixture 1
PASSED  函数级后置 1

test_sample.py::test_function[2]   函数级前置 2
  RUN function fixture 2
PASSED  函数级后置 2

test_sample.py::test_module[mod1]   模块级前置 mod1
  RUN module fixture mod1
PASSED
test_sample.py::test_func_module[mod1-1]   函数级前置 1
  RUN func_module with function 1 and module mod1
PASSED  函数级后置 1

test_sample.py::test_func_module[mod1-2]   函数级前置 2
  RUN func_module with function 2 and module mod1
PASSED  函数级后置 2

test_sample.py::test_module[mod2]   模块级后置 mod1
  模块级前置 mod2
  RUN module fixture mod2
PASSED
test_sample.py::test_func_module[mod2-1]   函数级前置 1
  RUN func_module with function 1 and module mod2
PASSED  函数级后置 1

test_sample.py::test_func_module[mod2-2]   函数级前置 2
  RUN func_module with function 2 and module mod2
PASSED  函数级后置 2
  模块级后置 mod2
```
总结:
- session(会话)级fixture 将最先运行前置,最后运行后置.同级间看调用先后
- module(模块)级fixture 会在运行关联的每个模块前运行前置,每个模块后运行后置
- class(类)会在运行关联的每个类前运行前置,每个类后运行后置


#### 8. fixture函数重写
1. 跨文件夹重写

基础/上级fixtures方法可以被子文件夹下的conftest.py中同名的fixtures方法覆盖

```py
tests/
    __init__.py

    conftest.py
        # content of tests/conftest.py
        import pytest

        @pytest.fixture
        def username():
            return 'username'

    test_something.py
        # content of tests/test_something.py
        def test_username(username):
            assert username == 'username'

    subfolder/
        __init__.py

        conftest.py
            # content of tests/subfolder/conftest.py
            import pytest

            @pytest.fixture
            def username(username):  # 覆盖并使用
                return 'overridden-' + username

        test_something.py
            # content of tests/subfolder/test_something.py
            def test_username(username):
                assert username == 'overridden-username'
```

2. 跨模块重写

用例模块(文件)中的fixture方法可以覆盖文件夹conftest.py中同名的fixtures方法

```py
tests/
    __init__.py

    conftest.py
        # content of tests/conftest.py
        @pytest.fixture
        def username():
            return 'username'

    test_something.py
        # content of tests/test_something.py
        import pytest

        @pytest.fixture
        def username(username):
            return 'overridden-' + username

        def test_username(username):
            assert username == 'overridden-username'

    test_something_else.py
        # content of tests/test_something_else.py
        import pytest

        @pytest.fixture
        def username(username):
            return 'overridden-else-' + username

        def test_username(username):
            assert username == 'overridden-else-username'
```

3. 参数化方法中覆盖fixtures方法

参数化内参数优先级更高
```py
tests/
    __init__.py

    conftest.py
        # content of tests/conftest.py
        import pytest

        @pytest.fixture
        def username():
            return 'username'

        @pytest.fixture
        def other_username(username):
            return 'other-' + username

    test_something.py
        # content of tests/test_something.py
        import pytest

        @pytest.mark.parametrize('username',['directly-overridden-username'])
        def test_username(username):
            assert username == 'directly-overridden-username'

        @pytest.mark.parametrize('username',['directly-overridden-username-other'])
        def test_username_other(other_username):
            assert other_username == 'other-directly-overridden-username-other'
```

4. 重写作用域

作用域仅限于重写后的作用域
- 子文件内 `conftest.py`重写作用于: 同级及文件下级
- 模块内重写: 当前模块
- 类级重写: 当前类

```py
tests/
    __init__.py

    conftest.py
        # content of tests/conftest.py
        import pytest

        @pytest.fixture(params=['one','two','three'])
        def parametrized_username(request):
            return request.param

        @pytest.fixture
        def non_parametrized_username(request):
            return 'username'

    test_something.py
        # content of tests/test_something.py
        import pytest

        @pytest.fixture
        def parametrized_username():  # 模块级重写
            return 'overridden-username'

        @pytest.fixture(params=['one','two','three'])
        def non_parametrized_username(request):
            return request.param

        def test_username(parametrized_username):  # 调用的是同模块的函数
            assert parametrized_username == 'overridden-username'

        def test_parametrized_username(non_parametrized_username):
            assert non_parametrized_username in ['one','two','three']

    test_something_else.py
        # content of tests/test_something_else.py
        def test_username(parametrized_username):  # 调用conftest.py文件的函数
            assert parametrized_username in ['one','two','three']

        def test_username(non_parametrized_username):
            assert non_parametrized_username == 'username'
```

### 3. 内置fixture方法

#### 1. tmp_path  临时目录和文件
在临时目录根目录中创建一个独立的临时目录以供测试调用

e.g. :
```py
CONTENT = u"content"


def test_create_file(tmp_path):
    d = tmp_path / "sub"
    print(d)  # /tmp/pytest-of-dev012/pytest-11/test_create_file0/sub
    d.mkdir()
    p = d / "hello.txt"
    p.write_text(CONTENT)
    assert p.read_text() == CONTENT
    assert len(list(tmp_path.iterdir())) == 1
```

#### 2. tmpdir_factory 
是一个session范围的fixture,可用于从任何其他测试用例及fixture中创建任意临时目录

e.g. :
```py
# conftest.py文件内容
import pytest


@pytest.fixture(scope="session")
def image_file(tmpdir_factory):
    img = compute_expensive_image()
    fn = tmpdir_factory.mktemp("data").join("img.png")
    img.save(str(fn))
    return fn


# contents of test_image.py
def test_histogram(image_file):
    img = load_image(image_file)
    # 计算和测试histogram
```

#### 3. pytestconfig
pytestconfig 的作用跟 request.config 一样，都是获取配置对象
```py
pytestconfig.getoption("参数名")  # 获取命令行参数
pytestconfig.getini("参数名")  # 获取配置文件参数
```
获取命令行参数e.g.
```py
def pytest_addoption(parser):
    parser.addoption(
        "--cmdopt", action="store", default="type1", help="my option: type1 or type2"
    )


def test_answer_1(pytestconfig):
    type = pytestconfig.getoption("--cmdopt")
    print("获取到命令行参数：%s" % type)
```
获取配置文件参数e.g.
```py
"""
[pytest]

log_cli = 1

addopts = -v -x
"""

@pytest.fixture(autouse=True)
def get_ini(pytestconfig):
    '''读取ini配置信息'''
    # 读取 log_cli配置
    log_cli = pytestconfig.getini('log_cli')
    print("获取到markers ：%s" % log_cli)
    addopts = pytestconfig.getini('addopts')
    print("获取到addopts的配置：%s " % addopts)
```


## 1.函数 function
### pytest.approx 浮点比较
```py
from pytest import approx

0.1 + 0.2 == approx

(0.1 + 0.2,0.2 + 0.4) == approx((0.3,0.6))  # 元组

{'a': 0.1 + 0.2,'b': 0.2 + 0.4} == approx({'a': 0.3,'b': 0.6})  # 字典

1.0001 == approx(1,rel=1e-3)  # 相对容差

1.0001 == approx(1,abs=1e-3)  # 绝对容差
```

### pytest.fail 设置用例为失败状态

`fail(msg='', pytrace=True)`: 使用给定消息显式地设置用例为失败状态


### pytest.importorskip 导入模块/跳过
如果无法导入模块,则跳过当前测试

`importorskip(modname, minversion=None, reason=None)`: 导入并返回请求的模块modname,或者如果无法导入模块,则跳过当前测试
- modname(str) - 要导入的模块的名称
- minversion(str) - 如果给定,导入的模块__version__属性必须至少为此最小版本,否则仍会跳过测试。
- reason(str) - 如果给定,则无法导入模块时,此原因显示为消息。



### pytest.exit 退出测试过程
`exit(msg, returncode=None)`: 退出测试过程。
- msg(str) - 退出时显示的消息。
- returncode(int) - 返回退出pytest时使用的代码。

### pytest.main 执行进程
`main(args=None: list, plugins=None: list)`: 执行进程内测试运行后返回退出代码
- args- 命令行参数列表。 列表格式
- plugins- 初始化期间要自动注册的插件对象列表。 列表格式



## 2.Marks(标记)

### 1. `pytest.mark.filterwarnings` 警告过滤器
`pytest.mark.filterwarnings(filter)`




### 5. `pytest.mark.usefixtures` 使用类,模块或项目中的Fixture方法
`pytest.mark.usefixtures(args)`
- args- 要使用的fixture的名称,作为字符串



### 7. `pytest.mark` 自定义标记


用例标记
```python
@pytest.mark.smoke # smoke可以进行替换
def func():
    pass
```

标记使用
- 控制台:

```shell
pytest -m smoke  # 运行smoke标记的用例
pytest -m "not smoke"  # 运行smoke标记外的用例
```
- pytest.main()中使用命令:

```python
pytest.main("-m", "smoke")
```



## 5.跳过 skip
### 1.`pytest.mark.skip` & pytest.skip 跳过测试函数

装饰器:`pytest.mark.skip(reason=None)`: 无条件地跳过测试函数
- reason(str) - 跳过测试函数的原因

函数:`pytest.skip(msg[, allow_module_level=False])`: 使用给定消息跳过测试用例
- allow_module_level(bool) - 跳过整个模块级别。默认为False。

```py
@pytest.mark.skip(reason="目前没办法测试该用例")
def test_the_unknown():
    pass

# 常用于导入时间内无法评估跳过条件
def test_function():
    if not valid_config():
        pytest.skip("不支持该配置")
```

模块级跳过(使用此方法跳过整个模块时会抛出Skipped异常，如果在脚本下方使用pytest.main()执行，会执行不到。此时应使用命令行pytest命令执行)
```py
import sys
import pytest

if not sys.platform.startswith("win"):
    pytest.skip("跳过只支持Windows平台的用例", allow_module_level=True)
```

### 2.`pytest.mark.skipif` 条件跳过测试函数
如果将多个skipif装饰器应用于测试函数，则如果任何跳过条件为真，则将跳过它

`pytest.mark.skipif(condition,*,reason=无)`
- condition(bool)。 表达式
- reason(str) - 跳过测试函数的原因。

```py
import pytest

@pytest.mark.skipif(sys.version_info<(3,6),reason="需要Python3.6版本以上")
def test_function():
    pass
```

```py
@pytest.mark.skipif(sys.platform=="win32",reason="不在Windows系统运行")
class TestPosixCalls(object):
    def test_function(self):  # 若跳过成立,类中每个用例都跳过
        pass
```


#### 1.共享标记
```py
import mymodule

minversion = pytest.mark.skipif(
    mymodule.__versioninfo__ < (1,1),reason="至少mymodule-1.1版本以上"
)

@minversion
def test_function():
    pass
```

#### 2.跨模块标记
```py
# skipif_marks.py
import mymodule


minversion = pytest.mark.skipif(
    mymodule.__versioninfo__ < (1,1),reason="至少mymodule-1.1版本以上"
)


# test_demo.py
from skipif_marks.py import minversion


@minversion
def test_function():
    pass
```

#### 3.缺少依赖跳过
模块级别或以下可用
```py
docutils = pytest.importorskip("docutils")  # 没有依赖则跳过
docutils = pytest.importorskip("docutils",minversion="0.3")  # 依赖版本不足跳过
```

## 6.参数化 parametrize
### 1.`pytest.mark.parametrize` 参数化
`@pytest.mark.parametrize(argnames,argvalues,indirect=False,ids=None,scope=None)`
- `argnames`: 以逗号分隔的字符串,或参数字符串的列表/元组,表示一个或多个参数名称。
- `argvalues`: 使用不同参数值调用测试。
    - 当 只指定了一个argname,则argvalues是值列表。
    - 当 指定了N个argnames,则argvalues必须是N元组的列表,其中每个tuple-element为其各自的argname指定一个值。
- `indirect`: 布尔值,用于确定argnames类型。
    - 当 indirect=True 时，parametrize 中的 argnames 参数被当成函数执行，且 argvalues 值作为 argnames函数中的参数传参。
    - 当 indirect=False 时，argnames 参数被当成普通变量
- `ids`: 字符串ID列表或可调用的迭代对象。
    - 当 字符串,则每个字符串对应于argvalues,以便它们是测试ID的一部分。
    - 当 将None作为特定测试的id给出,则将使用该参数的自动生成的id。如果是可调用的,它应该采用一个参数(单个argvalue)并返回一个字符串或返回None。
    - 当 为None,将使用该参数的自动生成的id。
    - 当 如果没有提供id,它们将自动从argvalues生成。
- `scope`: 如果指定,则表示参数的范围。范围用于按参数实例对测试进行分组。它还将覆盖任何fixture函数定义的范围,允许使用测试上下文或配置设置动态范围。

```python
@pytest.mark.parametrize("test_input,expected",[("3+5",8),("2+4",6),("6*9",42)])
def test_eval(test_input,expected):
    assert eval(test_input) == expected
```


#### indirect为True

```py
import pytest
# indirect=True 单参数
@pytest.fixture(params=['a', 'b', 'c'])  # 此时此处被忽略
def fixture_and_parametrize(request):
    print('\n执行参数{}'.format(request.param))
    return request.param

@pytest.mark.parametrize('fixture_and_parametrize', ['d', 'e', 'f'], indirect=True)
def test_fixture_and_parametrize_2(fixture_and_parametrize):
    print('indirect=True,参数为{}'.format(fixture_and_parametrize))
```
```py
# indirect=True 多参数
@pytest.fixture()
def fixture_and_parametrize(request):
    print('\n执行参数{}'.format(request.param.items()))
    return request.param

value = [{"one": 1, "two": 2}, {"one": 3, "two": 4}]

@pytest.mark.parametrize('fixture_and_parametrize', value, indirect=True)
def test_fixture_and_parametrize_2(fixture_and_parametrize):
    print('indirect=True,参数为{}'.format(fixture_and_parametrize.items()))
```


#### 参数组合

两组及以上参数化时,pytest会进行一一匹配.
- 将运行与设定参数的测试 x=0/y=2,x=1/y=2,x=0/y=3,x=1/y=3 四次测试

```py
import pytest

@pytest.mark.parametrize("x",[0,1])
@pytest.mark.parametrize("y",[2,3])
def test_foo(x,y):
    pass
```

```py
@pytest.fixture()
def fixture_and_parametrize1(request):
    print('\n执行参数{}'.format(request.param["one"]))
    return request.param["one"]

@pytest.fixture()
def fixture_and_parametrize2(request):
    print('\n执行参数{}'.format(request.param["two"]))
    return request.param["two"]

value = [{"one": 1, "two": 2}, {"one": 3, "two": 4}]

@pytest.mark.parametrize('fixture_and_parametrize1', value, indirect=True)
@pytest.mark.parametrize('fixture_and_parametrize2', value, indirect=True)
def test_fixture_and_parametrize_2(fixture_and_parametrize1, fixture_and_parametrize2):
    print('indirect=True,参数为{}'.format(fixture_and_parametrize1))
    print('indirect=True,参数为{}'.format(fixture_and_parametrize2))
```
```
============================= test session starts ==============================
platform linux -- Python 3.7.5, pytest-6.1.2, py-1.9.0, pluggy-0.13.1
rootdir: /home/dev012/workspace/demo
plugins: allure-pytest-2.8.6
collected 4 items

demo.py 
执行参数1

执行参数2
indirect=True,参数为1
indirect=True,参数为2
.
执行参数3

执行参数2
indirect=True,参数为3
indirect=True,参数为2
.
执行参数1

执行参数4
indirect=True,参数为1
indirect=True,参数为4
.
执行参数3

执行参数4
indirect=True,参数为3
indirect=True,参数为4
.

============================== 4 passed in 0.01s ===============================
```

- [也可基于pytest_generate_tests钩子函数在collecting阶段就进行参数化](#pytest_generate_tests-自定义生成用例)

### 2.参数化标记
### pytest.param 指定参数
`param(*values[, id][, marks])`: 在[pytest.mark.parametrize指定参数
- values- 按顺序的参数集值的变量args。
- 标记- 要应用于此参数集的单个标记或标记列表。
- id(str) - 属于此参数集的id。

```py
@pytest.mark.parametrize("test_input,expected",
    [
        ("3+5",8), 
        pytest.param("6*9",42,marks=pytest.mark.xfail), 
    ])
def test_eval(test_input,expected):
    assert eval(test_input) == expected

```

```py
import pytest
import sys

@pytest.mark.parametrize(
    ("n","expected"),
    [
        (1,2),
        pytest.param(1,0,marks=pytest.mark.xfail),
        pytest.param(1,3,marks=pytest.mark.xfail(reason="某个bug")),
        (2,3),
        (3,4),
        (4,5),
        pytest.param(
            10,11,marks=pytest.mark.skipif(sys.version_info >= (3,0),reason="py2k")
        ),
    ],
)
def test_increment(n,expected):
    assert n + 1 == expected
```
## 7.标记失败 xfail
### 函数
只能在测试函数, setup函数或teardown函数中使用此函数

`pytest.xfail(reason='')`: 由给定的原因,强制标记失败测试用例或测试准备函数

```py
def test_03(self):
    result = False
    if not result:
        pytest.xfail("登录不成功, 标记为xfail")
    assert 1 == 1
```
```py
@pytest.mark.xfail()
def test_function():
    pass


def test_function():
    if not valid_config():
        pytest.xfail("failing configuration (but should work)")  # 若调用该方法,不会继续执行该用例
```

### 标记
命令行: `pytest -rxXs` / `pytest --runxfail`: 强制运行预期失败(按无标记处理)

`pytest.mark.xfail(condition = None,reason = None,raises = None,run = True,strict = False)`
- condition(bool。
- reason(str) - 测试函数标记为xfail的原因。
- raises(异常) - 期望由测试函数引发的异常子类;其他例外将无法通过测试。
- run(bool) - 如果实际应该执行测试函数。如果False,该函数将始终为xfail并且不会被执行。
- strict(布尔) 
    - 如果False(默认值),该函数将在终端输出中显示,就xfail好像它失败一样,就像xpass它通过一样。在这两种情况下,这都不会导致测试套件整体失败。这对于标记稍后要解决的片状测试(随机失败的测试)特别有用。
    - 如果True,该函数将在终端输出中显示为xfail失败,但如果它意外通过则将使测试套件失败。这对于标记始终失败的函数特别有用,并且应该有明确的指示它们是否意外地开始通过(例如,库的新版本修复了已知错误)。

```py
@pytest.mark.xfail()
def test_function():
    pass

# condition表达式
@pytest.mark.xfail(sys.version_info >= (3,6),reason="Python3.6 API变更")
def test_function():
    pass


# raises 预期错误
@pytest.mark.xfail(raises=RuntimeError)
def test_function():
    pass

# 任何情况都不再运行
@pytest.mark.xfail(run=False)
def test_function():
    pass
```

#### strict
strict参数设置为True, 如果通过，测试套件的结果将视为失败
```py
@pytest.mark.xfail(strict=True)
def test_function():
    pass
```

[也可以使用xfail_strict变量配置到pytest.ini文件中](#8.配置文件pytest.ini)
```ini
[pytest]
xfail_strict=true
```

## 8.配置文件pytest.ini

### 配置文件所有的配置项
```sh
[pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg file found:

  markers (linelist)       markers for test functions
  empty_parameter_set_mark (string) default marker for empty parametersets
  norecursedirs (args)     directory patterns to avoid for recursion
  testpaths (args)         directories to search for tests when no files or dire
  usefixtures (args)       list of default fixtures to be used with this project
  python_files (args)      glob-style file patterns for Python test module disco
  python_classes (args)    prefixes or glob names for Python test class discover
  python_functions (args)  prefixes or glob names for Python test function and m
  disable_test_id_escaping_and_forfeit_all_rights_to_community_support (bool) di
  console_output_style (string) console output: "classic", or with additional pr
  xfail_strict (bool)      default for the strict parameter of xfail markers whe
  junit_suite_name (string) Test suite name for JUnit report
  junit_logging (string)   Write captured log messages to JUnit report: one of n
  junit_duration_report (string) Duration time to report: one of total|call
  junit_family (string)    Emit XML for schema: one of legacy|xunit1|xunit2
  doctest_optionflags (args) option flags for doctests
  doctest_encoding (string) encoding used for doctest files
  cache_dir (string)       cache directory path.
  filterwarnings (linelist) Each line specifies a pattern for warnings.filterwar
  log_print (bool)         default value for --no-print-logs
  log_level (string)       default value for --log-level
  log_format (string)      default value for --log-format
  log_date_format (string) default value for --log-date-format
  log_cli (bool)           enable log display during test run (also known as "li
  log_cli_level (string)   default value for --log-cli-level
  log_cli_format (string)  default value for --log-cli-format
  log_cli_date_format (string) default value for --log-cli-date-format
  log_file (string)        default value for --log-file
  log_file_level (string)  default value for --log-file-level
  log_file_format (string) default value for --log-file-format
  log_file_date_format (string) default value for --log-file-date-format
  addopts (args)           extra command line options
  minversion (string)      minimally required pytest version
  rsyncdirs (pathlist)     list of (relative) paths to be rsynced for remote dis
  rsyncignore (pathlist)   list of (relative) glob-style paths to be ignored for
  looponfailroots (pathlist) directories to check for changes
```
### 常用配置选项

#### 1.marker标记配置
`pytest --markers`查看配置所有
1. 可以在这里做mark的备注
2. 指定测试用例路径
3. 作用域为当前目录及当前目录的下级

配置文件的名字一定要是`pytest.ini`并推荐放在工程目录的根目录下面

```ini
[pytest]
mark=
    mark1: remark
    mark2: Run the mark2 case suite
testpaths=path
```

#### 2.xfail_strict
[用法](#7.标记失败-xfail)

默认启用,标记为@pytest.mark.xfail的用例但实际运行中通过的测试用例被报告为失败
```ini
[pytest]
xfail_strict=true
```

#### 3.addopts默认命令行参数
```ini
[pytest]
addopts = --alluredir="./allure-results"
```

#### 4.修改用例收集规则
涉及用例收集规则的有三个配置项
- `python_files (args)` 匹配 python 用例文件， 如test_*.py、 *_test.py
- `python_classes (args)` 匹配 class 类名称 如Test*.py
- `python_functions (args)` 匹配函数和class里面方法 如test_*
```ini
[pytest]

python_files =  xxx_*.py
```
如上述配置,pytest在收集用例时在文件层面的只会按`xxx_*.py`这个正则表达式去匹配文件名


## 9.`conftest.py` 作用域
`conftest.py`文件的作用域是 文件当前目录层级及当前目录更低的所有层级

`conftest.py`文件应放在python目录中(含`__init__.py`),否则将无法导包

一个测试工程下是可以有多个`conftest.py`的文件，一般在工程根目录放一个conftest.py起到全局作用。
在不同的测试子目录也可以放`conftest.py`，作用范围只在该层级以及以下目录生效。


# hook(钩子)方法
详细文档可以查看pytest官方文档https://docs.pytest.org/en/latest/reference.html#hooks
## 1.钩子函数概览
### 第一部分：setuptools
引导挂钩要求足够早注册的插件（内部和setuptools插件），可以使用的钩子

- `pytest_load_initial_conftests(early_config,parser,args)`: 在命令行选项解析之前实现初始conftest文件的加载。
- `pytest_cmdline_preparse(config,args)`: (不建议使用)在选项解析之前修改命令行参数。
- `pytest_cmdline_parse(pluginmanager,args)`: 返回一个初始化的配置对象,解析指定的args。
- `pytest_cmdline_main(config)`: 要求执行主命令行动作。默认实现将调用configure hooks和runtest_mainloop。
### 第二部分： 初始化挂钩
初始化钩子需要插件和conftest.py文件

- `pytest_addoption(parser)`: 注册argparse样式的选项和ini样式的配置值，这些值在测试运行开始时被调用一次。
- `pytest_addhooks(pluginmanager)`: 在插件注册时调用，以允许通过调用来添加新的挂钩
- `pytest_configure(config)`: 在插件和conftest文件执行初始配置。
- `pytest_unconfigure(config)`: 在退出测试过程之前调用。
- `pytest_sessionstart(session)`: 在Session创建对象之后，执行收集并进入运行测试循环之前调用。
- `pytest_sessionfinish(session,exitstatus)`: 在整个测试运行完成后调用，就在将退出状态返回系统之前。
- `pytest_plugin_registered(plugin,manager)`:一个新的pytest插件已注册。
### 第三部分： collection 收集钩子
- `pytest_collection(session)`: 执行给定会话的收集协议。
- `pytest_collect_directory(path, parent)`: 在遍历目录以获取集合文件之前调用。
- `pytest_collect_file(path, parent)`: 为给定的路径创建一个收集器，如果不相关，则创建“无”。
- `pytest_pycollect_makemodule(path: py._path.local.LocalPath, parent)`: 返回给定路径的模块收集器或无。
- `pytest_pycollect_makeitem(collector: PyCollector, name: str, obj: object)` :返回模块中Python对象的自定义项目/收集器，或者返回None。在第一个非无结果处停止
- `pytest_generate_tests(metafunc: Metafunc)`: 生成（多个）对测试函数的参数化调用。
- `pytest_make_parametrize_id(config: Config, val: object, argname: str)`: 返回val 将由`@pytest.mark.parametrize`调用使用的给定用户友好的字符串表示形式，如果挂钩不知道，则返回None val。
- `pytest_collection_modifyitems(session: Session, config: Config, items: List[Item])`: 在执行收集后调用。可能会就地过滤或重新排序项目。
- `pytest_collection_finish(session: Session)`: 在执行并修改收集后调用。
### 第四部分：测试运行（runtest）钩子
- `pytest_runtestloop(session: Session)`: 执行主运行测试循环（收集完成后）。
- `pytest_runtest_protocol(item: Item, nextitem: Optional[Item])`: 对单个测试项目执行运行测试协议。
- `pytest_runtest_logstart(nodeid: str, location: Tuple[str, Optional[int], str])`: 在运行单个项目的运行测试协议开始时调用。
- `pytest_runtest_logfinish(nodeid: str, location: Tuple[str, Optional[int], str])`:在为单个项目运行测试协议结束时调用。
- `pytest_runtest_setup(item: Item)`: 调用以执行测试项目的设置阶段。
- `pytest_runtest_call(item: Item)`: 调用以运行测试项目的测试（调用阶段）。
- `pytest_runtest_teardown(item: Item, nextitem: Optional[Item])`: 调用以执行测试项目的拆卸阶段。
- `pytest_runtest_makereport(item: Item, call: CallInfo[None])`: 被称为为`_pytest.reports.TestReport`测试项目的每个设置，调用和拆卸运行测试阶段创建一个。
- `pytest_pyfunc_call(pyfuncitem: Function)`: 调用基础测试功能。
### 第五部分：Reporting 报告钩子
- `pytest_collectstart(collector: Collector)`: 收集器开始收集。
- `pytest_make_collect_report(collector: Collector)`: 执行collector.collect()并返回一个CollectReport。
- `pytest_itemcollected(item: Item)`: 我们刚刚收集了一个测试项目。
- `pytest_collectreport(report: CollectReport)`: 收集器完成收集。
- `pytest_deselected(items: Sequence[Item])`: 要求取消选择的测试项目，例如按关键字。
- `pytest_report_header(config: Config, startdir: py._path.local.LocalPath)`: 返回要显示为标题信息的字符串或字符串列表，以进行终端报告。
- `pytest_report_collectionfinish(config: Config, startdir: py._path.local.LocalPath, items: Sequence[Item])`: 返回成功完成收集后将显示的字符串或字符串列表。
- `pytest_report_teststatus(report: Union[CollectReport, TestReport], config: Config)`: 返回结果类别，简写形式和详细词以进行状态报告。
- `pytest_terminal_summary(terminalreporter: TerminalReporter, exitstatus: ExitCode, config: Config)`: 在终端摘要报告中添加一个部分。
- `pytest_fixture_setup(fixturedef: FixtureDef[Any], request: SubRequest)`: 执行夹具设置执行。
- `pytest_fixture_post_finalizer(fixturedef: FixtureDef[Any], request: SubRequest)`: 在夹具拆除之后但在清除缓存之前调用，因此夹具结果fixturedef.cached_result仍然可用（不是 None）
- `pytest_warning_captured(warning_message: warnings.WarningMessage, when: Literal[‘config’, ‘collect’, ‘runtest’], item: Optional[Item], location: Optional[Tuple[str, int, str]])`: （已弃用）处理内部pytest警告插件捕获的警告。
- `pytest_warning_recorded(warning_message: warnings.WarningMessage, when: Literal[‘config’, ‘collect’, ‘runtest’], nodeid: str, location: Optional[Tuple[str, int, str]])`: 处理内部pytest警告插件捕获的警告。
- `pytest_runtest_logreport(report: TestReport)`: 处理项目的_pytest.reports.TestReport每个设置，调用和拆卸运行测试阶段产生的结果。
- `pytest_assertrepr_compare(config: Config, op: str, left: object, right: object)`: 返回失败断言表达式中的比较的说明。
- `pytest_assertion_pass(item: Item, lineno: int, orig: str, expl: str)`: （实验性的）在断言通过时调用。
### 第六部分：调试/相互作用钩
很少有可以用于特殊报告或与异常交互的挂钩：

- `pytest_internalerror(excrepr: ExceptionRepr, excinfo: ExceptionInfo[BaseException])`: 要求内部错误。返回True以禁止对将INTERNALERROR消息直接打印到sys.stderr的回退处理。
- `pytest_keyboard_interrupt(excinfo: ExceptionInfo[Union[KeyboardInterrupt, Exit]])`: 要求键盘中断。
- `pytest_exception_interact(node: Union[Item, Collector], call: CallInfo[Any], report: Union[CollectReport, TestReport])`: 在引发可能可以交互处理的异常时调用。
- `pytest_enter_pdb(config: Config, pdb: pdb.Pdb)`: 调用了pdb.set_trace（）。

## 2.部分使用实例

### 1.`pytest_assertrepr_compare`自定义断言对比信息

```py
# test_foocompare.py

class Foo(object):
    def __init__(self, val):
        self.val = val

    def __eq__(self, other):
        return self.val == other.val


def test_compare():
    f1 = Foo(1)
    f2 = Foo(2)
    assert f1 == f2
```
```py
# conftest.py
from test_foocompare import Foo


def pytest_assertrepr_compare(op, left, right):
    if isinstance(left, Foo) and isinstance(right, Foo) and op == "==":
        return ['Foo实例对比:',
                '   值: %s != %s' % (left.val, right.val)]

```

### 2.`pytest_generate_tests`自定义生成用例
命令行: 传递2个参数`pytest -vs --stringinput="hello" --stringinput="world" test_sample.py `
- tips: 如果没有传递参数,将跳过使用该参数名的用例

```py
:param metafunc:共有五个属性值
                metafunc.fixturenames:参数化收集时的参数名称
                metafunc.module:使用参数名称进行参数化的测试用例所在的模块对象
                metafunc.config:测试用例会话
                metafunc.function:测试用例对象,即函数或方法对象
                metafunc.cls: 测试用例所属的类的类对象
```

```py
# content of test_strings.py

def test_valid_string(stringinput):  # 用例
    print(stringinput)
    assert stringinput.isalpha()
```
```py
def pytest_addoption(parser):  # 增加命令行参数选项
    print("=========1=========")
    parser.addoption(
        "--stringinput",
        action="append",
        default=[],
        help="list of stringinputs to pass to test functions",
    )

def pytest_generate_tests(metafunc):  # 自定义用例收集
    print("=========1=========")
    if "stringinput" in metafunc.fixturenames:
        print(metafunc.fixturenames)  # 存有参数选项的列表  ['stringinput']
        print(metafunc.config.getoption("stringinput"))  # 取出该(stringinput)选项的值(列表) ['hello', 'world']
        metafunc.parametrize("stringinput",metafunc.config.getoption("stringinput"))  # 将该选项的值生成变量为stringinput的参数化
```

如下方结果可知,`pytest_addoption`运行在最前面,`pytest_generate_tests`运行在collecting阶段

outputs:
```
=========1=========
test_fixture======================== test session starts test_fixture=========================
platform linux -- Python 3.7.5, pytest-6.1.2, py-1.9.0, pluggy-0.13.1 -- /usr/bin/python3.7
cachedir: .pytest_cache
rootdir: /home/qydev012/workspace/demo
plugins: allure-pytest-2.8.6
collecting ... =========1=========
['stringinput']
['hello', 'world']
collected 2 items                                                                                                              

test_sample.py::test_valid_string[hello] hello
PASSED
test_sample.py::test_valid_string[world] world
PASSED

test_fixture========================= 2 passed in 0.01s ====================
```


### 3.`pytest_addoption`自定义选项(命令行/配置文件)选项
#### 1. 自定义命令行
conftest.py
```py
def pytest_addoption(parser):
    parser.addoption("-E", "--ENV", action="store", default="test", help="please choose environment", dest="env")  # 短选项必须为大写单个字母


@pytest.fixture
def cmdopt(request):
    return request.config.getoption("--ENV")
```
cmd: 
```sh
pytest -E=test
pytest -E test
pytest --ENV test
pytest --ENV=test
```

parser.addoption()参数说明
- name：自定义命令行参数的名字，可以是："foo"， "-foo" 或 "--foo"；支持多个名字(短选项必须为大写单个字母)
- action：在命令行中遇到此参数时要采取的基本操作类型；
- nargs：应该使用的命令行参数的数量；
- const：某些操作和nargs选择所需的常量值；
- default：如果参数不在命令行中，则生成的默认值。
- type：命令行参数应该转换为的类型；
- choices：参数允许值的容器；
- required：命令行选项是否可以省略（仅可选）；
- help：对参数作用的简要说明；
- metavar：帮助消息中参数的名称；
- dest：要添加到 parse_args() 返回的对象中的属性的名称；


##### 1.action:
- store: 默认，只存储参数的值，可以存储任何类型的值，此时 default 也可以是任何类型的值，而且命令行参数多次使用也只能生效一个，最后一个值覆盖之前的值

```py
def pytest_addoption(parser):
    parser.addoption("--cmdopt", action="store",
                     default="这个是默认值...",
                     help="将命令行参数 ’--cmdopt' 添加到 pytest 配置中")

# 从配置对象中读取自定义参数的值
@pytest.fixture(scope="session")
def cmdopt(request):
    return request.config.getoption("--cmdopt")

# 将自定义参数的值打印出来
@pytest.fixture(autouse=True)
def fix_1(cmdopt):
    print('\n --cmdopt的值：',cmdopt)

if __name__ == '__main__':
    # 使用参数
    pytest.main(['-s', '--cmdopt=store'])
```
```
# 控制台打印参数值：
============================= test session starts =============================
test_xixixi.py::TestDemoA::test_A_001 
 --cmdopt的值： store
PASS
============================== 1 passed in 0.02s ==============================
```

- append：存储一个列表，用 append 模式 将可以同时多次使用自定义参数，并且 default  默认值必须是一个列表，pytest 会把 default  默认参数的值和多个自定义参数的值放在一个列表中

```py
def pytest_addoption(parser):
    parser.addoption("--cmdopt", action="append",
                     default=['这是默认参数'],
                     help="将命令行参数 ’--cmdopt' 添加到 pytest 配置中")

if __name__ == '__main__':
    # 使用参数
    pytest.main(['-s', '--cmdopt=列表1', '--cmdopt=列表2'])
```
```
============================= test session starts =============================
test_xixixi.py::TestDemoA::test_A_001 
 --cmdopt的值： ['这是默认参数', '列表1', '列表2']
PASS
============================== 1 passed in 0.02s ==============================
```

- store_const: 使用 const 为命令行参数指定一个常量值，必须和 const 参数同时使用，使用这个模式后命令行参数不能赋值

```py
def pytest_addoption(parser):
    parser.addoption("--cmdopt", action="store_const",
                     default='这是默认参数',
                     const='这个是为命令行参数指定的常量值...',
                     help="将命令行参数 ’--cmdopt' 添加到 pytest 配置中")

if __name__ == '__main__':
    pytest.main(['-s','--cmdopt'])
```
```
============================= test session starts =============================
test_xixixi.py::TestDemoA::test_A_001 
 --cmdopt的值： 这个是为命令行参数指定的常量值...
PASS
============================== 1 passed in 0.02s ==============================
```

- append_const：存储一个列表，使用 const 为命令行参数指定一个常量值，并将 default 默认值和 const  常量值添加到列表中，这个模式可以同时多次使用自定义参数，但是还是不能赋值，只能使用常量

```py
def pytest_addoption(parser):
    parser.addoption("--cmdopt", action="append_const",
                     default=['这是默认参数'],
                     const='这个是为命令行参数指定的常量值...',
                     help="将命令行参数 ’--cmdopt' 添加到 pytest 配置中")

if __name__ == '__main__':
    pytest.main(['-s','--cmdopt', '--cmdopt'])
```
```
============================= test session starts =============================
test_xixixi.py::TestDemoA::test_A_001 
 --cmdopt的值： ['这是默认参数', '这个是为命令行参数指定的常量值...', '这个是为命令行参数指定的常量值...']
PASS
============================== 1 passed in 0.02s ==============================
```

##### 2.type
type 的类型可以是 python 的基础类型，比如：int，str，float，list 等类型，如果不指定类型的话，pytest会把接受到的参数值都默认为 str 类型，所以我们有时需要指定参数的类型：

注意：在使用 type 指定类型时，也需要把 default 的类型修改为同样的类型！

```py
def pytest_addoption(parser):
    parser.addoption("--cmdopt", action="store",
                     default=100,
                     type=int,
                     help="将命令行参数 ’--cmdopt' 添加到 pytest 配置中")

if __name__ == '__main__':
    pytest.main(['-s', '--cmdopt=888'])
```

##### 3.choices
choices 可以指定几个值，自定义参数必须在这几个值中选择一个，否则会报错

```py
def pytest_addoption(parser):
    parser.addoption("--cmdopt", action="store",
                     default='python',
                     choices= ['python', 'java', 'c++'],
                     help="将命令行参数 ’--cmdopt' 添加到 pytest 配置中")

if __name__ == '__main__':
    pytest.main(['-s', '--cmdopt=python'])
```
#### 2.自定义配置文件
```py

```

### 4.pytest_collection_modifyitems 用例收集完后调用

```py
def pytest_collection_modifyitems(session, config, items)::
    """
    在用例收集完毕后调用该hook,可以通过该hook修改收集用例的信息,修改顺序等
    :param session: -> dict pytest运行的会话信息
    :param config: -> dict 配置信息
    :param items: -> list 所收集到的所有用例信息
    """
```

### 5.pytest_runtest_makereport 用例执行结果
```py
def pytest_runtest_makereport(item, call):
    """
    :param item: 测试用例
    :param call: 测试步骤
    """
```
- 先执行when='setup' 返回setup 的执行结果
- 然后执行when='call' 返回call 的执行结果
- 最后执行when='teardown'返回teardown 的执行结果

运行过程中 若 `setup`&`teardown`阶段运行错误则结果为error且会终止继续运行.若`call`状态运行失败则是`failed`

e.g. :

```py
import pytest


@pytest.hookimpl(hookwrapper=True, tryfirst=True)
def pytest_runtest_makereport(item, call):
    print('------------------------------------')

    # 获取钩子方法的调用结果
    out = yield
    print('用例执行结果', out)

    # 3. 从钩子方法的调用结果中获取测试报告
    report = out.get_result()

    print('测试报告：%s' % report)
    print('步骤：%s' % report.when)
    print('nodeid：%s' % report.nodeid)
    print('description:%s' % str(item.function.__doc__))
    print(('运行结果: %s' % report.outcome))
    print(('用例名: %s' % report.outcomee))

    # 也可以通过yield返回的结果直接查询
    print('测试报告：%s' % out.result)
    print('步骤：%s' % out.result.when)
    print('nodeid：%s' % out.result.nodeid)
    print('description:%s' % str(item.function.__doc__))
    print(('运行结果: %s' % out.result.outcome))
    print(('用例名: %s' % out.result.head_line))
    

@pytest.fixture(scope="session", autouse=True)
def fix_a():
    print("setup 前置操作")
    yield 
    print("teardown 后置操作")


@pytest.mark.usefixtures("fix_a")
def test_a():
    '''用例描述:test_a'''
    print("这里是测试用例")

```
```
============================= test session starts ==============================
platform linux -- Python 3.7.5, pytest-6.1.2, py-1.9.0, pluggy-0.13.1
rootdir: /home/qydev012/workspace/demo
plugins: allure-pytest-2.8.6
collected 1 item

demo.py setup 前置操作
------------------------------------
用例执行结果 <pluggy.callers._Result object at 0x7f726cc1af50>
测试报告：<TestReport 'demo.py::test_a' when='setup' outcome='passed'>
步骤：setup
nodeid：demo.py::test_a
description:用例描述:test_a
运行结果: passed
=================================================================
测试报告：<TestReport 'demo.py::test_a' when='setup' outcome='passed'>
步骤：setup
nodeid：demo.py::test_a
description:用例描述:test_a
运行结果: passed
用例名: test_a
这里是测试用例
------------------------------------
用例执行结果 <pluggy.callers._Result object at 0x7f726cc1ac10>
测试报告：<TestReport 'demo.py::test_a' when='call' outcome='passed'>
步骤：call
nodeid：demo.py::test_a
description:用例描述:test_a
运行结果: passed
=================================================================
测试报告：<TestReport 'demo.py::test_a' when='call' outcome='passed'>
步骤：call
nodeid：demo.py::test_a
description:用例描述:test_a
运行结果: passed
用例名: test_a
.teardown 后置操作
------------------------------------
用例执行结果 <pluggy.callers._Result object at 0x7f726cc1af50>
测试报告：<TestReport 'demo.py::test_a' when='teardown' outcome='passed'>
步骤：teardown
nodeid：demo.py::test_a
description:用例描述:test_a
运行结果: passed
=================================================================
测试报告：<TestReport 'demo.py::test_a' when='teardown' outcome='passed'>
步骤：teardown
nodeid：demo.py::test_a
description:用例描述:test_a
运行结果: passed
用例名: test_a
```

### 6.pytest_terminal_summary 测试结果汇总
```py
def pytest_terminal_summary(terminalreporter, exitstatus, config)
最后的结果汇总,可以拿到所有的执行结果
参数：
- terminalreporter (_pytest.terminal.TerminalReporter) – 内部使用的终端测试报告对象
- exitstatus (int) – 返回给操作系统的返回码
- config(_pytest.config.Config) - pytest config对象
```

e.g. :
```py
def pytest_terminal_summary(terminalreporter, exitstatus, config):
    # 获取失败用例对象列表
    faileds = terminalreporter.stats.get("failed")
    for failed in faileds:
        longrepr = failed.longrepr
        print("=====================================")
        print(f"test_name: {failed.head_line}")
        print("outcome:", failed.outcome)
        print("nodeid:", failed.nodeid)
        print("skipped:", failed.skipped)
        print("traceback:\n", failed.longreprtext)
        print("error_line_no", longrepr.reprcrash.lineno)
        print("error_msg", longrepr.reprcrash.message)
        print("error_file_path", longrepr.reprcrash.path)
        print(f"duration: {failed.duration:.2f}")
        n = 0
        for arg in longrepr.reprtraceback.reprentries[0].reprfuncargs.args:
            n += 1
            print("arg_"+str(n)+":", arg)  # 每个用例的入参
    print("total:", terminalreporter._numcollected)
    print(f"success rate:{len(faileds)/terminalreporter._numcollected:.2%}")

    # 获取成功用例对象列表
    passeds = terminalreporter.stats.get("passed")
    for passed in passeds:
        print(passed.outcome)
        print(passed.duration)
        print(passed.nodeid)
        print(passed.head_line)
```
```
=====================================
test_name: test_a[9]
outcome: failed
nodeid: demo.py::test_a[9]
skipped: False
traceback:
 data = 9

    @pytest.mark.parametrize("data", [1,2,3,4,5,6,7,8,9], ids=[1,2,3,4,5,6,7,8,9])
    @pytest.mark.usefixtures("fix_a")
    def test_a(data):
        '''用例描述:test_a'''
        print("这里是测试用例")
        print(data)
>       assert data < 7
E       assert 9 < 7

demo.py:9: AssertionError
error_line_no 9
error_msg assert 9 < 7
error_file_path /home/qydev/workspace/demo/demo.py
duration: 0.00
arg_1: ('data', '9')
total: 9
success rate:66.67%
passed
7.817998994141817e-05
demo.py::test_a[4]
test_a[4]
```
### 7.pytest_report_teststatus 测试用例状态
```py
def pytest_report_teststatus(report, config):
    """
    :param report: 返回各个测试阶段的result对象, 可以用when属性来区分不同阶段。
    :param config: 配置对象
    """
    # when=='setup' 用例的前置操作
    # when=='call' 用例的执行
    # when=='teardown' 用例的后置操作
```
```py
def pytest_report_teststatus(report, config):
    '''turn . into √，turn F into x, turn E into 0'''
    if report.when == 'call' and report.failed:
        return (report.outcome, 'x', 'failed')
    if report.when == 'call' and report.passed:
        return (report.outcome, '√', 'passed')
    if report.when == 'setup' and report.failed:
        return (report.outcome, '0', 'error')
```


# plugins 插件
## 1.安装插件

使用pip安装即可

- `pip install pytest-NAME`
- `pip uninstall pytest-NAME`

### 2.查看插件列表
`pytest --trace-config`

### 3.常用插件列表
- pytest-django：为django应用程序编写测试。
- pytest-twisted：为twisted应用程序编写测试,启动反应堆并处理测试函数的延迟。
- pytest-cov：覆盖率报告,与分布式测试兼容
- pytest-xdist：将测试分发到CPU和远程主机,以盒装模式运行,允许分段故障,在looponfailing模式下运行,自动重新运行文件更改的失败测试。
- pytest-instafail：在测试运行期间报告失败。
- pytest-bdd使用行为驱动的测试编写测试。
- pytest-timeout：根据函数标记或全局定义进行超时测试。
- pytest-pep8：--pep8启用PEP8合规性检查的选项。
- pytest-ordering: 修改用例顺序
- pytest-assume: 当前用例断言失败也继续执行
- pytest-cov: 单元测试覆盖率
- pytest-random-order: 乱序
- pytest-sugar: 进度条

## 2.加载插件
方法一: 在测试模块/根目录`conftest.py`文件中指定需要使用插件的元组`pytest_plugins = ("myapp.testsupport.myplugin",)`

方法二: 
- 使用命令行运行/main方法注册插件
- 也可以取消注册插件`pytest -p no:name`

方法三:
- 无条件禁用: `pytest.ini`

```
[pytest]
addopts = -p no:NAME
```

## 3.插件发现顺序
- 通过加载所有内置插件
- 通过加载通过[setuptools入口点注册的所有插件。
- 通过预扫描选项的命令行并在实际命令行解析之前加载指定的插件。-pname
- 通过conftest.py命令行调用推断加载所有文件：
- 如果未指定测试路径,则使用当前dir作为测试路径
- 如果存在,则加载conftest.py并test*/conftest.py相对于第一个测试路径的目录部分。
- 请注意,pytestconftest.py在工具启动时没有在更深的嵌套子目录中找到文件。将conftest.py文件保存在顶级测试或项目根目录中通常是个好主意。
- 通过递归加载文件中pytest_plugins变量指定的所有插件conftest.py

## 4.失败重跑

失败重跑需要安装插件：
```shell
pip install pytest-rerunfailures
```
function/class级别标注重跑参数：
```python
@pytest.mark.flaky(reruns 5, reruns-delay 3)
```
控制台使用命令：作用域是当前会话全部
```shell
pytest --reruns num --reruns-delay num 
# num: 重试的次数 num: 间隔时间(s)
```
`pytest.main()`中使用命令：
```python
pytest.main(["--reruns", "num", "--reruns-delay", "num"])
# num: 重试的次数 num: 间隔时间(s)
```
-- --
## 5.xdist并发运行
https://github.com/pytest-dev/pytest-xdist
安装：
```shell
pip install pytest-xdist
```
该方法用的是多进程并发

支持部署到remote TODO:待研究

`pytest-parallel` 该库支持多进程多线程并发 TODO:待研究https://github.com/browsertron/pytest-parallel

使用方法：
pytest.main()中使用命令：
```python
pytest.main(["-n", "3"]) # 进行三个进程的并发运行
pytest.main(["-n", "auto"])  # 自动根据CPU确定线程，一般为CPU核心线程数
```
控制台使用命令：
```shell
pytest -n 3 # 进行三个进程的并发运行
pytest -n auto # 自动根据CPU确定线程，一般为CPU核心线程数
```

其他参数
- `--dist`: 加载模式 选项: "each", "load", "loadscope", "loadfile", "no" 默认为load
- `--tx`: 添加远端信息 `--tx popen//python=python2.5 --tx socket=192.168.1.102:8888 --tx ssh=user@codespeak.net//chdir=testcache`
- `--rsyncdir`: 远端执行的用例




### 开启远端分布式运行
https://www.cnblogs.com/my_captain/p/12775010.html

1. 将`socketserver.py`发送到执行机(node),启动脚本`python ` 默认端口为8888,可以修改端口
2. master启动脚本`pytest --dist=load --tx socket=node_host1:8888 --tx socket=node_host2:8888 --rsyncdir test_cases test_cases`选择合适的dist方案 连接宿主机



https://raw.githubusercontent.com/pytest-dev/execnet/master/execnet/script/socketserver.py
```py
#! /usr/bin/env python
# -*- coding: utf-8 -*-
"""
    start socket based minimal readline exec server

    it can exeuted in 2 modes of operation

    1. as normal script, that listens for new connections

    2. via existing_gateway.remote_exec (as imported module)

"""
# this part of the program only executes on the server side
#
import os
import sys

progname = "socket_readline_exec_server-1.2"


def get_fcntl():
    try:
        import fcntl
    except ImportError:
        fcntl = None
    return fcntl


fcntl = get_fcntl()

debug = 0

if debug:  # and not os.isatty(sys.stdin.fileno())
    f = open("/tmp/execnet-socket-pyout.log", "w")
    old = sys.stdout, sys.stderr
    sys.stdout = sys.stderr = f


def print_(*args):
    print(" ".join(str(arg) for arg in args))


if sys.version_info > (3, 0):
    exec(
        """def exec_(source, locs):
    exec(source, locs)"""
    )
else:
    exec(
        """def exec_(source, locs):
    exec source in locs"""
    )


def exec_from_one_connection(serversock):
    print_(progname, "Entering Accept loop", serversock.getsockname())
    clientsock, address = serversock.accept()
    print_(progname, "got new connection from %s %s" % address)
    clientfile = clientsock.makefile("rb")
    print_("reading line")
    # rstrip so that we can use \r\n for telnet testing
    source = clientfile.readline().rstrip()
    clientfile.close()
    g = {"clientsock": clientsock, "address": address, "execmodel": execmodel}
    source = eval(source)
    if source:
        co = compile(source + "\n", "<socket server>", "exec")
        print_(progname, "compiled source, executing")
        try:
            exec_(co, g)  # noqa
        finally:
            print_(progname, "finished executing code")
            # background thread might hold a reference to this (!?)
            # clientsock.close()


def bind_and_listen(hostport, execmodel):
    socket = execmodel.socket
    if isinstance(hostport, str):
        host, port = hostport.split(":")
        hostport = (host, int(port))
    serversock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # set close-on-exec
    if hasattr(fcntl, "FD_CLOEXEC"):
        old = fcntl.fcntl(serversock.fileno(), fcntl.F_GETFD)
        fcntl.fcntl(serversock.fileno(), fcntl.F_SETFD, old | fcntl.FD_CLOEXEC)
    # allow the address to be re-used in a reasonable amount of time
    if os.name == "posix" and sys.platform != "cygwin":
        serversock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    serversock.bind(hostport)
    serversock.listen(5)
    return serversock


def startserver(serversock, loop=False):
    execute_path = os.getcwd()
    try:
        while 1:
            try:
                exec_from_one_connection(serversock)
            except (KeyboardInterrupt, SystemExit):
                raise
            except:
                if debug:
                    import traceback

                    traceback.print_exc()
                else:
                    excinfo = sys.exc_info()
                    print_("got exception", excinfo[1])
            os.chdir(execute_path)
            if not loop:
                break
    finally:
        print_("leaving socketserver execloop")
        serversock.shutdown(2)


if __name__ == "__main__":
    import sys

    if len(sys.argv) > 1:
        hostport = sys.argv[1]
    else:
        hostport = ":8888"
    from execnet.gateway_base import get_execmodel

    execmodel = get_execmodel("thread")
    serversock = bind_and_listen(hostport, execmodel)
    startserver(serversock, loop=True)

elif __name__ == "__channelexec__":
    chan = globals()["channel"]
    execmodel = chan.gateway.execmodel
    bindname = chan.receive()
    sock = bind_and_listen(bindname, execmodel)
    port = sock.getsockname()
    chan.send(port)
    startserver(sock)
```

-- --
## 6.allure 测试报告
```shell
pip install allure-pytest
```
![index](https://upload-images.jianshu.io/upload_images/20499241-eabd309700892d6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

控制台使用：
```shell
pytest -alluredir=path # path为输出报告的路径
```
pytest.main()中使用：
```python
pytest.main(["--alluredir=path"])  # path为输出报告的路径
```
[allure使用详情](https://www.jianshu.com/p/40a5a005ce01)

## 7.自定义用例执行顺序

安装：
```shell
pip install pytest-ordering
```

使用：

通过指定序号指定，比如1，2，3...-2（倒数第二）, -1(最后）
```python
@pytest.mark.run(order=2)
def test_login():
    assert True

@pytest.mark.run(order=1)
def test_reg():
    assert True
```

通过指定函数名指定，比如test_login和test_order都要在test_reg后执行
```py
@pytest.mark.run(after='test_reg')
def test_login():
    assert True

def test_reg():
    assert True

@pytest.mark.run(after='test_reg')
def test_order():
    assert True
```

-- --

## 8.测试报告
1. xml文件 
2. log 
3. html

安装:
- html: `pip install pytest-html`


e.g. :
```py
# path 为存放路径
pytest.main("--junitxml=path", "--resultlog=path", "--html=path")
```
命令行：
- `pytest --junitxml=path --resultlog=path --html=path`
    - path 为存放路径
- `pytest --html=report.html --self-contained-html`: 将html和css文件合并生成
