# 测试左移&右移
常规流程: `需求 - 开发 - 测试 - 上线`. 从这个流程可以看出测试这个角色才参与流程是靠后的,因为依赖于开发交付的成果.

但是这种模式会存在一些问题, 
1. 工作量不均衡, 测试在开发编码阶段工作量较轻, 到测试这个阶段又过重, 开发则反之
2. 测试介入靠后, 开发成果存在缺陷, 越后期修复成本越高. 测试人员精力疲于修复简单的缺陷,而不能专注于深层次测试中且有较大可能性导致上线延期

## 破局
通过测试左移右移, 让测试有更多的主动权

### 测试左移
本质: 越早发现不合理的地方, 出问题的概率越低

目的: 
1. 提高质量上线: 通过一系列措施, 使问题在起步阶段就得到解决
2. 提高质量下限: 通过一系列措施, 使开发交付的成果底线得到了保障
3. 缩小测试周期: 交付的成果质量高, 那么测试环节的时间也会相应的降低

核心:
全员质量服务意识, 都为产品质量服务. 测试团队是有限的, 质量的参与人员不仅仅局限于测试人员, 只有通过赋能质量意识, 使团队成员都具备质量意识, 才能有效提高质量

措施:
- 有哪些活动可以提高质量上限（举例）？

1. 健康的项目流程（合理并且严格遵守的项目流程）
2. 合理的需求分析（评估需求的质量，分析需求的合理性以及完整性）
3. 出色的系统架构
4. 完整的系统设计（评估设计的质量，分析需求的合理性以及完整性）
5. 进行研发标准的定义
6. 更早的测试分析（先于开发完成需求的分析，做好各种评审的准备）
7. 尽早的测试执行（提早参与测试执行，在集成前就发现一些问题）

- 有哪些活动可以提高质量下限（举例）？

1. 健康的测试流程
2. 优秀的测试用例
3. 合理的测试计划
4. 合适的自动化
5. 适当的探索式测试
6. 充分利用静态代码扫描
7. 开发自测（TDD、BDD，测试提供更好的用例、技术支持）
8. 团队质量意识的培养

落地措施:
1. 质量文化的赋能
2. 质量规范梳理
3. 项目进度(里程碑, 项目周期)
4. 环节交付输出 (需求理解,单元测试, 上线时间, 线上问题)


### 测试右移
目的: 及时发现,及时反馈

核心: 围绕问题反馈、发现、定位、监控展开，参与人员则不仅仅局限于运维人员

措施: 
1. 通过接入`prometheus` + `granfana` 实现数据监控
    1. 服务器性能(cpu, 内存, i/o, 网络)
    2. 业务指标(注册量, 进件量, 通过量, 拒绝量, 放款量, 还款量, 短信发送量, 三方验证量)
    3. 风控指标
2. 接入阿里云日志告警(邮件, 短信)

# 测试理论
## 测试计划
1. 测试范围
2. 测试策略
    1. 明确”产品目标“
    2. 进行”风险分析“
    3. 适配”产品研发流程“
3. 测试资源
    1. 人力资源
    2. 环境资源
    3. 设备资源

# 工作流:
1. 测试导图前置: 填充细节 梳理优化逻辑
2. 测试导图跟产品简单过一下,双方确认无误
3. 需求评审 - 导图评审: 辅助开发对需求理解
4. 需求分解 - 工作量预估: 精细化管理
5. 开发概要设计: 参与设计 关注有没有漏
6. 模块提测: 模块冒烟及功能测试
7. 集成测试: 集成间测试, 重点关注新模块
8. 第二轮测试: 探索性 深度 缺陷处理
9. 预生产上线: 模拟生产上线
10. 预生产测试: 确认测试 确保上线未导致功能故障
11. 生产上线
12. 生产监控: 生产数据监控

# DevOps&CICD
- 采用 jenkinsfile + share library + scm 进行版本管理
- 容器化集群(k8s) 通过在k8s部署slave, 方便水平扩容 弹性伸缩

1. 合并到test环境, 触发单元测试和静态检查, 成功合并失败拒绝
2. 构建镜像 push仓库
3. 部署环境, pull仓库
4. 并发执行测试(接口 ui)
5. 人工验收通知(robot)

DevOps是一种思想、一组最佳实践、以及一种文化。DevOps是CICD思想的延伸，CICD是DevOps的基础核心，如果没有CICD自动化的工具和流程，DevOps是没有意义的。
- 困境:
    1. 涉及部门多
    2. 流程复杂
    3. 边界重新划分
    4. 自动化工具链是核心问题
- CI: 持续集成, 快速发现错误
- CD: 持续交付 持续部署

实践:
1. 通用工具链(jenkins,confluence,k8s,jira等)由运维推动
2. 专业工具链(例如:静态扫描,Sonar,自动化测试等)由相关职能部门推动
3. 全员灌输devops理念,每个职能推出KOL,对实践进行推动和优化
4. 依托自动化工具把开发、测试、发布、部署的过程整合，实现高度自动化与高效交付
5. 采用敏捷开发流程
    1. 采用看板方法:
        - 早上每天站会,沟通情况(任务状态，计划，以及障碍)
        - 每个月开回顾会,反思以及制定接下来的行动计划
        - 发布计划会(上线前最后的确认)
        - 小项目组,快迭代的模式
        - 小颗粒度划分任务
6. 相关职能部门推动自己的流程优化
    1. 开发:
        - 采用TDD开发模式
        - 制定代码合并标准
    2. 测试:
        - 推动自动化测试
        - 推动测试左右移
            - 左移(测试提前介入或赋能介入):
                1. 质量文化推广
                2. 质量体系建设
                3. 赋能开发自测
            - 右移(部署运营阶段的持续监控):
                1. 服务监控
                2. 业务监控

# 工程效能
1. 持续发布能力，它包括发布频率和发布前置时间，也就是从代码提交到功能上线花费的时间。
2. 需求响应周期，它包括交付周期时间和开发周期时间，交付周期时间指的是从确认用户提出的需求开始，到需求上线所经历的平均时长。开发周期时间指的是从开发团队理解需求开始，到需求可以上线所经历的平均时长。
3. 交付吞吐率，指的是单位时间内交付需求的数量；实际研发中，可以给出标准化的story/task定义，保证每个项目组的考核通用性。
4. 交付过程质量，它包含两个细分的指标，分别是开发过程中bug的创建和修复时间分布，以及bug库存; 当然, 也可以加一些譬如reopen率这样的指标。
5. 对外交付质量，它包含两个细分的指标，分别是单位时间的线上故障数，以及故障平均解决时长。

# 管理
- OKR: O 目标 KR 关键点
- action
1. 跟团队探讨质量的可能性
2. 分析并推动更优的质量管控措施
3. 质量体系规划和建设工作
4. 问题挖掘能力
# 大厂前沿
AI测试
1. 手淘AIOps实战-消息全链路异常检测
2. 从0到1，机器学习产品的精益质量

# jira
流程: 开始, 待确认, 修复中, stash, 重新打开, 待验证, 测试环境修复, 关闭, 完成

模块: 项目, 问题类型, 优先级, 概要, 经办人, 版本, 模块, 环境, 附件, 详情, 报告人

# 流程
- 瀑布式: 是一种线形的、顺序的软件开发模型
1. 特点: 顺序性, 依赖性, 具备里程碑特征, 基于文档驱动, 严格的阶段评审
2. 优点: 有利于大型软件开发过程人员的组织和管理
3. 缺点: 不够灵活, 周期长

# 用例设计
1. 等价类: 标准, 有效等价类, 无效等价类
2. 边界值: 针对条件限制的边缘进行测试
3. 错误推测法: 基于经验和直觉推测程序中所有可能存在的各种错误,从而有针对性的设计测试用例的方法
4. 因果图: 对输入条件的组合情况、输入条件之间的相互制约关系进行分析
5. 场景设计法: 通过事件流的形式测试集成状态

# 质量模型:
1. 功能性: 适合性, 准确性, 安全性
2. 可靠性: 成熟性, 容错性, 易恢复性
3. 易用性: 易理解性, 易学性, 易操作性
4. 效率: 时间, 资源
5. 维护性: 易分析性, 稳定性, 易测试性
6. 可移植性: 易安装, 易替换

# 质量影响要素
技术, 流程, 阻止

# 测试用例
用例编号

用例标题

功能模块名称

前置条件

输入数据

操作步骤

预期结果

优先级

执行结果

编写人

执行人

# 算法
1. 父子数组, 合并去重
`reduce(lambda x,y: set(x) | set(y), array)`

# 自定义nodeid
参数:
1. rename: 判断插件是否开启
2. skip: 指定需要skip的nodeid
3. skip-json: 指定需要skip的json文件

工作流:
1. `pytest_collection_modifyitems`
- 判断是否开启使用
- 提取正则结果
- 修改nodeid name

2. pytest_configure
- 判断是否开启skip和skip-json
- 将skip和skip-json合并

3. pytest_report_teststatus
- 判断是否为call阶段
- 判断状态是否为失败
- 将nodeid头部存储

4. pytest_runtest_setup
- 判断当前用例是否需要skip
- 执行skip

# 失败截图
参数:
1. screenshot: 开关
2. screenshot_path: 截图地址

1. pytest_configure
- 如果两个参数都为on, 则归档历史截图

2. pytest_runtest_makereport
- 查找driver实例
- 根据模式 执行截图
    1. 保存到指定地址
    2. 保存到`项目/screenshot`
    3. 无保存,仅附加到


# api框架
参数:
- -E: 环境
- -P: 项目
- -S: sheet
- --mark: sheet文件


1. pytest_configure
- 初始化配置, 将配置文件加载到上下文中

2. pytest_xdist_auto_num_workers
- 将并发数量调整为sheet数

3. pytest_generate_tests
- 读取excel
- 用例参数化

事件
1. 强制等待
2. 前置sql
3. 动态请求
4. 响应断言
5. 提取数据
6. 数据库断言
7. 后置sql
8. 归档

# ui框架
参数
- -P: 项目
- -E: 环境
- -S: 服务器
- -M: 模式
- -A: app包位置
- --device: 指定设备

1. pytest_configure
- 加载配置

2. pytest_collection_modifyitems
- 根据模式选择运行用例
- 将未选中用例添加到pytest_deselected中

3. pytest_runtest_makereport
- 在web模式下,发送cookie,用于在zalenium中声明运行结果

4. pytest_runtest_call
- 在web模式下,发送cookie,用于在zalenium中做注释

api用例: 500  sheet: 40+
平台用例: 700 场景100+
ui用例: 100 

# http
三次握手 四次挥手 CA证书 https交换流程 
http1.1
长连接
缓存处理
2.0
服务推送
多路复用

# nginx
优势:
- 响应快
- 高并发5w
- 低内存
- 高可靠
- 热部署

工作过程:
1. master建立监听套接字
2. master fork worker进程
3. master发送相关信号给worker
4. 所有worker的监听套接字在有新连接时都会变成可读
5. worker在读取前需要抢互斥锁
6. 抢到的worker开始处理事物, 完成后断开连接

架构:
1. master: 管理worker
2. worker: 处理网络事件

最大连接数:
1. 静态最大连接数: 连接数 * 进程 / 2
2. 反向代理最大连接数: 连接数 * 进程 / 4

命令行:
1. nginx -s reload 重启
2. nginx -s stop 快速关闭
3. nginx -s quit 优雅关闭
4. nginx restart 重启
5. nginx -v 查看版本
6. nginx 启动
7. nginx -t 检查配置

# shell
- 组:
    - groupadd 组名
    - groupdel 组名
- 用户:
    - useradd 用户名
    - userdel -r 用户名
    - passwd 用户名
    - usermod -g 组 用户名
- 属主
    - chown user file
    - chown -R user file
- 属组
    - chgrp group file
    - chgrp -R group file
- 权限
    - chmod a=rwx file
    - chmod 741 file
    - chmod u+w,g+r,o+x file
    - chmod u=wrx,g=rx,o=x file
- 其他:
    - 文件大小: `du -ah`
    - 磁盘: `df -h`
    - 内存: `free -m`
    - 关机: `init0 halt`
    - 重启: `init6 reboot`

- head: 默认前10条
- tail: 默认后10条
- cut: -d 分隔符 -f 作用域
- uniq: -c 数量 -d 仅显示重复的
- sort: -n 数字 -r 倒序 -k 作用域
- wc: 行数 单词数 字节数
- find: -name 查找文件
- grep: -i 区分大小写 -c 匹配总量 -l 文件名 -r 递归 -n 行号 -w 单词
- sed: -i 真实 -n 仅显示 -f 文件
    - a后 i前 r写入 w输出 p显示 s/old/new/ig替换 删除d
    - `/^start/,/^end/`
- awk
    - 格式: `awk 'BEGIN{}PATTERN{COMMAND}END{}' file`
    - `printf %20s%20s, $1, $2` %s %d %f
    - $0 $1 $2 $NF $NR
    - FS RS
- 表达式
    - -eq -lt -ne -gt
    - && ||
    - [ 2 == 2 ]
- 函数
    - `func(){}`
    - $0 $1 $2 $# $* $@ $?
- if
```shell
if [ ${2} -eq ${3} ]
then
    echo "1"
elif [ ${2} -gt ${3} ]
then
    echo "2"
else
    echo "3"
if
```
- for
```shell
for x in $(ls)
do
    echo ${x}
done
```
- while
```shell
while [ ${2} -lt 3 ]
do
    echo "suceess"
done
```
- until
```shell
until [ ${3} -gt 5 ]
do
    echo "until"
done
```
- case
```shell
case ${2} in
    1)
        echo "1"
        ;;
    *)
        echo "2"
esac
```

# docker
- systemctl daemon-reload
- systemctl restart docker
- systemctl start docker
- 健康检查
    - cmd interval retries timeout start-period
- dockerfile
    - FROM ENTRYPOINT LABEL RUN CMD ENV ARG COPY ADD WORKDIR USER VOLUME EXPOSE HEALTHCHECK
- docker compose
    - 命令: up down scale web=3 
        - -d守护 -f文件 -p项目
    - docker-compose.yml
        - version serivces build restart depends_on healthcheck command labels
```yaml
version: "3"

services:
  sonarqube:
    image: sonarqube:latest
    ports:
      - "9000:9000"
    networks:
      - sonarnet
    environment:
      TZ: Asia/Shanghai
      SONARQUBE_JDBC_USERNAME: sonar
      SONARQUBE_JDBC_PASSWORD: sonar
      SONARQUBE_JDBC_URL: jdbc:postgresql://db:5432/sonar
    depends_on:
      - db
      
    volumes:
      - sonarqube_conf:/opt/sonarqube/conf
      - sonarqube_data:/opt/sonarqube/data
      - sonarqube_extensions:/opt/sonarqube/extensions
      - sonarqube_bundled-plugins:/opt/sonarqube/lib/bundled-plugins
      - sonarqube_log:/opt/sonarqube/log

  db:
    image: postgres:11.1
    networks:
      - sonarnet
    environment:
      POSTGRES_USER: sonar
      POSTGRES_PASSWORD: sonar
      TZ: Asia/Shanghai
      POSTGRES_DB: sonar
    volumes:
      - postgresql_data:/var/lib/postgresql/data

networks:
  sonarnet:
    driver: bridge

volumes:
  sonarqube_conf:
  sonarqube_data:
  sonarqube_extensions:
  sonarqube_bundled-plugins:
  postgresql_data:
  sonarqube_log:
```
# jenkins
- jenkinshome: /var/jenkins_home
- pipeline: 运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂流程编排与可视化，帮助Jenkins实现从CI到CD与DevOps的转变
    - 代码（Code）: Pipeline以代码的形式实现，通常被检入源代码控制，是团队能够编辑，审查 和迭代其CD流程。
    - 可持续性（Durable）:Jenkins重启或者中断后都不会影响Pipeline Job。
    - 可停顿（Pausable）:Pipeline可以选择停止并等待人工输入或者批准，然后再继续Pipeline运行。
    - 多功能（Versatile）:Pipeline支持实现现实世界的复杂CD要求，包括fork/join子进程，循环和并行执行工作的能力。
    - 可拓展（Extensible）:Pipeline插件支持其DSL的自定义扩展及与其他插件集成的多个选项。
- 声明式 脚本式(groovy)
- pipeline agent stages stage step
- post: always success failure unstable changed
- environment input checkout parameters(调用: params.Greeting) stash存放 unstash取出 choice retry timeout超时 triggers tools when(expression not allOf anyOf) script parallel build sleep options label
- 全局变量: 
    - `env.BUILD_ID`: 当前版本ID
    - `env.JOB_NAME`: 构建项目的名称
    - `env.JENKINS_URL`: 完整的Jenkins网址(需要在系统配置)
- Jenkinsfile
- jira to wechat
    - `Generic Webhook Trigger`: 通用可配置webhook(可解析)
    - `HTTP Request Plugin`: http请求
    - 实现:
        - 在jira中设置webhook
# celery
- 架构: master broker worker 结果存储
- 命令行:
    - celery multi start w1 -A demo -l info --pidfile=./celery/%n.pid --logfile=./celery/%n%I.log
        - kill stopwait stop restart start
    - celery -A demo beat -l info --detach --logfile=./celery/%n.log
    - celery -A 工程 events
- 配置:
    - 地址 时区 过期时间 超时 并发量 限流
- shared_task
    - delay(键值对形式)
    - apply_async(args kwargs)
    - ready 状态
    - result 结果
- django_celery_beat
    - 四种定时模式: 经纬 时间 间隔 cron
    - cron五种模式: 分钟 小时 周天 月天 年月
    - name task 定时模式 参数 过期时间 开始时间 优先级 开关 运行次数 详情
    - 更新 update_changed
    - 信号: 接受close_old_connections, 运行结束, 失败, 终止
# gunicorn
- Gunicorn是一个WSGI HTTP服务器,使用了pre-fork + master-worker模式,gunicorn在启动时,会在主进程中预先fork出指定数量的worker进程来处理请求,推荐的worker数量是(2*$num_cores)+1
1. master建立监听套接字
2. master fork worker进程
3. master发送相关信号给worker
4. 所有worker的监听套接字在有新连接时都会变成可读
5. worker在读取前需要抢互斥锁
6. 抢到的worker开始处理事物, 完成后断开连接
- 命令
    - gunicorn -w 4 -b 0.0.0.0:8000 demo:app
    - -w 工人数 -b socket -D daemon运行 --worker-connections：worker最大连接数
    - reload 
    - gunicorn project_name.asgi:application -w 4 -k uvicorn.workers.UvicornWorker

# CSS
- color font-size text-align  padding margin
    - position: relative相对定位 fixed 固定定位
    - float: 浮动
    - Flex Box: 弹性盒子: display:flex flex-direction row row-reverse column column-reverse
- 选择器
    - .class  
    - #ID  
    - .class vars    
    - a[name]
- 伪类
    - :active激活 :focus焦点 :hover悬浮 :visited已访问
- 伪元素
    - :before :after :not
- 权重: !important > 行内样式 > id选择器 > 类 属性 伪类 > 标签 伪元素 > 通配符
# html
三种标签: 块元素div p 内联元素a span 内联块元素input img
# db
- offset distinct 
- 括号 > and > or
- %通配 _占位
- RTRIM LTRIM TRIM
- 时间: CURDATE() NOW() CURTIME() DATE() DATE_ADD(DATE, INTERVAL ? DATE) DATE_SUB
- 文本处理: LEN() LOWER UPPER()
- 聚合函数: AVG COUNT MAX MIN SUM ROUND
- group
    1. 在group by中使用的字段才可以在select中使用
    2. where不能用聚合函数 having可以且必须出现在select中
- 联结: inner join  left join  right join union  union all
- 插入: insert info 表名 values 更新: update 表名 set where 删除 delete from 表名 where
- 建表: CREATE TABLE 表名(字段名 类型 约束 参数)
- 加字段: ALTER TABLE 表名 ADD 名 类型 约束 参数;
- 加约束: ALTER TABLE 表名 ADD CONSTRAINT 约束 (字段);
- 删除字段: ALTER TABLE 表名 DROP COLUMN 字段;
- 删表: DROP TABLE 名;
- 重命名: RENAME TABLE OLD TO NEW
- 约束: PRIMARY KEY  REFERENCES 表(字段)  UNIQUE
- 类型: INTEGER DATETIME CHAR(10)
- 索引: CREATE INDEX 名 ON 表(字段);
- 创建用户: create user '用户名'@'host' identified by '密码';
- 修改密码:
    - SET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword');
    - set password=password("123");
- 删除用户: drop user '用户名'@'host';
- 权限: grant all on 数据库名.表名 to '用户名'@'地址';
- MYSQL_ROOT_PASSWORD=123456 root用户密码
- MYSQL_DATABASE=myproject 数据库名
- MYSQL_USER=dbuser 普通用户名
- MYSQL_PASSWORD=password  普通用户密码

# jira
问题类型 工作流 界面 字段 优先级 状态
- 状态: 转换 状态 (触发器 条件(限制操作人) 验证器 后处理功能(钩子))
- 问题类型: 功能错误 ui问题 功能确实 体验问题 系统配置 需求逻辑
- 字段: 项目 问题类型 优先级 概要 经办人 影响版本 模块 环境 描述 报告人
# JS
- 注释: //   /**/
- var let const
- 数据类型: string number boolen Null Undefined 数组 map set
- 字符串: toUpperCase, toLowerCase, indexOf, substring, split
- 数组: indexOf slice push pop unshift shift reverse splice concat join
    - 传入函数: map reduce filter every find findIndex sort
- Map: clear delete forEach get has set
- Set: add delete
- iterable
    - for...of
        - 数组: 每个元素
        - 字符串: 每个元素
        - map: 键值对
        - set: 每个元素
    - forEach
        - 数组: 元素 索引 self
        - map: 值 键 self
        - set: 元素 元素 self
- if for switch while 三元运算符
- function: arguments ...rest对象展开符
- 解析赋值 age:id=25
- 生成器&异步: async function*   async* f()  await
- call apply bind
- 错误捕获
- promise then catch resolve reject all
- document.getElementById() 除ID外都是返回数组
- onmousedown onmouseup onclick
- Date(参数|时间戳) parse(字符串"YYYY-MM-DD HH:mm:SS")
    - now getMonth(0-11) getDate(日期) getHours  toJSON
- `/REGEXP/ig` search replace
- 序列化
    - JSON.stringify(对象, 数组|函数, 缩进)
    - 在对象中声明`toJSON()`函数, 该函数return相关对象. object.toJSON()
- 构造函数(需要new)
- 原型链: 原型(prototype) 构造函数(constructor) 实例(`__proto__`)
    - 原型继承: 核心在于将原型修改为实例从而时动态添加的属性单向流动
- class: 需要`constructor`函数作为构造函数
    - 继承: class 子类 extends 父类
    - 通过 `super(参数)` 使用父类构造器
- 防抖 节流

# python
- 虚拟环境: python -m venv 名
- 规范 tab=四个空格 单行79字 顶级函数,类声明空两行 内部函数空一行
- 命名元组: collections.namedtuple("name", [k1, k2])(v1, v2)
- 集合: add update remove clear copy & | - ^
    - 原理: 创建一个散列表, 对元素进行hash, 得到的数值则为元素的下标
- 字典: 
    - 原理: 创建一个散列表, 对key进行hash, 得到数值则为key和value的下标
    - 查找原理: 通过键的一部分散列值在散列表中找, 如果找不到表元则报keyError, 如果找到表元则判断 键与表元是否相等(散列冲突) 如果不相等则用另一部分散列值去散列表的另一行中找 直至键相等取的值
- 推导式: 列表推导式 字典/集合推导式 生成器表达式 三元表达式
- 生成器 next send close throw 可迭代对象(可遍历) -> 迭代器(可next) -> 生成器
- 标准函数: functools.filter map zip functools.partial
- 内置函数: lambda n: about n expression
- 闭包
    1. 函数中嵌套函数
    2. 外层函数返回内层函数
    3. 内层函数引用外层的非全局变量
- 装饰器: (拓展)开放(修改)封闭原则 functools.wraps 用于保留函数原有的名称(`__name__`)和doc
    - 从下到上装饰, 从上到下执行
    - 类装饰器通过 `__call__`实现
- 内置装饰器(属性): classmethod staticmethod property X.getter X.setter X.deleter `__slots__`
- 魔术方法: 
    - new init: new->self->init
    - str(print str format) repr()
    - call
    - enter exit: 上下文管理区 通过 with 触发
    - add sub 算数运算
    - getattr(AttrError触发) getattribute setattr delattr
    - 描述器: get set delete (宿主实例, 宿主, 值)
- 对象属性:
    - `__dict__` 类:属性 方法  实例对象返回与实例相关的属性和方法
- 打开模式:
    - r 只读 不存在则报错 + 覆盖读写
    - w 只写 不存在则新建 + 覆盖读写
    - a 附加写 + 附加读写
- 面向对象三大特征: 封装 继承 多态
    - 菱形继承: C3算法 广度优先
    - 鸭子类型
- 元类: type(name, bases, attr)
    - 所有对象都是type的实例  实例关系type
    - 所有类的基类都是object  继承关系object
    - 定义metaclass后, 将调用元类的new方法 `__new__(cls, name, bases, attrs`
    - 做一个ORM 字段类 元类 模型类
- 内存管理:
    - is 比较内存地址 id 查看内存地址
    - 小整数池: -5 ~ 256
    - intern机制: 下划线,数字,字母组成不超过20哥自付的字符串会放入池中, 共用id
    - 深(全部)浅(仅父对象)拷贝: copy.deepcopy
    - 垃圾回收:  GC模块
        - 引用计数: 优点: 简单实时 缺点: 开销大, 无法解决循环引用
        - 标记清除: 常用于list dict tuple,解决循环引用问题. 缺点: 每次都要扫描整个堆, 扫描全部对象
        - 分代回收: 通过生存周期判断回收权重, 生存越久回收权重越低
- 并发
    - 线程 操作系统调度的最小单位
        - (threading.Thread(target=func, args, kwargs))
        - start join(time) is_alive getName setName
        - threading.current_thread() threading.enumerate() threading.activeCount()
        - run 继承类后在该函数中定义需要并发的函数, 类无需传target
        - 互斥锁(同步锁)threading.Lock()  .acquire()  .release() 死锁
        - GIL：全局解释器锁
    - 进程 进程是资源分配的最小单位 :地址空间 文件句柄集 文件系统状态 信号处理
        - multiprocessing.Process(target)
        - multiprocessing.cpu_count() .current_process() os.getpid()
        - start is_alive join kill terminate
        - 状态: 工作中 就绪状态 执行状态 等待状态
    - 进程池 multiprocessing.Pool: 可以用上下文形式使用 with Pool() as pool
        - apply apply_async(func, args, kwds, callback, error_callback) startmap colse join terminate
    - 线程队列queue.Queue: FIFO(先入先出) LIFO(后入先出) Priority(优先级, 数据)
        - qsize empty full get put task_done join
    - 进程队列 multiprocessing.Queue
    - 进程池队列 multiprocessing.Manager.Queue
    - 管道 multiprocessing.Pipe True全双工 | 接受, 发送
        - 实例方法 send recv close poll
    - 协程
        - 常用库 greenlet gevent 猴子补丁 asyncio(官方)
        - gevent: `joinall([spawn(func, args)])`
        - async await 语法糖
        - asyncio.get_event_loop(实例化) .sleep 
        - 实例方法: .run_until_complete .close
- re: match(pattern, text) compile(pattern).match
    - match的实例方法: group groups split
- datetime: strftime timestamp fromtimestamp
    - timedelta
- hashlib: md5 sha1
    - update   hexdigest 


# django
- 请求流程
`get_wsgi_application() --> WSGIHandler() --> self.load_middleware() --> __call__() --> self.get_response() --> URLconf.dispatch --> view --> Reponse`
- mtv + URLconf
- 命令行
    - django-admin startproject name .
        - 目录结构 manage.py + 配置目录(setting urls wsgi asgi) + sqlite3   
    - python manage.py runserver ip:port
    - python manage.py startapp name
        - 目录结构 admin apps models tests views
        - 应用: 创建 注册 路由(path, include)
    - shell check changepassword createsuperuser createuser
    - sqlmigrate 应用名 序号; makemigrations; migrate --database 名; showmigrations;
- setting
    - DEBUG ALLOWED_HOSTS INSTALLED_APPS DATABASES TIME_ZONE MIDDLEWARE ROOT_URLCONF DATABASE_ROUTERS MEDIA_ROOT DATABASE_APPS_MAPPING(label: db_name) USE_TZ TIME_ZONE
    - db: 引擎 数据库名 账户 密码 host port conn_max_age
    - 数据库路由: db_for_read db_for_write allow_relation allow_syncdb allow_migrate
- auth: PBKDF2
- HttpRequest:  body path method GET POST FILES
- django.utils: timezone.now()
- django.conf: settings
- models: 小写app_小写类名
    - 特性: 惰性执行 缓存
    - ORM: 面向对象 pymysql.install_as_MySQLdb
    - Meta: app_label db_table abstract ordering proxy unique_together
    - field: autofield, booleanfield, emailfield, urlfield, textfield, integerfield, decimalfield, datetimefield, charfield, ForeignField, OneToOneField ManyToManyField
        - max_length max_digits decimal_places auto_now auto_now_add
        - null blank db_column de_index default primary_key unique verbose_name help_text
        - to related_name on_delete 反向查询默认: 类_set
        - CASCADE PROTECT SET_NULL SET_DEFAULT SET() DO_NOTHING
        - m2m: add remove clear 选项: symmetrical(不支持反向)
        - through_fields(自己, 对方) through
        - 自关联 o2m m2m
    - FileField(upload_to=函数)  函数(模型实例, 文件)返地址 MEDIA_ROOT
    - JSONField: django.db.models.Value('null') 可直接搜内部key
        - 表达式: has_key has_keys has_any_keys contains
    - Choices: TextChoices IntegerChoices 类属性
        - get_字段_display()
    - QuerySet.query
    - all filter get exclude order_by reverse count first last exists limit values values_list distinct aggregate annotate
        - values在前表示分组, annotate在前表示额外字段
        - filter严格 annotate任意
    - DoesNotExist
    - 聚合函数django.db.models: Avg Count Max Min Sum
    - 过滤表达式: exact isnull in
    - 模糊匹配: contains icontains startswith endswith
    - 比较表达式: gt gte lt lte
    - 日期: year month day week_day hour minute second
    - F对象原生执行 Q对象逻辑处理 & | ~
    - 错误处理: django.shortcuts.get_object_or_404(类, 值)
    - 管理器: django.db.models.Manager
    - `bulk_create([类实例])`  `bulk_update([类实例], [字段])`
- 路由: django.urls  include path<类型:名> re_path(?P<名>规则) reverse
    - str int slug uuid path
    - namespace app_name
- 信号 django.db.models.signals  django.dispatch.receiver(signals, sender)
    - pre_save post_save(update无效) pre_init post_init pre_delete post_delete m2m_changed request_started request_finished
    - 两种使用方式: signal.connect(func, sender)  装饰器receiver()
    - 自定义: django.dispatch.Signal(providing_args=[]) .send(sender, kwargs)
- 中间件middleware 核心就是闭包
    - request: 请求上下文  get_response
    - 自定义: 外层接收get_response 内接收request
        - 类: 初始化接收get_response call接收request
    - hook: 函数需要放在内层函数内或者定义
        - process_view(request, view_func, view_args, view_kwargs) 返回 HttpResponse || None
        - process_exception(self, request, exception) 返回 HttpResponse || None
        - process_template_response(self, request, response) 返回 TemplateResponse || None
    - 异步: 通过在中间件中声明 sync_capable async_capable 确定异步支持
        - django.utils.decorators 中有三个装饰器方法
        - django.utils.deprecation.MiddlewareMixin 继承类实现异步
- 日志: 文件夹必须已创建
    - version filters formatters handlers(level, filters, class, filename, maxBytes, backupCount, formatter, encoding) loggers root
- 邮件: django.core.mail: send_mail, mail_admins
    - ADMINS= (("名", "邮箱"),)  MANAGERS
    - SERVER_EMALL DEFAULT_FROM_EMAIL EMAIL_HOST EMAIL_HOST_USER EMAIL_HOST_PASSWORD EMAIL_BACKEND
- 缓存 django.core.cache.cache
    - 配置
    - set(k,v,t) get(k,d) get.add(k, v, t) get_or_set(k, d) get_many([]) delete delete_many clear touch(k,t) incr decr
    - django_redis.get_redis_connection("name")
        - incr hmset expire hincrby hget expireat
# 部署
[部署](.././27.部署/1.部署.md)
# drf
- 序列化器
    - 字段: BooleanField CharField DecimalField DateTimeField(format, input_formats) IntegerField ReadOnlyField
    - SerializerMethodField: 通过 `get_字段名(self, obj)`使用
    - 关系序列化: PrimaryKeyRelatedField StringRelatedField 关联对象的序列化器类(many)
    - HiddenField(default=CurrentUserDefault()) request中要带user信息
    - 参数: max_length min_length allow_blank max_value min_value
        - read_only write_only required default allow_null validators error_message help_text source label
    - Meta: model fields exclude depth read_only_fields extra_kwargs validators list_serializer_class
    - 校验器: rest_framework.validators
        - UniqueValidator(qs, msg) UniqueTogetherValidator(qs, fields ,msg)
        - 单字段校验 validate_字段(self, validate)
        - 对象级 validate(self, attrs)
        - 自定义校验器 func(validate)
        - 校验顺序: 字段内validators -> 单字段 > 多字段 > list_serializer
    - Serializer(instance, data, context): 需要重写create update
        - is_valid(raise_exception)
    - ModelSerializer: 自动生成 字段 校验器 model fields必填
    - to_internal_value(self, data): 在validate前运行
    - to_representation(self, instance): .data时调用
    - ListSerializer list_serializer_class update要重写
- 视图
    - APIView: 身份认证 权限检查 流量控制 Request Response
    - GenericAPIView: 查询集 序列化器类 主键名 路由关键字 过滤器 分页器
        - queryset serliazer_class lookup_field lookup_url_kwargs filter_backends pagination_class
    - mixins: RetrieveModelMixin UpdateModelMixin DestoryModelMixin ListModelMixin CreateModelMixin
        - create perform_create list retrieve update perform_update partial_update destroy perform_destroy
    - ViewSetMixin: 重写 as_view({method: function})
        - Router action
    - ModelViewSet
- 权限
    - django
        - 增删改查: add_class change_class delete_class view_class
        - content_type表 应用和模型类关系
        - 用户类权限函数
            - get_user_permissions get_group_permissions get_all_permissions
            - has_perm has_perms has_module_perms
        - django.contrib.auth.mixins.PermissionRequiredMixin 不能与drf的认证共用
            - 类属性permission_required = ("users.view_user", "users.add_user")
    - drf rest_framework.permissions: SAFE_METHODS
        - genericAPIView会在get_object时调用, self.check_object_permissions(request，obj)
        - AllowAny IsAuthenticated IsAdminUser IsAuthenticatedOrReadOnly
        - DjangoModelPermissions DjangoObjectPermissions
        - 全局配置 DEFAULT_PERMISSION_CLASSES 类属性 permission_classes
        - 自定义: BasePermission has_permission(self, request, view) has_object_permission(self, request, view, obj)
- 限流 rest_framework.throttling
    - AnonRateThrottle:anon UserRateThrottle:user ScopedRateThrottle:自定义
    - second minute hour day
    - DEFAULT_THROTTLE_RATES  throttle_classes  throttle_scope
- 分页 rest_framework.pagination
    - LimitOffsetPagination: limit offset
    - CursorPagination
    - PageNumberPagination
        - 自定义: 类属性: page_query_param page_size_query_param max_page_size page_size
        - get_paginated_response 自定义返回值 self.page.paginator.num_pages self.page.number
    - 函数: paginate_queryset(qs) 分页 get_paginated_response(data) 添加信息
    - DEFAULT_PAGINATION_CLASS PAGE_SIZE pagination_class
- 用户系统 django.contrib.auth: User 
    - 字段: id username password last_login is_supersuer email is_active groups is_staff
    - 自定义: AbstractUser
        - 配置 AUTH_USER_MODEL
        - 新增字段: permissions mobile_no 
        - 设置密码: user实例.set_password 算法: PBKDF2
        - 函数: get_full_name get_short_name email_user get_username is_anonymous is_authenticated check_password
        - 获取用户类: django.contrib.auth.get_user_model
- 系统认证 
    - django:django.contrib.auth.backends.ModelBackend
        - authenticate: 认证逻辑, 返回user对象
        - user_can_authenticate: 判断能否认证
        - 配置: AUTHENTICATION_BACKENDS
        - 主动调用: django.contrib.auth.authenticate()
    - drf: 常用simple-jwt的后端
        - apiView中 1.dispatch 2.initialize_request 3.Request实例化调用验证
        - 自带三个认证: rest_framework.authentication: Basic Session Token
        - 自定义: BaseAuthentication
            - authenticate 校验逻辑
        - 配置: DEFAULT_AUTHENTICATION_CLASSES authentication_classes
    - 区别: django需要主动调用, 常用来进行登录校验;drf父类为APIView都可被动调用, 常用来做后续验证token识别
- 令牌 djangorestframework-simplejwt
    - token结构: header(base4(类型,算法)) playload(base64(过期时间, 用户等)) signature(HS256(header+.+playload+secret))
    - 鉴权配置: DEFAULT_AUTHENTICATION_CLASSES: rest_framework_simplejwt.authentication.JWTAuthentication
    - 配置: SIMPLE_JWT: ACCESS_TOKEN_LIFETIME:5m REFRESH_TOKEN_LIFETIME:24h 可以用timedelta对象
        - UPDATE_LAST_LOGIN:false AUTH_HEADER_NAME: Authorization AUTH_HEADER_TYPES:Bearer
    - 视图 rest_framework_simplejwt.views: TokenObtainPairView TokenRefreshView
        - 鉴权步骤: 
            1. is_valid调用validate 
            2. 调用authenticate验证账号密码 返空字典
            3. get_token中构造token数据
            4. 在空字典中添加构造出的access和refresh
            5. 返回
        - 自定义: 
            - get_token: 类似字典添加数据,增加payload数据
            - validate: 修改返回值(response.json)
            - `__init__`: 添加认证字段 `self.fields["field"]`
    - 认证后端: rest_framework_simplejwt.authentication.JWTAuthentication
        - authenticate 成功返回  (用户对象, token) 失败返None
- 路由rest_framework.routers: SimpleRouter(trailing_slash=False) DefaultRouter
    - 实例化 -> register(路由, ViewSet, basename) -> router.urls
        - 路由名: basename-list/detail
    - retriever list create update partial_update destroy
    - action(methods=[], detail, url_parh, url_name)
        - url_path默认方法名 url_name端口名默认`类-方法名`/`basename-方法名`
    - 格式: 路由/路由参数/url_path  路由/url_path
    - ViewSet: lookup_url_kwarg lookup_value_regex
- 过滤 django-filter django_filters.rest_framework.DjangoFilterBackend
    - 使用: self.filter_queryset(self.get_queryset())
    - 配置: DEFAULT_FILTER_BACKENDS filter_backends
    - 类属性: filterset_fields 默认exact  filterset_class
    - 自定义: 继承 django_filters.rest_framework.FilterSet
        - NumberFilter CharFilter BooleanFilter RangeFilter(min max) TimeRangeFilter(after before) DateFromToRangeFilter(after before)
            - method(queryset, name, value) 
            - field_name, lookup_expr, method, label, distinct, exclude
- 查询 rest_framework.filters.SearchFilter
    - 配置 DEFAULT_FILTER_BACKENDS SEARCH_PARAM:search filter_backends search_fields
    - search=book,price 结果为book price的交集 为各字段的并集
    - 规则: ^ = @ $
    - 自定义: 继承SearchFilter 重写相关函数
- 排序 rest_framework.filters.OrderingFilter
    - 配置: DEFAULT_FILTER_BACKENDS ORDERING_PARAM:ordering ordering_fields ordering
    - ordering=-id,name
- 异常捕获 rest_framework.views.exception_handler
    - 配置: EXCEPTION_HANDLER
    - 自定义: 接受(exc, context)的函数 需要返回response 
        - exc为错误对象
- 接口文档 rest_framework.schemas.coreapi.AutoSchema
    - 安装: coreapi
    - 配置 DEFAULT_SCHEMA_CLASS
    - 路由: rest_framework.documentation.include_docs_urls
        - path('docs/', include_docs_urls(title="接口文档"))
    - 在视图的doc中声明注释
- 请求 rest_framework.request.Request
    1. 根据content-type解析
    2. request.data 支持POST FORM
    3. request.param 查询字符串
    4. headers method META["REMOTE_ADDR"] auth user content_type stream
- 响应 rest_framework.response.Response
    - data status headers exception content_type
    - rest_framework.status
- 跨域 django-cors-headers 1. 注册 2. 中间件 要放在common中间件前
    - 配置 CORS_ALLOWED_ORIGINS CORS_ALLOWED_ORIGIN_REGEXES CORS_ALLOW_ALL_ORIGINS
    - 流程:
        1. 客户端第一次发送options请求询问后端是否允许跨域
        2. 允许则响应告知允许
        3. 客户端发送第二次请求(业务请求)
# vue
- npm
    - npm install -g npm
    - npm install
    - npm ls name
    - npm update
    - --registry
    - -S -D -g 
- yarn
    - yarn init
    - yarn install | yarn
    - yarn add xxx   --dev --peer --optional
    - yarn remove xxx
    - yarn upgrade
    - yarn upgrade xxx
    - yarn list
    - yarn global add remove upgrade list
    - yarn run xxx
- vue
    - 优点: 解耦视图与数据 复用组件 前端路由 状态管理 虚拟DOM
    - MVVM model view viewmodel
    - vue create project_name
    - npm init vite-app 工程名称; yarn create vite-app 工程名称
    - vscode插件 EsLint
    - element-ui  Vue.use(element-ui)
    - 响应式: ref(.value) reactive(对象) 
    - 保持源响应式: `toRef(object, [name])` toRefs(支持解构赋值)
    - 插值表达式 {{ 变量名 }} v-once v-html
    - v-bind :attr
    - v-if v-else-if v-else 高切换开销 v-show 高初始渲染开销 通过display:none 实现
    - v-for: 唯一key用于提高性能, 当数组某个元素变动时,无需全部重新渲染 (value,key,index) in object
        - count in 10 循环数字
        - v-for比v-if优先级更高 不能在同一节点一起使用
    - v-on @event
        - 修饰符: prevent
    - v-model (只能在input textarea select)
        - checkbox true-value false-value
        - 修饰符: lazy trim number
    - 生命周期: beforeCreate created beforeMount mounted beforeUpdate updated beforeUnmount unmounted
        - onBeforeMount onMounted onBeforeUpdate onUpdated onBeforeUnmount onUnmounted
    - 计算属性有缓存, 性能开销小 computed(()=>{})
    - 2+: data() methods computed watch template
    - 3+: setup(props, context)
    - 修饰符: prevent阻止默认 stop停止冒泡 capture从上到下 self once passive滚动性能
        - keydown: enter tab delete esc up down left right
        - mousedown: left middle right
    - 组件
        - 根组件 app = createApp()
        - 局部组件 Vue.component(组件名, {})
        - 全局组件 {components: {}}
        - 组件传值 props
            - props形参 1. 对类型校验 type 2. 必传校验 required 3. 默认值 default 4. 校验器 validator
            - 通过组件节点传值 单向数据流 初始化时传递一次
            - 如果没有形参则默认继承到该节点上 支持关闭继承 支持指定继承$attrs
            ```js
            const component2 = {
                props: {
                    A: {
                        type: String,
                        required: true  // 必传参数
                    },
                    B: {
                        type: Array,
                        default: [1, 2, 3, 4]
                    },
                    C: {
                        type: Boolean,
                        validator: (value)=>{
                            return value === true
                        }
                    }
                }
            }
            <counter :name="name" :age="age" height=200 :popup="popup" />
            ```
        - 子组件调用父组件 emits 支持set 对象 数组
            - emits形参 1. 支持对传值做校验
            - 调用 this.$emit("event_name", value) context.emit $emit
            - <subcomponent @event_name="event1" />
        ```js
        {
            emits: {  // 声明父组件事件并编写validator对数据进行验证
                event2: (value)=>{
                    return value<20?true:false;
                }
        }
        {
            template: `<sub @event2="function" />`
        }
        ```
        - 动态组件 `:is="component"`
        - 缓存保存 `<keep-alive></keep-alive>`
        - 多级组件传值 传值 provide  接收 inject
            - provide 对象 `provide: {age: 20}`
            - inject 数组 `['age']` 对象 `{"age": {default: 11}}`
        - 异步组件 `Vue.defineAsyncComponent(Promise实例返回template)`
    - 样式 数组 对象 字符串
    - 插槽slot

- vue-router
- axios
- vuex
- vue-cli
- vite

# 项目

# k8s
- 优点: 快速部署 快速扩展 节约资源
- 特点: 自动部署 自动重启 自动复制 自动伸缩 模块化 插件化
- 功能: 自动装箱 自我修复 水平扩展 服务发现 滚动更新 版本回退 密钥配置管理 存储编排 批处理
- 架构
    - master: 网关 调度器 控制器管理 ETCD
    - worker: kubelet(资源操作) kube-proxy网络代理 Pod(基本单元由容器+pause容器组成) Docker容器引擎
- 命令行: `kubectl [command] [type] [name] [flags]`
    - create(-f 指定文件 -o 输出类型 --dry-run 干运行) expose run set get explain edit delete rollout rolling-update scale autoscale cluster-info top describe logs(-f持续查看) exec cp apply(-f 指定文件) label
    - `kubectl create deployment nginx --image=nginx`: 拉取nginx并运行
    - `kubectl expose deployment nginx --port=80 --type=NodePort`: 对外暴露80端口 
- 核心组件:POD 部署 服务 数据卷
- yaml
```yaml
apiVersion: v1 版本
kind: Pod 类型
metadata: 资源自身属性
spec: 具体规格
```
- pod: name ready restart age
    - 概念:
        1. pod是容器, 装着docker创建的容器
        2. pod是一个逻辑分组, 有独立的专用ip, 是最小创建和管理单元
        3. pod由多个容器组成, 彼此间共享网络和存储资源.通过管理pause达到管理所有容器的效果
        4. 同一个pod的容器总是会被调度到相同节点
    - 创建pod流程
    1. 发起创建create指令到api server
    2. api server 将数据处理后写入etcd
    3. 调度器watch到etcd中有未绑定的pod, 读取数据并通过调度预选(过滤主机) 调度优选(主机打分) 从而确定绑定的主机
    4. 调度器调用网关在etcd中写入boundpod对象
    5. kubelet watch到etcd中有已绑定本node但未部署的pod, 读取数据调用docker创建相关容器,从而建立pod
    6. 通过docker得到容器状态 从而通过网关将pod状态写入etcd中
    - 资源共享:
        1. pod内容器间使用localhost通信
        2. pod间采用ip
        3. pod内所有容器可用pod声明的挂载
    - 网络实现:
        1. pause为其他容器提供共享网络和文件挂载资源
        2. 类似于docker中container网络模式一样
        3. 由pause挂载文件和网络,其他容器挂载pause/加入pause
    - 镜像拉取策略imagePullPolicy: IfNotPresent  Always  Never
    - 调度策略: 
        - 节点选择器 spec.selector: 指挥部署在含有指定label的node上 
        - 资源配额 spec.containers[].resources
            - requests: 最少资源
            - limits: 最大资源
        - 节点亲和性spec.affinity.nodeAffinity: In NotIn Exists
            - 硬亲和性: 约束条件都要满足
            - 软亲和性: 尝试满足
        - 污点和污点容忍Taint
            - NoSchedule：一定不被调度
            - PreferNoSchedule：尽量不被调度【也有被调度的几率】
            - NoExecute：不会调度，并且还会驱逐Node已有Pod
    - 重启策略: Always OnFailure Nerver
    - 生命周期: running error pending terminating unknow pullimagebackoff
    - 探针(监控检查)spec.containers[]
        - readnessProbe: 可访问检查, 有效期内未ready则调用重启策略
        - livenessProbe: 存活检查
        - 检查方式: httpGet(HTTP请求) exec(shell命令) tcpSocket
        - 初始化 间隔 超时时间
- 标签metadata.labels: 可以在各种资源对象上定义label
    - kubectl label nodes name k=v
    - kubectl label nodes name k-
    - kubectl label nodes name k=v --overwriter
    - kubectl get nodes --show-lables
- 部署/副本集/有状态集/守护进程集/job/cronjob: deployment用于管理replicaSet, rs来管理pod; deployment可以声明升级策略, 记录版本, 失败回滚
    - kubectl set image deployment web nginx=nginx:1.15 滚动升级
    - rollout status 查看升级状态 rollout history 查看历史版本
    - rollout undo 回滚   --to-revision 回滚指定版本
    - kubectl scale deployment web --replicas=10 弹性伸缩指定副本数
    - 自动弹性伸缩HPA 最大数 最小数 触发条件(cpu>50等)
- 服务: --port宿主端口 --target-port容器端口 --type类型
    - 类型: 
        - ClusterIp 集群内部访问 
        - NodePort：对外访问应用使用(映射) 
            - nodePort 对外暴露端口
            - port 服务间暴露端口 
            - tagerPort 容器端口
        - LoadBalancer：负载均衡
- 密钥/配置管理: 可以通过挂载的形式, 也可以通过环境变量形式 使用
    - 相同点: 键值对 导出变量 通过目录文件形式挂载 可热更新
    - --from-file挂载文件 --from-file=pwd=./password.txt
    - --from-literal挂在文本 --from-literal=user=./username.txt
- ingress: 精确匹配 前缀匹配 通配符
- 数据卷/数据持久化
    - emptyDir 存储临时数据的简单空目录, pod删除也会被删
    - hostPath 与宿主机映射
    - NFS
    - PV 由管理员配置的一段网络存储, 资源提供者
        - 四种状态(可用 已绑定 已释放 失败) 三种访问模式(单读写 多只读 多读写) 三种回收策略(保留 删除 回收)
    - PVC 资源使用者