以下内容绝大部分为:`Flask Web开发: 基于Python的Web应用开发实战(第2版)`读书笔记.

鉴于当前技术趋势及本人未来的技术走向,本笔记未来将弱化template(前端)方面的内容.更注重后端的实践
## 简介
flask有3个依赖库: (路由. 调试. WSGI)由Werkzeug提供, 模板系统由jinja2, 命令行由Click

flask使用的是MTV架构( Model–Template–View ), 就是模型. 模板. 视图. 

1. 一般是用户通过浏览器向我们的服务器发起一个请求(request), 这个请求回去访问视图函数, 
2. (如果不涉及到数据调用, 那么这个时候视图函数返回一个模板也就是一个网页给用户), 
3. 视图函数调用模型, 模型去数据库查找数据, 然后逐级返回, 视图函数把返回的数据填充到模板中空格中, 最后返回网页给用户. 

## 路由和视图函数

### 路由
路由命名要统一, 要以`/`开头
- 设置`/case` 访问`case/` 访问不到
- 设置`/case/` 访问`case` 将重定向至case/

- 端点(endpoint): 通过API可用的功能
- 路由(route): 用于访问端点的“名称”, 用于URL中

#### 路由注册
1. 装饰器
2. 集中注册
```py
from flask import Flask

app = Flask(__name__)  # 定义名字


# 装饰器注册
@app.route("/")
def index():
    return "hello world"


def login():
    return "hello python"


# 集中注册
# 路由. 端点. 视图函数 适用方法
app.add_url_rule(rule="/login", endpoint="endpoint", view_func=login, methods=["GET", "POST"])
if __name__ == '__main__':
    app.run(debug=True)

```
#### 动态路由
> Flask 支持在路由中使用 string . int . float 和 path 类型. path 类型是一种特殊的字符串, 与 string 类型不同的是, 它可以包含正斜线. 
```py
@app.route("/<int:id>")
def index():
    print(id)
    return "hello world"
```

```python
from flask import Flask

app = Flask(__name__)


@app.route("/<id>")
@app.route("/<int: id>")
@app.route("/<string: id>")  # 不支持含斜杠(/)
@app.route("/<float: id>")  # 支持含斜杠
@app.route("/<path: id>")
@app.route("/<uuid: id>")
def index(id):
    return id


if __name__ == '__main__':
    app.run(debug=True)
```

#### 路由映射
```py
print(app.url_map)
# Map([<Rule '/login' (HEAD, GET, OPTIONS) -> endpoint>,
# <Rule '/static/<filename>' (HEAD, GET, OPTIONS) -> static>,
# <Rule '/<id>' (HEAD, GET, OPTIONS) -> index>])
```

#### 路由默认参数

```python
@app.route("/haha/", defaults={"sid": "50"})  # sid默认为50
@app.route("/haha/<sid>")
def index(sid):
    print(sid)
    return sid


@app.route("/haha/")
@app.route("/haha/<sid>")
def index(sid="sads"):  # sid默认为sads
    print(sid)
    return sid

# 函数形参中的默认值优先级高于装饰器
```

### 视图函数
#### 装饰视图函数
1. 视图装饰器应该放最外层, 否则里面的装饰器不会生效. 
2. 视图函数包裹的装饰器不要return值, 否则会被包装成返回数据. 

```python
from flask import Flask

app = Flask(__name__)


def decorator(func):
    def decor(*args, **kwargs):
        print("我是个装饰器1")
        res = func(*args, **kwargs)
        print("我是个装饰器2")
        return res  # 其他装饰器必须返回视图函数的返回值

    return decor


@decorator  # 此处不会被运行到     
@app.route("/index")  # 支持叠加路由
@app.route("/")
@decorator
def index():
    return "<p style='color: red'> 蛤蛤蛤蛤蛤flask</p>"


if __name__ == '__main__':
    app.run(debug=True)
```

#### 类视图&可插拔视图
类视图的好处:类是可以继承的 代码可以复用 可以定义多种行为

类视图支持以类属性的形式显示声明支持的method和装饰器

类视图示例:
```python
from functools import wraps

from flask import Flask, request
from flask.views import View, MethodView

from werkzeug.utils import redirect

app = Flask(__name__)


def decorator1(func):
    @wraps(func)  # @functools.wraps(func)的作用就是保留原有函数的名称和docstring
    def decorate1(*args, **kwargs):
        print("我是装饰器前")
        res = func(*args, **kwargs)
        print("我是装饰器后")
        return res

    return decorate1


class ProjectView(View):
    # methods = ['GET', 'POST']  # 可以在类中设置,  也可以在添加路由中设置
    # decorators = (decorator1,)  # 可以在类内设置,  也可以在类外添加路由前 显式装饰

    def get(self):
        return "我是get"

    def post(self):
        return "我是post"

    def dispatch_request(self):  # 调度请求
        dispatch_pattern = {'GET': self.get, 'POST': self.post}
        method = request.method
        return dispatch_pattern.get(method)()


g = ProjectView.as_view("index")  # 视图名
d = decorator1(g)  # 装饰路由
app.add_url_rule('/index', view_func=d, methods=['GET', 'POST'])


class UserView(MethodView):
    decorators = (decorator1,)  # 可以在类内设置,  也可以在类外添加路由前 显式装饰

    def get(self, user_id="xixixi"):
        print(user_id)
        return "我是get"

    def post(self, user_id):
        return "我是post"

    def delete(self, user_id):
        # delete a single user
        pass

    def put(self, user_id):
        # update a single user
        pass


h = UserView.as_view("login")
# 如果url有传参, 则走这条路由, 将参数传递给相关函数
app.add_url_rule('/login/<user_id>', view_func=h, methods=['GET', 'POST', 'PUT', 'DELETE'])

# 如果页面无传参, 则走这条路由
app.add_url_rule('/login/', view_func=h, methods=['GET', 'POST', 'PUT', 'DELETE'], defaults={"user_id": "dddd"})
if __name__ == '__main__':
    app.run(debug=True, port=3001)
```

## flask配置
```py
app = Flask(__name__)
app.config["static_url_path"] = ""  # 静态文件地址
app.config["static_folder"] = ""  # 静态文件名
```
## FLASK命令行
### 启动flask
1. windows
```bat
set FLASK_APP=main.py # 启动文件
set FLASK_DEBUG=1 # 打开
flask run
```
2. linux
```sh
export FLASK_APP=main.py
export FLASK_DEBUG=1
flask run
```
### 其他选项
1. 帮助
```flask --help```
2. run选项的帮助
```flask run --help```
```text
-h, --host TEXT                 The interface to bind to.
-p, --port INTEGER              The port to bind to.
--cert PATH                     Specify a certificate file to use HTTPS.
--key FILE                      The key file to use when specifying a
                                certificate.
--reload / --no-reload          Enable or disable the reloader. By default
                                the reloader is active if debug is enabled.
--debugger / --no-debugger      Enable or disable the debugger. By default
                                the debugger is active if debug is enabled.
--eager-loading / --lazy-loader
                                Enable or disable eager loading. By default
                                eager loading is enabled if the reloader is
                                disabled.
--with-threads / --without-threads
                                Enable or disable multithreading.
--extra-files PATH              Extra files that trigger a reload on change.
                                Multiple paths are separated by ';'.
--help                          Show this message and exit.
```

## 请求上下文&应用上下文
|变量|类型|说明|
|-|-|-|
|current_app|应用上下文|当前应用的应用实例|
|g|应用上下文|处理请求时用来临时存储的对象, 每次请求都会重置|
|request|请求上下文|请求对象, 封装了客户端发出的http请求中的内容|
|session|请求上下文|用户会话, 字典, 存储请求间需要"记住"的值|

### 获取应用上下文对象current_app
```py
from flask import Flask, current_app
# 应用上下文在请求到来时会进行入栈操作, 若在非request上下文时, 需要手动出入栈

app_ctx = app.app_context()
app_ctx.push()  # 入栈
app2 = current_app
print(app2)
app_ctx.pop()  # 出栈
app3 = current_app
print(app3)  # 抛出异常 RuntimeError: Working outside of application context

# 常用
with app.app_context():
    app4 = current_app
    print(app4)
```

#### 应用上下文原理(代理模式)
![](./image/app_context.png)

flask在内部维护着两个线程隔离的栈，current_app指向了AppContext(应用上下文)中的栈顶，request指向了RequestContext(请求上下文)栈顶,
当请求进入的时候，Request对象被压入栈，从而request有了指向处理请求，
接下来会判断AppContext栈顶是否为空，若为空则向栈中压入一个AppContext对象，即app,从而current_app就有了指向，
所以我们在项目中使用是没有报错的，而我们上面的代码不是在请求中实现的所以AppContext栈顶为空，current_app并没有指向一个AppContext对象

1. request对象是如何在视图函数(路由)中绑定使用?

1. 最小原型里面的app是一个函数, 而flask是对象, 对象被调用是执行`__ca11__`方法.  
2. `app.__cal1__`里面的函数: `wsgi_app()`
3. `wsgi_app`源码: 会通过环境变量数据实例化一个`RequestContext(environ)`, 并执行`ctx.push()`将这个请求上文推入一个栈中.  
4. `request_ctx.push()`: 先判断一下是否有一个`appContext`, 没有的话推入一个.  
5. `_request_ctx_stack.top`: 就是现在的请求对象
6. `_app_ctx_stack.top`: 就是现在的app对象. 
```py 
@app.route('/) 
def index(): 
    a=_app_ctx_stack.top 
    b=_request_ctx_stack.top 
    return'year' 
```
7. `_request_ctx_stack.top`: 就是request
8. `_app_ctx_stack.top`: 就是current_app

### 获取应用上下文对象g
一般将单次请求中临时对象存储于此。
```py
from flask import Flask, g

# ...

@app.before_request
def before():
    g.name = "A"


@app.route("/")
def index():
    return g.name
```
### 请求对象request
flask中request对象常用的属性和方法
|属性或方法|说明|
|-|-|
|get_data()|返回请求主体的缓冲数据|
|get_json()|返回字典, 解析请求体json|
|json|同get_json()|
|url|请求的完整URL|
|headers|字典, 存储请求所有的http请求头|
|method|http请求方法|
|files|字典, 存储上传的所有文件|
|values|字典, 表单和查询字符串(form&args)的合集|
|form|字典, 存储表单字段|
|args|字典, 存储URL查询字符串参数|
|cookies|字典, 存储所有cookies|
|blueprint|蓝图(蓝图)|
|endpoint|处理该请求的flask端点名称(flask默认将视图函数名作为路由端点名称)|
|scheme|URL策略(http \| https)|
|is_secure()|通过安全的连接(https)发送请求时返回True|
|host|请求定义的主机名, 如果有定义端口, 还包括端口|
|path|url的一部分|
|query_string|返回URL查询字符串为原始二进制|
|full_path|path以及查询字符串部分|
|base_url|仅url, 没有查询字符串部分|
|remote_addr|客户端的ip|
|environ|请求的原始WSGI环境|
|stream|原始请求流|
|is_json|bool, 判断content-type是否为application/json|
|is_xhr|bool,判断请求头 X-Requested-With: XMLHttpRequest|

```py
@app.route("/", methods=["GET", "POST"])
def index():
    print("request.form", request.form)  # ImmutableMultiDict([])
    print("args", request.args)  # ImmutableMultiDict([('test', '123'), ('values', 'asjkdhas')])
    print("values", request.values)  # CombinedMultiDict([ImmutableMultiDict([('test', '123'), ('values', 'asjkdhas')]), ImmutableMultiDict([])])
    print("request.stream", request.stream)  # <_io.BytesIO object at 0x00000159A1823FC0> 原始请求的二进制
    print("cookies", request.cookies)  # {}
    print("headers", request.headers)
    """headers:
    Host: 127.0.0.1:5000
    Connection: keep-alive
    Cache-Control: max-age=0
    Upgrade-Insecure-Requests: 1
    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.113 Safari/537.36
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
    Sec-Fetch-Site: none
    Sec-Fetch-Mode: navigate
    Sec-Fetch-User: ?1
    Sec-Fetch-Dest: document
    Accept-Encoding: gzip, deflate, br
    Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
    """
    print("files", request.files)  # ImmutableMultiDict([])
    print("json", request.json)  # {'name': 'hahahahaha', 'age': 123, 'version': '1.0.0'}
    print("get_json()", request.get_json())  # 若不是post请求则返None, {'name': 'hahahahaha', 'age': 123, 'version': '1.0.0'}
    print("blueprint", request.blueprint)  # 未定义则返回None
    print("endpoint", request.endpoint)  # index
    print("method", request.method)  # GET or POST
    print("scheme", request.scheme)  # http
    print("is_secure", request.is_secure)  # False
    print("host", request.host)  # 127.0.0.1:5000
    print("path", request.path)  # / 定义的路由部分
    print("query_string", request.query_string)  # b'test=123&values=asjkdhas' 二进制bytes 查询字符串
    print("full_path", request.full_path)  # /?test=123&values=asjkdhas   path+查询字符串
    print("url", request.url)  # http://127.0.0.1:5000/?test=123&values=asjkdhas  完整url
    print("base_url", request.base_url)  # http://127.0.0.1:5000/ host+port
    print("remote_addr", request.remote_addr)  # 127.0.0.1
    print("environ", request.environ)
    print("request.is_json", request.is_json)  # True
    print("request.is_Xhr", request.is_xhr)  # False  XMLHTTPRequest
    print("get_data()", request.get_data())  # b'{\r\n\t"name": "hahahahaha",\r\n\t"age": 123,\r\n\t"version": "1.0.0"\r\n}' 二进制
    return {"hello world": "haahhaahah"}
```

### 请求钩子
|函数|说明|
|-|-|
|before_request|注册一个函数, 在每次请求前运行|
|before_first_request|注册一个函数, 只在处理第一个请求之前运行. 一般用来进行服务器初始化|
|after_request|注册一个函数, 如果运行结束没有异常抛出, 便运行该函数|
|teardown_request|注册一个函数, 每次请求结束都会运行|
**请求函数与请求钩子之间一般用上下文全局变量g**
```py
@app.before_request
def func_1():
    setattr(g, "haha", "xixixi")
    print("before_request")


@app.before_first_request
def func_2():
    print("before_first_request")


@app.after_request  # 一般用来统一修改响应的内容
def func_3(response):  # 只会在请求正常退出时才会被调用, 它必须传入一个参数来接受响应对象, 并返回一个响应对象
    print(response)
    print(getattr(g, "haha"))
    print("after_request")
    return response  # 返回一个响应对象


@app.teardown_request  # 一般用来统一释放请求所占有的资源
def func_4(exception):  # 在任何情况下都会被调用, 它必须传入一个参数来接受异常对象
    print(exception)
    print(getattr(g, "haha"))
    print("teardown_request")
```

### 响应
flask中状态码默认为200, 若需要进行自定义有两种方式
1. 直接以元组的形式`return body/template, status_code, headers`
2. 方法: `make_response()`

|属性或方法|说明|
|-|-|
|status_code|状态码|
|headers|一个类似字典的对象, 包含响应头信息|
|set_cookie()|添加响应cookie|
|delete_cookie()|删除一个cookie|
|content_length|响应体长度|
|content_type|响应类型|
|set_data()|使用字符串或者字节设置响应|
|get_data()|获取响应体|

```py
from flask import make_response


# 以传参的形式添加参数,可以混合使用
@app.route("/", methods=["GET", "POST"])
def index():
    rsp = make_response({"hello world": "haahhaahah"})
    rsp.status_code = 404
    rsp.headers["hahahah"] = "xixixixi"
    rsp.set_cookie("test", "sadjhasj")  # (key, value)
    rsp.content_length = 1000000
    rsp.content_type = "text/html"
    print(rsp.get_data(), "================")  # b'{\n  "hello world": "haahhaahah"\n}\n'
    return rsp


# 以实例属性的形式添加参数
@app.route("/user", methods=["GET", "POST"])
def user():
    res = make_response({"hello world": "haahhaahah"})
    res.response = json.dumps({"name": "dedede"})  # 必须以字符串形式,会覆盖实例化时传参
    res.status = '202'
    res.headers = {"Location": "dsads", "content-type": "application/json"}
    return res


@app.route("/login/", methods=["GET"])
def login():
    # response, status code, headers
    return {"hahah": "xixixi"}, 202, {"content-type": "application/json"}
```
![](./image/响应2.png)
![](./image/响应1.png)

#### jsonify

```py
from flask import jsonify


@app.route('/_get_current_user')
def get_current_user():
    return jsonify(username=g.user.username,
                    email=g.user.email,
                    id=g.user.id)


"""
{
            "username": "admin",
            "email": "admin@localhost",
            "id": 42
        }
"""
```
#### 显示中文
*新版本已支持无需下列修改直接显示中文*

无论是使用json.dumps()还是jsonify(), 返回中文字符时的原生格式都不会直接显示中文,以下两个方法都可以实现显示中文
1. 直接在创建的falsk对象中 `FLASK["JSON_AS_ASCII"] = False`
2. 在进行json转换时, `ensure_ascii= False`
```py
import json

from flask import Flask, make_response

app = Flask(__name__)  # 定义名字
app.config["JSON_AS_ASCII"] = False  # 全局定义成可以返回非ASCII字符


@app.route("/xx", methods=["GET", "POST"])
def root():
    # a = json.dumps({"name": "我是中文"})  # {"name": "\u6211\u662f\u4e2d\u6587"}
    a = json.dumps({"name": "我是中文"}, ensure_ascii=False)  # {"name": "我是中文"}
    res = make_response(a, 201, {"content-type": "application/json"})
    return res


@app.route("/login")
def login():
    b = json.dumps({"name": "我是中文"})  # {"name": "我是中文"}
    res = make_response()
    res.data = b  # 官方推荐使用data 而不是response
    res.status = '202'
    res.headers = {"content-type": "application/json"}
    return res


if __name__ == '__main__':
    app.run(debug=True)
```
#### 响应的类型 Content-Type

|  |  |
| --- | --- |
| 文本 | text/plain |
| HTML | text/html |
| XML | application/xml |
| json | application/json |

[](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)
### 重定向redirect
1. 通过函数`redirect("route")`
2. 在注册路由处`redirect_to="route"`
3. 在视图函数响应时`return body/template, 301, {"Location": "redirect to route"}`
```py
@app.route("/index", redirect_to="/login")  # 若在装饰器进行重定向将不会运行视图函数内的代码
def index():
    return {"xxx": "dddd不会运行到"}

@app.route("/")
def index():
    return redirect("/login")

@app.route("/", methods=["GET", "POST"])
def root():
    return {"hahah": "xixixi"}, 301, {"Location": "login"}  # 在请求头中有300+状态码 ,  location时浏览器会自动重定向
```

可以与`url_for()`一起使用,通过端点返回url
1. `redirect("/new/url")`
2. `redirect(url_for("endpoint")) `
3. `redirect(url_for("路由")) `
4. `redirect(url_for("静态文件夹", "filename"))`

### 错误响应
1. 全局错误: 
- 装饰器
- 集中注册

2. 抛出异常
    1. 视图终止函数abort, abort实际上一种处理异常的方式
    - 抛出定义异常状态码→ 定义全局错误模板
    - 直接定义异常状态码及错误模板
    2. raise
    - 抛出异常 → 定义全局错误模板

```py
@app.route("/", methods=["GET", "POST"])
def index():
    rsp = make_response({"hello world": "haahhaahah"})
    abort(404)  # 抛出错误码, 会去werkzeug.exceptions.default_exceptions找默认的错误
    # 抛出异常后不会继续执行之后程序
    return rsp

@app.route("/login")
def login():
    abort(Response("dsadasdsad"))
    abort(jsonify({'error': 'Internal server error'}))

@app.errorhandler(404)  # 全局错误
# 这个handler可以catch住所有abort(404)以及找不到对应router的处理请求
def not_found(error):
    return jsonify({'error': 'Not found'}), 404

@app.errorhandler(500)
# 可以捕获abort(500)
def internal_server_error(error):
    return jsonify({'error': 'Internal server error'}), 500

@app.errorhandler(Exception)
# 这个handler可以catch住所有的abort(500)和raise exeception.
def global_error(error):
    return jsonify({"eroor": "system error"}), 500

class MyError(Exception):
    """自定义错误类"""
    pass

@app.errorhandler(MyError)
def MyErrorHandle(error):
    response = dict(status=0, message="400 Error")
    return jsonify(response), 400
```
### 错误码

```py
from werkzeug.exceptions import default_exceptions

print(default_exceptions)
"""
{400: <class 'werkzeug.exceptions.BadRequest'>,
 401: <class 'werkzeug.exceptions.Unauthorized'>,
 403: <class 'werkzeug.exceptions.Forbidden'>,
 404: <class 'werkzeug.exceptions.NotFound'>,
 405: <class 'werkzeug.exceptions.MethodNotAllowed'>,
 406: <class 'werkzeug.exceptions.NotAcceptable'>,
 408: <class 'werkzeug.exceptions.RequestTimeout'>,
 409: <class 'werkzeug.exceptions.Conflict'>,
 410: <class 'werkzeug.exceptions.Gone'>,
 411: <class 'werkzeug.exceptions.LengthRequired'>,
 412: <class 'werkzeug.exceptions.PreconditionFailed'>,
 413: <class 'werkzeug.exceptions.RequestEntityTooLarge'>,
 414: <class 'werkzeug.exceptions.RequestURITooLarge'>,
 415: <class 'werkzeug.exceptions.UnsupportedMediaType'>,
 416: <class 'werkzeug.exceptions.RequestedRangeNotSatisfiable'>,
 417: <class 'werkzeug.exceptions.ExpectationFailed'>,
 418: <class 'werkzeug.exceptions.ImATeapot'>,
 422: <class 'werkzeug.exceptions.UnprocessableEntity'>,
 423: <class 'werkzeug.exceptions.Locked'>,
 428: <class 'werkzeug.exceptions.PreconditionRequired'>,
 429: <class 'werkzeug.exceptions.TooManyRequests'>,
 431: <class 'werkzeug.exceptions.RequestHeaderFieldsTooLarge'>,
 451: <class 'werkzeug.exceptions.UnavailableForLegalReasons'>,
 500: <class 'werkzeug.exceptions.InternalServerError'>,
 501: <class 'werkzeug.exceptions.NotImplemented'>,
 502: <class 'werkzeug.exceptions.BadGateway'>,
 503: <class 'werkzeug.exceptions.ServiceUnavailable'>,
 504: <class 'werkzeug.exceptions.GatewayTimeout'>,
 505: <class 'werkzeug.exceptions.HTTPVersionNotSupported'>}
"""
```
```py
# 自定义错误类


from werkzeug.exceptions import HTTPException


class EngineEException(HTTPException):
    code = 500
    eigen_code = 4000
    description = 'Inner Server Error'


class RequestError(EngineEException):
    code = 400


class DataNotFound(RequestError):
    code = 404
    eigen_code = 4004
    description = 'Data Not Found'

    def __init__(self, message):
        self.description = '%s Not Found' % message


class InvalidRequest(RequestError):
    eigen_code = 4005
    description = 'Invalid Request URL'


class MissingKey(RequestError):
    eigen_code = 4006
    description = 'Missing Key'

    def __init__(self, key):
        self.description = 'Missing Key `%s`' % key



# 制定一个响应
def json_response(code, error, status_code):
    response = make_response(json.dumps(dict(code=code, error=error)), status_code)
    response.headers['Content-Type'] = 'application/json; charset=utf-8'
    return response

# 异常捕获处理
@app.errorhandler(Exception)
def handler_exception(e):
    if isinstance(e, OtherException):  # 未定义
        code, status_code, error = 4000, 400, e.description
    elif isinstance(e, EigenException):
        code, status_code, error = e.eigen_code, e.code, e.description
    elif isinstance(e, HTTPException):
        code, status_code, error = e.code, e.code, e.description
    else:
        code, status_code, error = 5000, 500, '%s(%s)' % (e.__class__.__name__, str(e))
    return json_response(code, error, status_code)
```
## 数据库

> SQL 数据库擅于用高效且紧凑的形式存储结构化数据. 这种数据库需要花费大量精力保证数据的一致性, 需要考虑停电或硬件失效. 为了达到这种程度的可靠性, 关系型数据库采用一种称为 ACID 的范式, 即atomicity(原子性). consistency(一致性). isolation(隔离性)和durability(持续性). NoSQL 数据库放宽了对 ACID 的要求, 从而获得性能上的优势. 对中小型应用来说, SQL 和 NoSQL 数据库都是很好的选择, 而且性能相当. 

> 数据库抽象层, 也称为对象关系映射器(ORM)或对象文档映射器(ODM)  
> 性能较原生指令差一些, 但是相对生产力有一个很大提升

### 非面向对象的使用
#### qlite使用
```py
@app.before_request 
def before_request():
    g.db=sqlite3.connect(app.config['DATABASE'])

@app.teardown_request
def teardown_request(exception):
    db=getattr(g, 'db', None)
    if db is not None: 
        db.close()
```

#### MySQL使用

```python
def connect_to_database(): 
    conn = pymysql.connect(host='localhost', user='root', pas sword='', db='lemon_tester', charset='utf8mb4',cursorclass=pymysql.cursors.Dictcursor)
    return conn.cursor()

@app.route("/")
def index(): 
    db=connect_to_database()
    db.execute('SELECT * FROM project_info;')
    res=db.fetchal1()
    print(res)
    return 'hello'
```

### 数据库框架 Flask-SQLAlchemy
> Flask-SQLAlchemy 扩展包装了 SQLAlchemy 框架

安装库`pip install flask_sqlalchemy`
|数据库引擎|URL|
|-|-|
|MySql|mysql://username:password@hostname/database|
|sqlite(win)|sqlite:///c:/absolute/path/to/database|
|sqlite(unix)|sqlite:////absolute/path/to/database|
*username & password: 数据库的登录凭据；hostname: 服务器地址(远程或本地)；database: 指定需要使用的数据库*

#### 初始化配置数据库
```py
import os
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy


basedir = os.path.abspath(os.path.dirname(__file__))  # 动态获取工程根目录
app = Flask(__name__)

app.config['SQLALCHEMY_DATABASE_URI'] ='sqlite:///' + os.path.join(basedir, 'data.sqlite')  # 拼接数据库url
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)  # 创建数据库驱动实例
# 如果设定目录没有sqlite文件, 将会自动创建sqlite文件. 
```

### 定义模型
#### 常用的SQLAlchemy列类型
|类型名|python类型|说明|
|-|-|-|
|Integer|int|普通整数, 通常是32位|
|SmallInteger|int|取值范围小的整数, 通常是16位|
|BigInteger|int/long|不限制精度的整数|
|Float|float|浮点数|
|Numeric|decimal.Decimal|定点数|
|String|str|变长字符串|
|Text|str|变长字符串, 对较长或不限长度的字符串做了优化|
|Unicode|unicode|变长Unicode字符串|
|UnicodeText|unicode|变长Unicode字符串,对较长或不限长度的字符串做了优化|
|Boolean|bool|布尔值|
|Date|datetime.date|日期|
|Time|datetime.time|时间|
|DateTime|datetime.datetime|日期和时间|
|Interval|datetime.timedelta|时间间隔|
|Enum|str|一组字符串|
|PickleType|任何对象|自动使用pickle序列化|
|LargeBinary|str|二进制blob|
#### 常用的SQLAlchemy列选项
|选项名|说明|
|-|-|
|primary_key|列为表的主键|
|uniquey|列不允许出现重复值|
|indexy|为列创建索引, 提升查询效率|
|nullabley|允许使用空值|
|defaulty|默认值|
|comment|说明, 注释|
|index|索引|
|autoincrement|自增长|
|db.Foreignkey("project.id")|外键|

```py
class Role(db.Model):  # 继承驱动实例
    __tablename__ = 'roles'  # 定义表名, 若不定义默认为小写的类名
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)

    def __repr__(self):  # 给解释器打印自定义格式
        return '<Role %s>' % self.name

class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Interger, primary_key=True)
    username = db.Column(db.String(64), unique=True, index=True)
    # created = db.Column(db.DateTime, defaulty=datetime.now())  # 默认插入当前时间
    # remarks = db.Column(db.String(64), nullabley=True)

    def __repr__(self):  # 给解释器打印自定义格式
        return '<User %s>' % self.username
```
### 一对多关系
|选项名|说明|
|-|-|
|backref|在关系的另一个模型中添加反向引用|
|primaryjoin|明确指定两个模型之间使用的联结条件；只在模棱两可的关系中需要指定|
|lazy|指定如何加载相关记录, 可选值有 select (首次访问时按需加载). immediate (源对象加载后就加载). joined (加载记录, 但使用联结). subquery (立即加载, 但使用子查询), noload (永不加载)和 dynamic (不加载记录, 但提供加载记录的查询)|
|uselist|如果设为 False , 不使用列表, 而使用标量值|
|order_by|指定关系中记录的排序方式|
|secondary|指定多对多关系中关联表的名称|
|secondaryjoin|SQLAlchemy 无法自行决定时, 指定多对多关系中的二级联结条件|

#### backref
```py
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    name = Column(String)
    addresses = relationship("Address", backref="user")

class Address(Base):
    __tablename__ = 'addresses'

    id = Column(Integer, primary_key=True)
    email_address = Column(String, nullable=False)
    user_id = Column(Integer, ForeignKey('users.id'))

# 每个User可能有多个Address，因此我们在User类中定义了一个relationship，用于与Address建立联系。此外，我们添加了一个backref参数，使用字符串"user"作为值。这告诉SQLAlchemy在Address类中创建一个属性，该属性允许我们轻松地从Address获取与其关联的User对象
```
```py
address = session.query(Address).first()
user = address.user
```

#### back_populates
```py
class Parent(Base):
    __tablename__ = 'parent'
    id = Column(Integer, primary_key=True)
    children = relationship("Child", back_populates="parent")
 
class Child(Base):
    __tablename__ = 'child'
    id = Column(Integer, primary_key=True)
    parent_id = Column(Integer, ForeignKey('parent.id'))
    parent = relationship("Parent", back_populates="children")
```

`backref` vs `back_populates`
- `back_populates` 需要双向显示说明；backref 只需要指明一边隐式声明； 
- `back_populates` 更麻烦, backref更简单； 
- `back_populates` 更具有可读性, 能很快知道各个表之间的关系. 

### 一对一关系
只需要在一对多关系基础上的父表中使用 uselist 参数来表示。 

```py
class Parent(Base):
    __tablename__ = 'parent'
    id = Column(Integer, primary_key=True)
    child_id = Column(Integer, ForeignKey('child.id'))
    child = relationship("Child", back_populates="parent")
 
class Child(Base):
    __tablename__ = 'child'
    id = Column(Integer, primary_key=True)
    parent = relationship("Parent", back_populates="child", uselist=False)
```
```py
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship


Base = declarative_base()

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    name = Column(String(50))
    address = relationship("Address", uselist=False, backref="user")

class Address(Base):
    __tablename__ = 'addresses'

    id = Column(Integer, primary_key=True)
    email_address = Column(String(50))
    user_id = Column(Integer, ForeignKey('users.id'))
```


### 多对多关系
多对多关系 Table 适用场景:  
1. 关系表只存储2个关联表的id作为外键, 没有其他信息
2. 关联表并不能作为模型操作. 

```py
xuanke=db.Table('xuanke', 
                db.column('user_id', db.Integer, db.Foreignkey('user.id')), 
                db.column('subject_id', db.Integer, db.Foreignkey('subject.id'))

#ORM
class User(db.Mode1): 
    id=db.column(db.Integer, primary_key=True)
    name=db.column(db.string(20))
    subjects=db.relationship('Subject', secondary=xuanke, backref=db.backref('user', lazy='dynamic'), lazy='dynamic')

# lazy查询的时候的数据加载状态select
# user =User.query.get(1)
# select:user.subjects ==>[Subjcet(), Subject()]
# dynamic:user.subjects.filter().all()==>query 对象

class Subject(db.Mode1): 
    id=db.column(db.Integer, primary_key=True)
    name=db.column(db.string(20))
    students=db.relationship('Xuanke', backref='subject')


User.subjects # --> 获取的是Xuanke
subject.students.student  # -->
```

多对多关系需要获取额外内容

```python
class Xuanke(db.Mode1): 
    student_id=db.column(db.Integer, db.Foreignkey('user.id'), primary_key=True)
    subject_id=db.Column(db.Integer, db.Foreignkey('subject.id'), primary_key=True)

class User(db.Model): 
    id=db.column(db.Integer, primary_key=True)
    name=db.column(db.string(20), nullable=False)
    subjects=db.relationship('Xuanke', backref='user')

class subject(db.Model): 
    id=db.column(db.Integer, primary_key=True)
    name=db.column(db.string(20), nullable=False)
    students=db.relationship('Xuanke', backref='subject')

user=User.query.get(1)
#获取选课
xuanke=user.subjects
#获取课程
for ke in xuanke: 
    print(ke.subject)
```

### 自引用关系

```python
class Follower(db.Mode1): 
    fensi_id=db.column(db.Integer, db.Foreignkey('user.id'), primary_key=True)
    guanzhuzhe_id=db.Column(db.Integer, db.Foreignkey('user.id'), primary_key=True)

class User(db.Mode1): 
    id=db.column(db.Integer, primary_key=True)
    name=db.column(db.string(20), nullable=False)
    fensis=db.relationship('Follower', foreign_keys=[Follower.guanzhuzhe_id], backref='guanzhuzhe')
    guanzhuzhes=db.relationship('Follower', foreign_keys=[Follower.fensi_id], backref='fensi')
```

### 关联查询

```python
m=db.session.query(Module,Project).filter(Project.id==Module.project_id==2).a11()
```
### 创建表
```powershell
# windows
set FLASK_APP=main.py
flask shell
# 进入flask shell
>>> from main import db
>>> db.create_all()
# 如果数据库表已经存在于数据库中, 那么db.create_all() 不会重新创建或者更新相应的表. 
```
*清空当前数据库结构*
```powershell
set FLASK_APP=main.py
flask shell
>>> from main import db
>>> db.drop_all()  # 清空当前数据库表结构
```
### 插入行
```py
# 进入flask shell 后
from main import Role, User  # 导入两个模型类

# 实例化
admin_role = Role(name='Admin')
tom_user = User(username='tom', role=admin_role)

print(admin_role)  # <Role 'Admin'>
print(tom_user)  # <User 'tom'>
print(admin_role.id)  # None
print(tom_user.id)  # None
# 此时实例并未提交至数据库,id一般设为主键后由数据库自行管理, 所以此时获取不到id


# 实例化数据库对象
db = SQLAlchemy()

# 添加到会话
# 方法一: 
db.session.add(admin_role)
db.session.add(tom_user)
# 方法二: 可添加多个对象
db.session.add_all([admin_role, tom_uesr])

# 提交会话
db.session.commit()

print(admin_role.id)  # 1
print(tom_user.id)  # 1
```
*数据库会话能保证数据库的一致性,提交操作使用原子方式把会话中的对象全部写入数据库,避免因部分更新导致数据库不一致*

会话回滚`db.session.rollback()`
```py
# 一. 未添加到数据库会话,回滚有效
admin_role.name = "hahahahahaha"
print(admin_role.name)  # "hahahahahaha"
db.session.rollback()
print(admin_role.name)  # "Admin"

# 二. 已添加到数据库会话,回滚有效
admin_role.name = "hahahahahaha"
db.session.add(admin_role)
print(admin_role.name)  # "hahahahahaha"
db.session.rollback()
print(admin_role.name)  # "Admin"

# 三. 已提交到数据库,回滚无效
admin_role.name = "hahahahahaha"
db.session.add(admin_role)
db.session.commit()
print(admin_role.name)  # "hahahahahaha"
db.session.rollback()
print(admin_role.name)  # "hahahahahaha"
```

### 修改行
```py
# 接上
admin_role.name = 'hahaha'
db.session.add(admin_role)
db.session.commit()
```

### 删除行
```py
db.session.delete(admin_role)
db.session.commit()
```

### 查询行
```py
# 1. 所有的all()
Role.query.all()
# 2. 第一个first()
users=User.query.first()
# 3. get()通过主键去获取
users= User.query.get(1)
#如果有多个主键
users=User.query.get((1, 5))
users=User.query.get({"id": 1, "project_id": 3})
# 4. filter_by()
admin=User.query.filter_by(username='admin').first()
# 5. filter()更加复杂的查询
User.query.filter(User.email.endswith('Qexample.com')).al1()
# 6. 按某种规则对用户排序: 
User.query.order_by(User.username.desc()).all()
[<User u'admin'>, <User u'guest'>, <user u'peter'>]
# 7. 限制返回用户的数量: 
User.query.order_by(user.username.desc()).1imit(1).all()
[<User u'admin'>]

admin_role.users  # 返回列表形式外键关联的user模型对象 [<User 'tom'>]
tom_user.role  # 返回外键关联的role模型对象 <Role 'Admin'>
# 因为Role 一对多 User 所以tom_user.role返回一个对象,admin_role.users 返回列表
```
|方法|说明|
|-|-|
|all()|以列表形式返回查询的所有结果|
|first()|返回查询的第一个结果, 如果没有结果, 则返回 None|
|first_or_404()|返回查询的第一个结果, 如果没有结果, 则终止请求, 返回 404 错误响应|
|get()|返回指定主键对应的行, 如果没有对应的行, 则返回 None|
|get_or_404()|返回指定主键对应的行, 如果没找到指定的主键, 则终止请求, 返回 404 错误响应|
|count()|返回查询结果的数量|
|paginate()|返回一个 Paginate 对象, 包含指定范围内的结果|


*过滤器*
|过滤器|说明|
|-|-|
|filter()|把过滤器添加到原查询上, 返回一个新查询|
|filter_by()|把等值过滤器添加到原查询上, 返回一个新查询|
|limit()|使用指定的值限制原查询返回的结果数量, 返回一个新查询|
|offest()|偏移原查询返回的结果, 返回一个新查询|
|order_by()|根据指定条件对原查询结果进行排序, 返回一个新查询|
|group_by()|根据指定条件对原查询结果进行分组, 返回一个新查询|
```py
User.query.filter_by(role=admin_role).all()  # [<User 'tom'>]列表, all()查询符合条件的全部,role=admin_role 通过反向定义, 查询Role模型的admin_role对象

str(User.query.filter_by(role=admin_role))  # 此时对象名变成了sql原生语句
# 'SELECT users.id AS users_id, users.username AS users_username, users.role_id AS users_role_id \nFROM users \nWHERE ? = users.role_id'

mode = Role.query.filter_by(name='Admin').first()  # <Role 'Admin'>
```
*lazy*
```py
admin_role.users  # [<User 'tom'>]
# 查询有个小问题. 执行user_role.users 表达式时, 隐式的查询会调用 all() 方法, 返回一个用户列表

# 在不需要主动查询时, 我们需要返回查询对象, 进行自定义操作
# 在定义模型时, 可以在外键属性处添加 lazy参数
users = db.relationship('User', backref='role', lazy='dynamic')
admin_role.users.users.order_by(User.username).all()
```

### 集成python shell
```py
@app.shell_context_processor
def make_shell_context():
    return dict(db=db, User=User, Role=Role)  # 除了默认引入的app外, 还会引入db User Role
# flask shell 命令将自动把这些对象导入shell
```

### 使用Flask-Migrate实现数据库迁移
*这个扩展是对 Alembic 的轻量级包装, 并与 flask 命令做了集成  
数据库迁移框架能跟踪数据库模式 的变化, 然后以增量的方式把变化应用到数据库中. *

安装: `pip install flask-migrate`
```py
# 初始化
from flask_migrate import Migrate


migrate = Migrate(app, db)
```
```sh
flask db init  # 添加数据库迁移支持目录
# 会在工程根目录创建migrate目录, 里面有迁移脚本
```
在migrations目录versions中有py脚本文件, 文件中有两个函数  
1. `upgrade()`函数把迁移中的改动应用到数据库中
2. `downgrade()`函数则将改动删除

Alembic 框架 具有添加和删除改动的能力, 意味着数据库可重设到修改历史的任意一点.   
**自动创建的迁移不一定总是正确的, 有可能会漏掉一些细节,需要进行手动检查**

    使用 Flask-Migrate 管理数据库模式变化的步骤如下. 
    (1) 对模型类做必要的修改. 
    (2) 执行 flask db migrate 命令, 自动创建一个迁移脚本. 
    (3) 检查自动生成的脚本, 根据对模型的实际改动进行调整. 
    (4) 把迁移脚本纳入版本控制. 
    (5) 执行 flask db upgrade 命令, 把迁移应用到数据库中. 
```sh
# shell
flask db migrate -m "initial migration"  # 创建迁移脚本, -m remark的意思

flask db upgrade # 进行数据库迁移
```
*标记现在数据库为已更新,若使用了upgrade时会自动标记,但如果是一开始db.create_all()时就需要标记了*
```sh
# shell
flask db stamp  # 标记现在数据库为已更新
```
    在前一个迁移脚本的基础上修改的步骤如下: 
    执行 flask db downgrade 命令, 还原前一个脚本对数据库的改动
    (注意, 这可能导致部分数据丢失). 
    (2) 删除前一个迁移脚本, 因为现在已经没什么用了. 
    (3) 执行 flask db migrate 命令生成一个新的数据库迁移脚本. 这个
    迁移脚本除了前面删除的那个脚本中的改动之外, 还包括这一次对模型
    的改动. 
    (4) 根据前面的说明, 检查并应用迁移脚本. 
```sh
# shell
flask db downgrade  # 还原到上一次对数据库的改动
```
## 使用Flask-Mail提供电子邮件支持
安装:`pip install flask-mail`

flask-mail支持使用jinja2模板渲染邮件正文

flask-mail smtp服务器配置
|配置|默认值|说明|
|-|-|-|
|MAIL_SERVER|localhost|电子邮箱服务器的主机名或ip地址|
|MAIL_PORT|25|电子邮箱服务器的端口|
|MAIL_USE_TLS|False|启用传输层安全协议(TLS)|
|MAIL_USE_SSL|False|启用安全套接层(SSL)协议|
|MAIL_USERNAME|None|邮件账户的用户名|
|MAIL_PASSWORD|None|邮件账户的密码|
```py
import os
from flask_mail import Mail


# 配置
app.config['MAIL_SERVER'] = 'xx.xx.com'
app.config['MAIL_PORT'] = 587
app.config['MAIL_USE_TLS'] = True
# app.config['MAIL_USE_SSL'] = True
app.config['MAIL_USERNAME'] = os.environ.get('MAIL_USERNAME')  # 从系统环境中获取敏感凭证
app.config['MAIL_PASSWORD'] = os.environ.get('MAIL_PASSWORD')

# 初始化flask-mail
mail = Mail(app)
```
向系统环境变量写入敏感凭证(习惯python语法的同学要注意, 写入环境'='不要带空格)
```sh
# unix
export MAIL_USERNAME='邮箱账号'
export MAIL_PASSWORD='邮箱密码'
```
```powershell
# windows
set MAIL_USERNAME='邮箱账号'
set MAIL_PASSWORD='邮箱密码'
```
**实例**
```py
# 我们可以封装一个发送邮件的模板
from flask_mail import Message


app.config['FLASK_MAIL_SUBJECT_PREFIX'] = '[邮件主题前缀]'
app,config['FLASK_MAIL_SENDER'] = '发件人'

def send_mail(to, subject, template, **kwargs):
    msg = Message(app.config[FLASK_MAIL_SUBJECT_PREFIX] + subject
                  sender=app,config['FLASK_MAIL_SENDER'], recipients=[to])  # 主题, 发件人, 收件人(收件人处接收参数为列表)
    msg.body = render_template(template + '.txt', **kwargs)
    msg.html = render_template(template + '.html', **kwargs)  # 因为设定形参时只能传一个模板名,所以在方法内做模板名称的拼接
    mail.send(msg)
```
```html
<!-- mail.html -->
User <b>{{ user.username }}</b> has joined.
```
mail.txt
```text
User {{ user.username }} has joined.
```
### 异步发邮件
为了不能让发邮件占据我们系统正常运行, 所以要做成异步的模式, 如果量大还要写入队列发送,两种低消耗方法
1. 协程 genvent库 genvent.swap(func, *args, **kwargs)
2. 多线程  Thread
```py
# 多线程
from threading import Thread


def send_async_email(app, msg):
    with app.app_context():  # , Flask-Mail 的 send() 函数使用 current_app , 因此必须激活应用上下文. 
        mail.send(msg)

# 上下文是与线程配套的, 在不同的线程中执行 mail.send() 函数时, 要使用app.app_context() 人工创建应用上下文. 

def send_mail(to, subject, template, **kwargs):
    msg = Message(app.config[FLASK_MAIL_SUBJECT_PREFIX] + subject
                  sender=app,config['FLASK_MAIL_SENDER'], recipients=[to])  # 主题, 发件人, 收件人(收件人处接收参数为列表)
    msg.body = render_template(template + '.txt', **kwargs)
    msg.html = render_template(template + '.html', **kwargs)  # 因为设定形参时只能传一个模板名,所以在方法内做模板名称的拼接
    thr = Thread(target=send_async_email, args=[app, msg])
    thr.start()
    return thr


# 协程
import gevent

def send_mail(to, subject, template, **kwargs):
    msg = Message(app.config[FLASK_MAIL_SUBJECT_PREFIX] + subject
                  sender=app,config['FLASK_MAIL_SENDER'], recipients=[to])  # 主题, 发件人, 收件人(收件人处接收参数为列表)
    msg.body = render_template(template + '.txt', **kwargs)
    msg.html = render_template(template + '.html', **kwargs)  # 因为设定形参时只能传一个模板名,所以在方法内做模板名称的拼接
    association = gevent.spawn(send_async_email, [app, msg])
    return association
```
## 大型应用的结构
Flask 应用的基本结构
```
|-flasky
    |-app/
        |-templates/
        |-static/
        |-main/
            |-__init__.py
            |-errors.py
            |-forms.py
            |-views.py
        |-__init__.py
        |-email.py
        |-models.py
|-migrations/
|-tests/
    |-__init__.py
    |-test*.py
|-venv/
|-requirements.txt
|-config.py
|-flasky.py
```
这种结构有 4 个顶级文件夹: 
- Flask 应用一般保存在名为 app 的包中；
- 和之前一样, 数据库迁移脚本在 migrations 文件夹中；
- 单元测试在 tests 包中编写；
- 和之前一样, Python 虚拟环境在 venv 文件夹中. 
- requirements.txt 列出了所有依赖包, 便于在其他计算机中重新生成相同的虚拟环境；
- `config.py` 存储配置；
- `flasky.py` 定义 Flask 应用实例, 同时还有一些辅助管理应用的任务. 

### 配置选项
```py
# 示例选自Flask-Web开发(狗书) p119
import os
basedir = os.path.abspath(os.path.dirname(__file__))


class Config:  # 将通用的配置项放在父类做属性, 并且指定默认参数
    # 密钥
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard to guess string'
    # 邮件
    MAIL_SERVER = os.environ.get('MAIL_SERVER', 'xx.xx.com')
    MAIL_PORT = int(os.environ.get('MAIL_PORT', '587'))
    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS', 'true').lower() in \
        ['true', 'on', '1']
    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')
    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')
    FLASKY_MAIL_SUBJECT_PREFIX = '[Flasky]'
    FLASKY_MAIL_SENDER = 'Flasky Admin <flasky@example.com>'
    FLASKY_ADMIN = os.environ.get('FLASKY_ADMIN')
    # 数据库
    SQLALCHEMY_TRACK_MODIFICATIONS = False

    @staticmethod
    def init_app(app):
        pass


# 将需要自定义的配置放置在各个子类
class DevelopmentConfig(Config):  # 开发环境的子类
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URL') or \
        'sqlite:///' + os.path.join(basedir, 'data-dev.sqlite')


class TestingConfig(Config):  # 测试环境的子类
    TESTING = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('TEST_DATABASE_URL') or \
        'sqlite://'


class ProductionConfig(Config):  # 生产环境的子类
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \
        'sqlite:///' + os.path.join(basedir, 'data.sqlite')


# 通过字典的方式存储相关类名, 方便引用
config = {
    'development': DevelopmentConfig,
    'testing': TestingConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}
```
### 应用包 application
应用包用于存放应用的所有代码. 模板和静态文件. 
#### 应用工厂函数
在app文件的__init__.py文件中定义工厂函数, 集中初始化相关配置

工厂函数好处: 
1. 将创建应用实例的过程交给工厂函数, 通过传入不同的配置, 我们可以创建不同环境下的应用
2. 在做测试时, 为每个实例分配分配不同的配置, 从而测试每一种不同的情况
3. 想创建实例时再创建实例
```py
from flask import Flask
from flask_bootstrap import Bootstrap
from flask_mail import Mail
from flask_moment import Moment
from flask_sqlalchemy import SQLAlchemy
from config import config

bootstrap = Bootstrap()
mail = Mail()
moment = Moment()
db = SQLAlchemy()


def create_app(config_name):  # param: 想要运行的环境
    app = Flask(__name__)
    app.config.from_object(config[config_name])  # 将config中所有的配置直接导入应用
    config[config_name].init_app(app)

    # 初始化拓展
    bootstrap.init_app(app)
    mail.init_app(app)
    moment.init_app(app)
    db.init_app(app)

    # 以蓝图的形式添加路由和自定义的错误页面
    from .main import main as main_blueprint
    app.register_blueprint(main_blueprint)  # 注册蓝图

    return app
```

### 在蓝图中实现应用功能
因为采用工厂函数集中初始化的原因, 定义路由和错误响应页面变得不是特别方便. 这时使用蓝图是一个更好的解决办法. 

> 蓝图和应用类似, 也可以定义路由和错误处理程序. 不同的是, 在蓝图中定义的路由和错误处理程序处于休眠状态, 直到蓝图注册到应用上之后, 它们才真正成为应用的一部分. 使用位于全局作用域中的蓝图时, 定义路由和错误处理程序的方法几乎与单脚本应用一样. 

> 与应用一样, 蓝图可以在单个文件中定义, 也可使用更结构化的方式在
包中的多个模块中创建. 

在app包中创建一个子包(相当于子应用), 在子包的__init__.py文件中创建蓝图
```py
from flask import Blueprint

main = Blueprint('main', __name__)  #实例化一个 Blueprint 类对象; param: (必传)蓝图的名称和蓝图所在的包或模块,与应用一样, 多数情况下第二个参数使用 Python 的 __name__ 变量即可. 

# 为避免发生循环导入 于是将导入路由和错误响应放在最后. 
# 因为下面两个模块引用了main, 只有等main创建后再导入, 才不会造成循环导入
from . import views, errors
```
**注意: 原来应用时路由和错误响应都是使用app作为应用, 现在放在蓝图下时应改为main作为应用对象**
```py
# app/main/errors.py
from flask import render_template
from . import main


# 在蓝图中定义错误响应有一定的不同,若使用errorhandler装饰器的话, 只有在蓝图内部的错误才会触发程序, 如果需要注册全局应用的错误程序, 需要使用app_errorhandeler装饰器
@main.app_errorhandler(404)  
def page_not_found(e):
    return render_template('404.html'), 404


@main.app_errorhandler(500)
def internal_server_error(e):
    return render_template('500.html'), 500

```

```py
# app/main/views.py
from flask import render_template, session, redirect, url_for, current_app
from .. import db
from ..models import User
from ..email import send_email
from . import main
from .forms import NameForm


@main.route('/', methods=['GET', 'POST'])
def index():
    form = NameForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.name.data).first()
        if user is None:
            user = User(username=form.name.data)
            db.session.add(user)
            db.session.commit()
            session['known'] = False
            if current_app.config['FLASKY_ADMIN']:
                send_email(current_app.config['FLASKY_ADMIN'], 'New User',
                           'mail/new_user', user=user)
        else:
            session['known'] = True
        session['name'] = form.name.data
        return redirect(url_for('.index'))  # 在蓝图中端点名不再是类名, 而是main.index(蓝图名.类名), 在同一蓝图中可以简写成.index
    return render_template('index.html',
                           form=form, name=session.get('name'),
                           known=session.get('known', False))
```
*这意味着, 同一蓝图中的重定向可以使用简写形式(.index), 但跨蓝图的重定向必须使用带有蓝图名的完全限定端点名(main.index). *

### 应用脚本

```py
# 主脚本
import os
from flask_migrate import Migrate
from app import create_app, db
from app.models import User, Role

app = create_app(os.getenv('FLASK_CONFIG') or 'default')  # 从环境变量中获取配置, 创建指定配置的应用实例. 若没有则使用默认配置
migrate = Migrate(app, db)


@app.shell_context_processor
def make_shell_context():
    return dict(db=db, User=User, Role=Role)
```
### 依赖文件
```sh
# 生成需求文件
pip freeze > requirements.txt
# 安装需求文件
pip install -r requirements.txt
```
### 单元测试
```py
import unittest
from flask import current_app
from app import create_app, db


class BasicsTestCase(unittest.TestCase):
    def setUp(self):
        self.app = create_app('testing')  # 初始化环境
        self.app_context = self.app.app_context()  # 激活上下文
        self.app_context.push()  # 上下文入栈
        db.create_all()  # 创建数据库

    def tearDown(self):
        db.session.remove()  # 移除会话
        db.drop_all()  # 删除数据库
        self.app_context.pop()  # 上下文出栈

    def test_app_exists(self):
        self.assertFalse(current_app is None)  # 确保应用实例存在

    def test_app_is_testing(self):
        self.assertTrue(current_app.config['TESTING'])  # 确保应用在测试配置中运行

```
```py
# 启动程序
import os
import click
from flask_migrate import Migrate
from app import create_app, db
from app.models import User, Role

app = create_app(os.getenv('FLASK_CONFIG') or 'default')
migrate = Migrate(app, db)


@app.shell_context_processor  
def make_shell_context():
    return dict(db=db, User=User, Role=Role)


@app.cli.command()  # 被装饰的函数名就是命令名
@click.argument('test_names', nargs=-1)
def test(test_names):
    """Run the unit tests."""
    import unittest
    if test_names:
        tests = unittest.TestLoader().loadTestsFromNames(test_names)
    else:
        tests = unittest.TestLoader().discover('tests')
    unittest.TextTestRunner(verbosity=2).run(tests)
```
```sh
flask test
# 使用@app.cli.command()装饰器装饰的函数, 可直接在终端中启动
```
### 创建数据库
有两种方法: 

一. Flask-migrate跟踪迁移
```sh
flask db upgrade
```
二. SQLAlchemy自带的
```py
db = SQLAlchemy()
db.create_all()
```
# 实例
## 用户身份验证
**flask的身份验证拓展库**
- Flask-Login:管理已登录用户的用户会话
- Werkzeug:计算密码散列值并进行核对
- itsdangerous:生成并核对加密安全令牌
### 密码安全性
**若想保证数据库中用户密码的安全,关键在于不存储密码本身,而是存储密码的散列值**

#### 使用Werkzeug计算密码散列值
*计算密码散列值的函数接收密码作为输入,添加随机内容(盐值 )之后,使用多种单向加密算法转换密码,最终得到一个和原始密码没有关系的字符序列,而且无法还原成原始密码. 核对密码时,密码散列值可代替原始密码,因为计算散列值的函数是可复现的:只要输入(密码和盐值)一样,结果就一样. *
```py
from werkzeug.security import generate_password_hash, check_password_hash


generate_password_hash(password, method='pbkdf2:sha256',salt_length=8)
# 这个函数的输入为原始密码,返回密码散列值的字符串形式,供存入用户数据库. method 和 salt_length 的默认值就能满足大多数需求. 

check_password_hash(hash, password)
# 这个函数的参数是从数据库中取回的密码散列值和用户输入的密码. 返回值为 True 时表明用户输入的密码正确. 
```
在数据库模型类上使用散列值方法
```py
class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, index=True)
    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))
    password_hash = db.Column(db.String(128))

    # 只写不读
    @property
    def password(self):
        raise AttributeError('password is not a readable attribute')

    @password.setter
    def password(self, password):
        self.password_hash = generate_password_hash(password)  # 将散列写入

    def verify_password(self, password):
        return check_password_hash(self.password_hash, password)  # 传入密码与存储的散列密码比对

    def __repr__(self):
        return '<User %r>' % self.username

```
针对散列的单元测试
```py
import unittest
from app import create_app, db
from app.models import User


class UserModelTestCase(unittest.TestCase):
    def setUp(self):
        self.app = create_app('testing')
        self.app_context = self.app.app_context()
        self.app_context.push()
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()
        self.app_context.pop()

    def test_password_setter(self):
        u = User(password='cat')
        self.assertTrue(u.password_hash is not None)

    def test_no_password_getter(self):
        u = User(password='cat')
        with self.assertRaises(AttributeError):
            u.password

    def test_password_verification(self):
        u = User(password='cat')
        self.assertTrue(u.verify_password('cat'))
        self.assertFalse(u.verify_password('dog'))

    def test_password_salts_are_random(self):
        u = User(password='cat')
        u2 = User(password='cat')
        self.assertTrue(u.password_hash != u2.password_hash)
```
### 创建身份验证的蓝图
在app包下创建auth子包,存放auth蓝图
```py
# app/auth/__init__.py  auth包的构造函数
from flask import Blueprint

auth = Blueprint('auth', __name__)

from . import views  # 该蓝图的路由
```
模板文件有两种存放方式:
1. 在总的template目录下按蓝图创建目录存放
2. 在蓝图目录下创建template(应用会先搜索应用的模板目录,然后再搜索蓝图的模板目录)
```py
#  app/auth/views.py
from flask import render_template
from . import auth


@auth.route('/login')
def login():
    return render_template('auth/login.html') 
```
要在app目录的__init__.py中注册蓝图
```py
from .auth import auth as auth_blueprint
    app.register_blueprint(auth_blueprint, url_prefix='/auth')  # 指定了url_prefix后该蓝图的path前会加/auth
    # http://localhost:5000/auth/login
```
### 使用flask-login验证用户身份
安装:`pip install flask-login`

**如果要使用这个拓展,需要应用的相关模型实现以下方法/属性**
|属性/方法|说明|
|-|-|
|is_authenticated|如果用户提供的登录凭据有效,必须返回 True ,否则返回 False|
|is_active|如果允许用户登录,必须返回 True ,否则返回 False . 如果想禁用账户,可以返回 False|
|is_anonymous|对普通用户必须始终返回 False ,如果是表示匿名用户的特殊用户对象,应该返回 True|
|get_id|必须返回用户的唯一标识符,使用 Unicode 编码字符串|
**也可以通过集成flask-login里面的UserMixin类,已经默认实现这些功能了**
```py
from . import db, login_manager
from flask_login import UserMixin


class User(UserMixin, db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(64), unique=True, index=True)
    username = db.Column(db.String(64), unique=True, index=True)
    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))
    password_hash = db.Column(db.String(128))

# 装饰器把这个函数注册给 Flask-Login,在这个扩展需要获取已登录用户的信息时调用,返回用户对象
@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))
```
在`app/__init__.py`中
```py
from flask_login import LoginManager

login_manager = LoginManager
login_manager.login_view = 'auth.login'  # 无权限访问时,重定向到这个端点

def create_app(config_name):
    # ...
    login_manager.init_app(app)  # 初始化
    # ...
```
#### 保护路由
```py
@auth.route('/logout')  # 必须先路由
@login_required  # 禁止未授权的用户访问, 重定向到登录页
def logout():
    logout_user()
    flash('You have been logged out.')
    return redirect(url_for('main.index'))
```
#### 登录表单
```py
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, BooleanField, SubmitField
from wtforms.validators import DataRequired, Length, Email


class LoginForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired(), Length(1, 64), Email()])  # 错误msg,验证函数
    password = PasswordField('Password', validators=[DataRequired()])
    remember_me = BooleanField('Keep me logged in')
    submit = SubmitField('Log In')
```
```py
current_user.is_authenticated  # 由flask-login定义,为当前登录的用户对象
# 通过 current_user.is_authenticated 表达式就能判断当前用户是否登录
```
```py
@auth.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():  # 验证表单数据
        user = User.query.filter_by(email=form.email.data.lower()).first()
        if user is not None and user.verify_password(form.password.data):  # 判断账号和密码
            login_user(user, form.remember_me.data)  #　保持登录勾选, 在用户会话中把用户标记为已登录
            # cookie 有效期默认一年
            next = request.args.get('next')  # 读取原url,url确保是相对URL
            if next is None or not next.startswith('/'):
                next = url_for('main.index')
            return redirect(next)
        flash('Invalid email or password.')
    return render_template('auth/login.html', form=form)
```
### 退出登录
```py
@auth.route('/logout')
@login_required
def logout():
    logout_user()  # 删除并重设用户会话
    flash('You have been logged out.')
    return redirect(url_for('main.index'))
```
```py

```
```py

```


```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```

# 其他插件
## 文件上传
文件上传: 可使用`flask-upload`

有一条原则是“永远不要信任用户输入”. 这条原则同样适用已上传文件的文件名. 所有提交的表单数据可能是伪造的, 文件名也可以是危险的. 比如说上传一个文件通过相对路径来替换你系统的文件. 此时要谨记: 在把文件保存到文件系统之前总是要使用这个函数对文件名进行安检. 

所以在保存的时候必须使用`from werkzeug.utils import secure_filename`对文件进行处理
```py
from flask import Flask, request
from werkzeug.utils import secure_filename

app = Flask(__name__)  # 定义名字
app.config["MAX_CONTENT_LENGTH"] = 1024*1024  # 413 Request Entity Too Large


@app.route("/", methods=["GET", "POST"])
def root():
    file = request.files.get("name")  # 文件对象
    print(file)
    print(file.filename)  # 文件名
    if file.filename in ("png"):  # 限制文件格式
        file.save(secure_filename(file.filename))
        return "GG"
    if request.method == "GET":
        print(request.args)  # ImmutableMultiDict([('user', 'hahah')])
    elif request.method == "POST":
        print(request.json)  # {'user': 'hahahaha'}
    return "测试test"


# 访问文件
@app.route("/read", methods=["GET", "POST"])
def root():
    return send_from_directory(os.path.dirname(__name__), "ludashi.jpg")


if __name__ == '__main__':
    app.run(debug=True)
```

# RESTful API风格
http://www.pythondoc.com/flask-restful/first.html
# 部署

## docker
dockerfile
```dockerfile
FROM python:3.6-alpine  
# 指定一个基容器镜像
# 这里使用的是 3.6 版解释器,基于 Alpine Linux 发行版构建. 容器镜像经常使用 AlpineLinux,因为它体量小. 

ENV FLASK_APP flasky.py
ENV FLASK_CONFIG production
# ENV定义运行时环境变量,变量名及其值


RUN adduser -D flasky  # 容器中创建一个名为 flasky 的用户 -D 参数禁止命令提示用户输入密码
USER flasky  # 命令选择以哪个用户的身份运行容器 默认root

WORKDIR /home/flasky  # 定义应用所在的顶层目录

COPY requirements requirements  # 从本地文件系统中把文件复制到容器的文件系统中
RUN python -m venv venv  # 创建虚拟环境
RUN venv/bin/pip install -r requirements/docker.txt # 选择虚拟环境进行安装依赖库

COPY app app  # 只需复制生产环境需要的文件
COPY migrations migrations
COPY flasky.py config.py boot.sh ./

# run-time configuration
EXPOSE 5000  # 定义服务器安装在容器的哪个端口上
ENTRYPOINT ["./boot.sh"]  # 指定启动容器时如何运行应用
```
```sh
python -m venv venv
# -m 为python3.3之后创建轻量虚拟环境的参数
# 第一个参数为 虚拟环境 名称
# 第二个参数为 虚拟环境的位置  venv目录的意思
```
boot.sh
```sh
#!/bin/sh
source venv/bin/activate  # 初始化环境
flask deploy  # 运行部署程序
exec gunicorn -b :5000 --access-logfile - --error-logfile - flasky:app  # 启动 Gunicorn 服务器
# 监听 5000 端口 --access 访问日志 --error错误日志
# exec 会代替原有shell进程,运行exec的命令. Docker 会特别留意启动容器的进程, 如果该进程停止, 容器也会停止. 使用exec替代后, Docker便一直监听该进程
```
docker mysql 
```sh
docker run --name mysql -d -e MYSQL_RANDOM_ROOT_PASSWORD=yes -e MYSQL_DATABASE=flasky -e MYSQL_USER=flasky -e MYSQL_PASSWORD=<database-password> mysql/mysql-server:5.7
# --name mysql创建一个名为mysql的容器；
# MYSQL_RANDOM_ROOT_PASSWORD 随机创建root用户密码 密码可以使用docker log mysql在日志中查看；
# MYSQL_DATABASE 创建数据库(名)；
# MYSQL_USER 创建数据库用户；
# MYSQL_PASSWORD 创建数据库密码；
# 最后是指定要使用的镜像
```
服务容器关联数据库容器
```sh
docker run -d -p 8000:5000 --link mysql:dbserver -e DATABASE_URL=mysql+pymysql://flasky:<database-password>@dbserver/flasky -e MAIL_USERNAME=<your-gmail-username> -e MAIL_PASSWORD=<your-gmail-password> flasky:latest
# . --link 选项把这个新容器与一个现有的容器连接起来. value是以冒号分隔的两个名称:一个是目标容器的名称或 IDID, 另一个是设定在当前容器中访问目标容器所用的别名.目标容器名为mysql, 在当前容器中访问目标容器可通过别名(dbserver)访问
# DATABASE_URL 设定数据库url环境变量, falsky为之前设定的数据库用户名, dbserver为主机ip, 用别名时Docker会解析成ip
```