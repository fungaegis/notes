以下内容绝大部分为:`Flask Web开发: 基于Python的Web应用开发实战(第2版)`读书笔记.

鉴于当前技术趋势及本人未来的技术走向,本笔记未来将弱化template方面的内容.更注重restful风格的实践
## 简介
flask有3个依赖库: (路由. 调试. WSGI)由Werkzeug提供, 模板系统由jinja2, 命令行由Click

flask使用的是MTV架构( Model–Template–View ), 就是模型. 模板. 视图. 

1. 一般是用户通过浏览器向我们的服务器发起一个请求(request), 这个请求回去访问视图函数, 
2. (如果不涉及到数据调用, 那么这个时候视图函数返回一个模板也就是一个网页给用户), 
3. 视图函数调用模型, 模型去数据库查找数据, 然后逐级返回, 视图函数把返回的数据填充到模板中空格中, 最后返回网页给用户. 

## 路由和视图函数

### 路由
路由命名要统一, 要以`/`开头
- 设置`/case` 访问`case/` 访问不到
- 设置`/case/` 访问`case` 将重定向至case/

- 端点(endpoint): 通过API可用的功能
- 路由(route): 用于访问端点的“名称”, 用于URL中

#### 路由注册
1. 装饰器
2. 集中注册
```py
from flask import Flask

app = Flask(__name__)  # 定义名字


# 装饰器注册
@app.route("/")
def index():
    return "hello world"


def login():
    return "hello python"


# 集中注册
# 路由. 端点. 视图函数 适用方法
app.add_url_rule(rule="/login", endpoint="endpoint", view_func=login, methods=["GET", "POST"])
if __name__ == '__main__':
    app.run(debug=True)

```
#### 动态路由
> Flask 支持在路由中使用 string . int . float 和 path 类型. path 类型是一种特殊的字符串, 与 string 类型不同的是, 它可以包含正斜线. 
```py
@app.route("/<int:id>")
def index():
    print(id)
    return "hello world"
```

```python
from flask import Flask

app = Flask(__name__)


@app.route("/<id>")
@app.route("/<int: id>")
@app.route("/<string: id>")  # 不支持含斜杠(/)
@app.route("/<float: id>")  # 支持含斜杠
@app.route("/<path: id>")
@app.route("/<uuid: id>")
def index(id):
    return id


if __name__ == '__main__':
    app.run(debug=True)
```

#### 路由映射
```py
print(app.url_map)
# Map([<Rule '/login' (HEAD, GET, OPTIONS) -> endpoint>,
# <Rule '/static/<filename>' (HEAD, GET, OPTIONS) -> static>,
# <Rule '/<id>' (HEAD, GET, OPTIONS) -> index>])
```

#### 路由默认参数

```python
@app.route("/haha/", defaults={"sid": "50"})  # sid默认为50
@app.route("/haha/<sid>")
def index(sid):
    print(sid)
    return sid


@app.route("/haha/")
@app.route("/haha/<sid>")
def index(sid="sads"):  # sid默认为sads
    print(sid)
    return sid

# 函数形参中的默认值优先级高于装饰器
```

### 视图函数
#### 装饰视图函数
1. 视图装饰器应该放最外层, 否则里面的装饰器不会生效. 
2. 视图函数包裹的装饰器不要return值, 否则会被包装成返回数据. 

```python
from flask import Flask

app = Flask(__name__)


def decorator(func):
    def decor(*args, **kwargs):
        print("我是个装饰器1")
        res = func(*args, **kwargs)
        print("我是个装饰器2")
        return res  # 其他装饰器必须返回视图函数的返回值

    return decor


@decorator  # 此处不会被运行到     
@app.route("/index")  # 支持叠加路由
@app.route("/")
@decorator
def index():
    return "<p style='color: red'> 蛤蛤蛤蛤蛤flask</p>"


if __name__ == '__main__':
    app.run(debug=True)
```

#### 类视图&可插拔视图
类视图的好处:类是可以继承的 代码可以复用 可以定义多种行为

类视图支持以类属性的形式显示声明支持的method和装饰器

类视图示例:
```python
from functools import wraps

from flask import Flask, request
from flask.views import View, MethodView

from werkzeug.utils import redirect

app = Flask(__name__)


def decorator1(func):
    @wraps(func)  # @functools.wraps(func)的作用就是保留原有函数的名称和docstring
    def decorate1(*args, **kwargs):
        print("我是装饰器前")
        res = func(*args, **kwargs)
        print("我是装饰器后")
        return res

    return decorate1


class ProjectView(View):
    # methods = ['GET', 'POST']  # 可以在类中设置,  也可以在添加路由中设置
    # decorators = (decorator1,)  # 可以在类内设置,  也可以在类外添加路由前 显式装饰

    def get(self):
        return "我是get"

    def post(self):
        return "我是post"

    def dispatch_request(self):  # 调度请求
        dispatch_pattern = {'GET': self.get, 'POST': self.post}
        method = request.method
        return dispatch_pattern.get(method)()


g = ProjectView.as_view("index")  # 视图名
d = decorator1(g)  # 装饰路由
app.add_url_rule('/index', view_func=d, methods=['GET', 'POST'])


class UserView(MethodView):
    decorators = (decorator1,)  # 可以在类内设置,  也可以在类外添加路由前 显式装饰

    def get(self, user_id="xixixi"):
        print(user_id)
        return "我是get"

    def post(self, user_id):
        return "我是post"

    def delete(self, user_id):
        # delete a single user
        pass

    def put(self, user_id):
        # update a single user
        pass


h = UserView.as_view("login")
# 如果url有传参, 则走这条路由, 将参数传递给相关函数
app.add_url_rule('/login/<user_id>', view_func=h, methods=['GET', 'POST', 'PUT', 'DELETE'])

# 如果页面无传参, 则走这条路由
app.add_url_rule('/login/', view_func=h, methods=['GET', 'POST', 'PUT', 'DELETE'], defaults={"user_id": "dddd"})
if __name__ == '__main__':
    app.run(debug=True, port=3001)
```

## flask配置
```py
app = Flask(__name__)
app.config["static_url_path"] = ""  # 静态文件地址
app.config["static_folder"] = ""  # 静态文件名
```
## FLASK命令行
### 启动flask
1. windows
```bat
set FLASK_APP=main.py # 启动文件
set FLASK_DEBUG=1 # 打开
flask run
```
2. linux
```sh
export FLASK_APP=main.py
export FLASK_DEBUG=1
flask run
```
### 其他选项
1. 帮助
```flask --help```
2. run选项的帮助
```flask run --help```
```text
-h, --host TEXT                 The interface to bind to.
-p, --port INTEGER              The port to bind to.
--cert PATH                     Specify a certificate file to use HTTPS.
--key FILE                      The key file to use when specifying a
                                certificate.
--reload / --no-reload          Enable or disable the reloader. By default
                                the reloader is active if debug is enabled.
--debugger / --no-debugger      Enable or disable the debugger. By default
                                the debugger is active if debug is enabled.
--eager-loading / --lazy-loader
                                Enable or disable eager loading. By default
                                eager loading is enabled if the reloader is
                                disabled.
--with-threads / --without-threads
                                Enable or disable multithreading.
--extra-files PATH              Extra files that trigger a reload on change.
                                Multiple paths are separated by ';'.
--help                          Show this message and exit.
```

## 请求上下文&应用上下文
|变量|类型|说明|
|-|-|-|
|current_app|应用上下文|当前应用的应用实例|
|g|应用上下文|处理请求时用来临时存储的对象, 每次请求都会重置|
|request|请求上下文|请求对象, 封装了客户端发出的http请求中的内容|
|session|请求上下文|用户会话, 字典, 存储请求间需要"记住"的值|

获取应用上下文对象
```py
app_ctx = app.app_context()
app_ctx.push()
app_ctx.pop()
```

### 原理(代理模式)
1. request对象是如何在视图函数(路由)中绑定使用?

1. 最小原型里面的app是一个函数, 而flask是对象, 对象被调用是执行`__ca11__`方法.  
2. `app.__cal1__`里面的函数: `wsgi_app()`
3. `wsgi_app`源码: 会通过环境变量数据实例化一个`RequestContext(environ)`, 并执行`ctx.push()`将这个请求上文推入一个栈中.  
4. `request_ctx.push()`: 先判断一下是否有一个`appContext`, 没有的话推入一个.  
5. `_request_ctx_stack.top`: 就是现在的请求对象
6. `_app_ctx_stack.top`: 就是现在的app对象. 
```py 
@app.route('/) 
def index(): 
    a=_app_ctx_stack.top 
    b=_request_ctx_stack.top 
    return'year' 
```
7. `_request_ctx_stack.top`: 就是request
8. `_app_ctx_stack.top`: 就是current_app
### 请求对象request
flask中request对象常用的属性和方法
|属性或方法|说明|
|-|-|
|get_data()|返回请求主体的缓冲数据|
|get_json()|返回字典, 解析请求体json|
|json|同get_json()|
|url|请求的完整URL|
|headers|字典, 存储请求所有的http请求头|
|method|http请求方法|
|files|字典, 存储上传的所有文件|
|values|字典, 表单和查询字符串(form&args)的合集|
|form|字典, 存储表单字段|
|args|字典, 存储URL查询字符串参数|
|cookies|字典, 存储所有cookies|
|blueprint|蓝本(蓝图)|
|endpoint|处理该请求的flask端点名称(flask默认将视图函数名作为路由端点名称)|
|scheme|URL策略(http \| https)|
|is_secure()|通过安全的连接(https)发送请求时返回True|
|host|请求定义的主机名, 如果有定义端口, 还包括端口|
|path|url的一部分|
|query_string|返回URL查询字符串为原始二进制|
|full_path|path以及查询字符串部分|
|base_url|仅url, 没有查询字符串部分|
|remote_addr|客户端的ip|
|environ|请求的原始WSGI环境|
|stream|原始请求流|
|is_json|bool, 判断content-type是否为application/json|
|is_xhr|bool,判断请求头 X-Requested-With: XMLHttpRequest|

```py
@app.route("/", methods=["GET", "POST"])
def index():
    print("request.form", request.form)  # ImmutableMultiDict([])
    print("args", request.args)  # ImmutableMultiDict([('test', '123'), ('values', 'asjkdhas')])
    print("values", request.values)  # CombinedMultiDict([ImmutableMultiDict([('test', '123'), ('values', 'asjkdhas')]), ImmutableMultiDict([])])
    print("request.stream", request.stream)  # <_io.BytesIO object at 0x00000159A1823FC0> 原始请求的二进制
    print("cookies", request.cookies)  # {}
    print("headers", request.headers)
    """headers:
    Host: 127.0.0.1:5000
    Connection: keep-alive
    Cache-Control: max-age=0
    Upgrade-Insecure-Requests: 1
    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.113 Safari/537.36
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
    Sec-Fetch-Site: none
    Sec-Fetch-Mode: navigate
    Sec-Fetch-User: ?1
    Sec-Fetch-Dest: document
    Accept-Encoding: gzip, deflate, br
    Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
    """
    print("files", request.files)  # ImmutableMultiDict([])
    print("json", request.json)  # {'name': 'hahahahaha', 'age': 123, 'version': '1.0.0'}
    print("get_json()", request.get_json())  # 若不是post请求则返None, {'name': 'hahahahaha', 'age': 123, 'version': '1.0.0'}
    print("blueprint", request.blueprint)  # 未定义则返回None
    print("endpoint", request.endpoint)  # index
    print("method", request.method)  # GET or POST
    print("scheme", request.scheme)  # http
    print("is_secure", request.is_secure)  # False
    print("host", request.host)  # 127.0.0.1:5000
    print("path", request.path)  # / 定义的路由部分
    print("query_string", request.query_string)  # b'test=123&values=asjkdhas' 二进制bytes 查询字符串
    print("full_path", request.full_path)  # /?test=123&values=asjkdhas   path+查询字符串
    print("url", request.url)  # http://127.0.0.1:5000/?test=123&values=asjkdhas  完整url
    print("base_url", request.base_url)  # http://127.0.0.1:5000/ host+port
    print("remote_addr", request.remote_addr)  # 127.0.0.1
    print("environ", request.environ)
    print("request.is_json", request.is_json)  # True
    print("request.is_Xhr", request.is_xhr)  # False  XMLHTTPRequest
    print("get_data()", request.get_data())  # b'{\r\n\t"name": "hahahahaha",\r\n\t"age": 123,\r\n\t"version": "1.0.0"\r\n}' 二进制
    return {"hello world": "haahhaahah"}
```

### 请求钩子
|函数|说明|
|-|-|
|before_request|注册一个函数, 在每次请求前运行|
|before_first_request|注册一个函数, 只在处理第一个请求之前运行. 一般用来进行服务器初始化|
|after_request|注册一个函数, 如果运行结束没有异常抛出, 便运行该函数|
|teardown_request|注册一个函数, 每次请求结束都会运行|
**请求函数与请求钩子之间一般用上下文全局变量g**
```py
@app.before_request
def func_1():
    setattr(g, "haha", "xixixi")
    print("before_request")


@app.before_first_request
def func_2():
    print("before_first_request")


@app.after_request  # 一般用来统一修改响应的内容
def func_3(response):  # 只会在请求正常退出时才会被调用, 它必须传入一个参数来接受响应对象, 并返回一个响应对象
    print(response)
    print(getattr(g, "haha"))
    print("after_request")
    return response  # 返回一个响应对象


@app.teardown_request  # 一般用来统一释放请求所占有的资源
def func_4(exception):  # 在任何情况下都会被调用, 它必须传入一个参数来接受异常对象
    print(exception)
    print(getattr(g, "haha"))
    print("teardown_request")
```

### 响应
flask中状态码默认为200, 若需要进行自定义有两种方式
1. 直接以元组的形式`return body/template, status_code, headers`
2. 方法: `make_response()`

|属性或方法|说明|
|-|-|
|status_code|状态码|
|headers|一个类似字典的对象, 包含响应头信息|
|set_cookie()|添加响应cookie|
|delete_cookie()|删除一个cookie|
|content_length|响应体长度|
|content_type|响应类型|
|set_data()|使用字符串或者字节设置响应|
|get_data()|获取响应体|

```py
from flask import make_response


# 以传参的形式添加参数,可以混合使用
@app.route("/", methods=["GET", "POST"])
def index():
    rsp = make_response({"hello world": "haahhaahah"})
    rsp.status_code = 404
    rsp.headers["hahahah"] = "xixixixi"
    rsp.set_cookie("test", "sadjhasj")  # (key, value)
    rsp.content_length = 1000000
    rsp.content_type = "text/html"
    print(rsp.get_data(), "================")  # b'{\n  "hello world": "haahhaahah"\n}\n'
    return rsp


# 以实例属性的形式添加参数
@app.route("/user", methods=["GET", "POST"])
def user():
    res = make_response({"hello world": "haahhaahah"})
    res.response = json.dumps({"name": "dedede"})  # 必须以字符串形式,会覆盖实例化时传参
    res.status = '202'
    res.headers = {"Location": "dsads", "content-type": "application/json"}
    return res


@app.route("/login/", methods=["GET"])
def login():
    # response, status code, headers
    return {"hahah": "xixixi"}, 202, {"content-type": "application/json"}
```
![](./image/响应2.png)
![](./image/响应1.png)

#### jsonify

```py
from flask import jsonify


@app.route('/_get_current_user')
def get_current_user():
    return jsonify(username=g.user.username,
                    email=g.user.email,
                    id=g.user.id)


"""
{
            "username": "admin",
            "email": "admin@localhost",
            "id": 42
        }
"""
```
#### 显示中文
新版本已支持无需下列修改直接显示中文

无论是使用json.dumps()还是jsonify(), 返回中文字符时的原生格式都不会直接显示中文,以下两个方法都可以实现显示中文
1. 直接在创建的falsk对象中 `FLASK["JSON_AS_ASCII"] = False`
2. 在进行json转换时, `ensure_ascii= False`
```py
import json

from flask import Flask, make_response

app = Flask(__name__)  # 定义名字
app.config["JSON_AS_ASCII"] = False  # 全局定义成可以返回非ASCII字符


@app.route("/xx", methods=["GET", "POST"])
def root():
    # a = json.dumps({"name": "我是中文"})  # {"name": "\u6211\u662f\u4e2d\u6587"}
    a = json.dumps({"name": "我是中文"}, ensure_ascii=False)  # {"name": "我是中文"}
    res = make_response(a, 201, {"content-type": "application/json"})
    return res


@app.route("/login")
def login():
    b = json.dumps({"name": "我是中文"})  # {"name": "我是中文"}
    res = make_response()
    res.data = b  # 官方推荐使用data 而不是response
    res.status = '202'
    res.headers = {"content-type": "application/json"}
    return res


if __name__ == '__main__':
    app.run(debug=True)
```
#### 响应的类型 Content-Type

|  |  |
| --- | --- |
| 文本 | text/plain |
| HTML | text/html |
| XML | application/xml |
| json | application/json |

[](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)
### 重定向redirect
1. 通过函数`redirect("route")`
2. 在注册路由处`redirect_to="route"`
3. 在视图函数响应时`return body/template, 301, {"Location": "redirect to route"}`
```py
@app.route("/index", redirect_to="/login")  # 若在装饰器进行重定向将不会运行视图函数内的代码
def index():
    return {"xxx": "dddd不会运行到"}

@app.route("/")
def index():
    return redirect("/login")

@app.route("/", methods=["GET", "POST"])
def root():
    return {"hahah": "xixixi"}, 301, {"Location": "login"}  # 在请求头中有300+状态码 ,  location时浏览器会自动重定向
```

可以与`url_for()`一起使用,通过端点返回url
1. `redirect("/new/url")`
2. `redirect(url_for("endpoint")) `
3. `redirect(url_for("路由")) `
4. `redirect(url_for("静态文件夹", "filename"))`

### 错误响应
1. 全局错误: 
- 装饰器
- 集中注册

2. 抛出异常
    1. abort函数 abort实际上一种处理异常的方式
    - 抛出定义异常状态码→ 定义全局错误模板
    - 直接定义异常状态码及错误模板
    2. raise
    - 抛出异常 → 定义全局错误模板


```py
@app.route("/", methods=["GET", "POST"])
def index():
    rsp = make_response({"hello world": "haahhaahah"})
    abort(404)  # 抛出异常后不会继续执行之后程序
    return rsp

@app.route("/login")
def login():
    abort(Response("dsadasdsad"))
```

## 模板(jinja2)
### 变量
Jinja2 能识别所有类型的变量, 甚至是一些复杂的类型, 例如列表. 字典和对象；
在视图函数返回响应处可以传参
```html
<p>A value from a dictionary: {{ mydict['key'] }}.</p>
<p>A value from a list: {{ mylist[3] }}.</p>
<p>A value from a list, with a variable index: {{ mylist[myintvar] }}.</p>
<p>A value from an object's method: {{ myobj.somemethod() }}.</p>
```

### 过滤器
|函数|说明|
|-|-|
|safe|渲染值时不转义|
|capitalize|把值的首字母改为大写, 其他为小写|
|lower|把值改为小写|
|upper|把值改为大写|
|title|把值中每个单词的首字母改为大写|
|trim|把值的首尾空格去除|
|striptags|渲染前将值中的html标签去除|
```html
Hello, {{ name|capitalize }}

<!-- {#当变量未定义时, 显示默认字符串, 可以缩写为d#} -->
<p>{{name | default('No name', true)}}</p>
<!-- {#单词首字母大写#} -->
<p>{{'hel1o' | capitalize}}</p>
<!-- {#单词全小写#} -->
<p>{{'XML'| lower}}</p>
<!-- {#去除字符串前后的空白字符#} -->
<p>{{' he1lo ' | trim}}</p>
<!-- {#字符串反转, 返回“o11eh”#} -->
<p>{{'hello' | reverse}}</p>
<!-- {#格式化输出, 返回"Numberis 2”#} -->
<p>{{%s is %d' | format("Number", 2)}}</p>

<!-- {#关闭HTML自动转义#} -->
<p>{{'<em>name</em>'I safe}}</p>
{%autoescape false%}
<!-- {#HTML转义, 即使autoescape关了也转义, 可以缩写为e#} -->
<p>{{'<em>name</em>' |  escape}}</p>
{%endautoescape%}
```
#### 数字
```html
<!-- {#四舍五入取整, 返回13.0#} -->
<p>{{12.8888 | round}}</p>
<!-- {#向下截取到小数点后2位, 返回12.88#} -->
<p>{{12.8888 | round(2, 'floor')}}</p>
<!-- {#绝对值, 返回12#}| -->
<p>{{-12 | abs}}</p>
```

#### 列表
```html
<!-- {#取第一个元素#} -->
<p>{{[1, 2, 3, 4, 5] | first }}</p>
<!-- {#取最后一个元素#} -->
<p>{{[1, 2, 3, 4, 5] | last }}</p>
<!-- {#返回列表长度, 可以写为count#} -->
<p>{{[1, 2, 3, 4, 5]|1ength }}</p>
<!-- {#列表求和#} -->
<p>{{[1, 2, 3, 4, 5] | sum }}</p>
<!-- {#列表排序, 默认为升序#} -->
<p>{{[3, 2, 1, 5, 4] | sort }}</p>
<!-- {#合并为字符串, 返回“1|2|3|4|5"#} -->
<p>{{[1, 2, 3, 4, 5] | join('|')}}</p>
<!-- {#列表中所有元素都全大写. 这里可以用upper, lower, 但capitalize无效#} -->
<p>{{['tom', 'bob', 'ada'] | upper }}</p>
```

#### 判断
除了过滤器, 所谓的“测试”也是可用的. 测试可以用于对照普通表达式测试一个变量. 要测试一个变量或表达式, 你要在变量后加上一个is以及测试的名称. 例如, 要得出一个值是否定义过, 你可以用name is defined, 这会根据name是否定义返回true或false. 

测试也可以接受参数. 如果测试只接受一个参数, 你可以省去括号来分组它们. 例如, 下面的两个表达式做同样的事情: 
- `{%if 1oop.index is divisibleby3%}`
- `{%if loop.index is divisibleby(3)%}`

```html
<!-- {#检查变量是否被定义, 也可以用undefined检查是否未被定义#} -->
{% if name is defined %}
<p>Name is:{{ name }}</p>
{%endif%}
<!-- {#检查是否所有字符都是大写#} -->
{%if name is upper%}
<h2>"{{ name}}"are all upper case.</h2>
{%endif%}
<!-- {#检查变量是否为空#} -->
{% if name is none %}
<h2>variable is none.</h2>
{%endif%}
<!-- {#检查变量是否为字符串, 也可以用number检查是否为数值#} -->
{% if name is string %}
<h2>{{ name}}is a string.</h2>
{%endif%}
<!-- {#检查数值是否是偶数, 也可以用odd检查是否为奇数#} -->
{% if 2 is even%}
<h2>variable is an even number.</h2>
{%endif%}
<!-- {#检查变量是否可被迭代循环, 也可以用sequence检查是否是序列#} -->
{%if[1, 2, 3]is iterable%}
<h2>variable is iterable.</h2>
{%endif%}
<!-- {#检查变量是否是字典#} -->
{%if{'name': 'test'}is mapping%}
<h2>variable is dict.</h2>
{%endif%}
```
### 控制结构
```html
<!-- f循环-->
{% if user %}
    Hello ,{{user}}!
{% else %}
    Error
{% endif %}

<!-- for循环 -->
{% for x in args %}
    <li>{{x}}</li>
{% endfor %}

<!-- 默认每个for元素之间会有空白, 如果要去除, 使用- -->
{% for p in projects - %}
项目: {{p.name}}: {{p.interfaces}}
{%-endfor%}
```
- loop.index当前循环迭代的次数(从1开始)
- loop.index0当前循环迭代的次数(从0开始)
- loop.revindex到循环结束需要迭代的次数(从1开始)
- loop.revindex0到循环结束需要迭代的次数(从0开始)
- loop.first如果是第一次迭代, 为True. 
- loop.last如果是最后一次迭代, 为True.  
- loop.length序列中的项目数. 

### 宏(函数)
```html
<!-- 宏基类文件 -->
<!-- 定义宏 -->
{% macro func(args)  %}
    <li>{{args}}</li>
{% endmacro %}

<!-- 同文件下使用宏 -->
{% for i in comments %}
    {{ func(i) }}
{% endfor %}
```
```html
<!-- 另一个引用宏基类的文件 -->
{% import "宏模板.html" as macros %}

<ul>
    {% for i in comments %}
        {{ macros.func(i) }}
    {% endfor %}
</ul>
```
### 包含模板
`include` 子模板完全拥有父类内容.
```html
<!-- common.html -->
<div>
    <ul>
        <li>贴吧</li>
        <li>音乐</li>
    </ul>
</div>
```
```html
<body>
{% include 'common.html' %}
</body>
```
### 继承模板
`extends` 继承模板, 共性抽取, 代码复用,子类可以扩充独有内容
```html
<!-- base.html -->
<html>
<head>
    {% block head %}
    <title>Baidu - {% block title %}{% endblock %}</title>
    {% endblock %}
</head>
<body>
    {% block body %}
    {% endblock %}
</body>
</html>
```
```html
<!-- 衍生模板 -->
{% extends "base.html" %}
{% block title %}Index{% endblock %}
{% block head %}
{{super()}}
<style src="xx.css"></style>
{% endblock %}
{% block body %}
<div>content text!</div>
{% endblock %}
```
### include & extends 区别
> include基类一般为公用组件, 子类引用全部代码  
> extends基类一般为整个html的骨架, 由子类去填充空白

### Flask-Bootstrap
`pip install flask-bootstrap`  bootstrap库里面有现成模板骨架
https://getbootstrap.com/docs/4.1/getting-started/introduction/

|块名|说明|
|-|-|
|doc|整个html页面|
|html_attribs|`<html>`页面标签的属性|
|html|`<html>`标签中的内容|
|head|`<head>`标签中的内容|
|title|`<title>`标签中的内容|
|metas|一组`<meta>`标签|
|styles|CSS声明|
|body_attribs|`<body>`标签的属性|
|body|`<body>`标签中的内容|
|navbar|导航栏|
|content|页面内容|
|scrpit|文档底部的js声明|
*如果应用需要向已经有内容的块中添加新内容, 必须使用 Jinja2 提供的 super() 函数*
```py
from flask_bootstrap import Bootstrap
from flask import Flask

app = Flask(__name__)
# bootstrap初始化会将应用实例作为参数传给构造函数
bootstrap = Bootstrap(app)
```
```html
<!-- 继承boostrap基模板 -->
{% extends "bootstrap/base.html" %} 
{% block title %}<h1>这里是title</h1>{% endbolck %}
{% block navbar %}<h1>这是导航栏</h1>{% endblock %}
{% block content %}<h1>这个是正文</h1>{% endblock %}
<!-- script块已有定义内容,  不可随意覆盖使用 -->
{% block script%}
{{super()}}
<script src='my_script.js'></script>
```

### 自定义错误页面
```py
@app.errorhandler(404)  # 错误处理函数
def page_not_found(e):  # 
    return render_template('404.html'), 404

@app.errorhandler(500)
def server_error(e):
    return reder_template('500.html'), 500
```
*html页面可以通过二次封装bootstrap基模板, 一般情况下页面导航来都是公用模块, 此时可以封装一个统一的导航栏成为一个新的基类模板*

### 链接
`url_for()`函数可以通过应用实例URL映射中保存的信息生成URL
```py
url_for(view_func)  # 传视图端点名
url_for(index, _external=True)  # 返回绝对路径 http://localhost:5000/
# 生成内部使用的链接 相对路径即可, 外部链接则需要绝对路径

# 生成动态URL,动态URL所需要的动态参数可直接传入
name = "haha"
url_for(user, name=name, _external=True)

# 传给 url_for() 的关键字参数不仅限于动态路由中的参数, 非动态的参数也会添加到查询字符串中
# 设name为动态参数 即 app.route("/<name>")
url_for(user, name="jj", version=3, code=4, page=20, _external=True)
# http://localhost:5000/jj?version=3&code=4&page=20
```

### 静态文件
*html文件引入静态资源的时候建议使用url_for生成动态路径,为了避免覆盖原有样式, 注意使用超继承*
```html
{% block head %}
{{super()}}
<style src="{{ url_for('static', filename='xixi.css') }}, type='text/css'">
{% endblock %}
```

### 使用Flask-Moment本地化日期和时间
官方使用手册: http://momentjs.com/docs/#/displaying/ 

*Moment.js个使用 JavaScript 开发的优秀客户端开源库;  
可以在浏览器中渲染日期和时间  
moment有format() . fromNow(). fromTime() . calendar() . valueOf() 和 unix() 等方法*

安装命令: `pip install flask-moment`
```py
# 初始化
from flask_moment import Moment
from flask import Flask
from flask_bootstrap import Bootstrap


app = Flask(__name__)
bootstrap = Bootstrap(app)
moment = Moment(app)
# js, Flask-Moment 还依赖 jQuery.js

@app.route("index")
def index():
    return render_template("index.html", current_time=datetime.utcnow())
```
```html
<!-- base.html -->
<!-- 前端需要在html基类模板中设置scripts -->
{% block scripts %}
{{super()}}
{{monment.include_moment()}}
{{moment.loacle("cn")}}
<!-- loacle声明需要将时间转为指定国家的时间 -->
{% endblock %}
```
```html
<!-- index.html -->
{{ moment(current_time).format('LLL') }}  
<!-- format渲染日期和时间. 参数决定了渲染的方式, 从 'L' 到 'LLLL' 分别对应不同的复杂度 -->
{{ moment(current_time).formNow(refresh=True) }}
<!-- 这个时间戳最开始显示为“a few seconds ago”, 但设定refresh=True 参数后, 其内容会随着时间的推移而更新.  -->
```

## Web表单
用户填写的信息通过`request.form` 访问
### flask-wtf
安装:`pip install flask-wtf`
```py
# 配置
import uuid
from flask import Flask


app = Flask(__name__)
# 防止CSRF跨站攻击 需要配置密钥, 常规需要配置到环境变量中. 本例为展示方便直接放在源码中
app.config["SECRET_KEY"] = uuid.uuid4()  # 62d08e22-de7b-4d4c-b3c1-6720be981bfd
```
```py
# 定义表单类
from flask_wtf import FlaskForm
from wtfroms import StringField, SubmitField
from wtforms.validators import DateRequired

class NameForm(FlaskForm):
    name = StringField("这个是格式错误时返回的msg", validators=[DateRequired()])
    # StringField 类表示属性为type="text" 的 HTML <input> 元素. 
    # validators指定一个由验证函数组成的列表
    submit = SubmitField('Submit')
    # SubmitField 类表示属性为type="submit" 的 HTML <input> 元素

@app.route("/", methods=["post", "get"])
def index():
    form = NameForm()
    return reder_template("index.html", form=form)
```
```html
<!-- 使用原生渲染时除了要写以下表格外还需要对其进行样式美化 -->
<form method="post">
<!-- form.hidden_tag() 元素. 这个元素生成一个隐藏的字段, 供 Flask-WTF 的 CSRF 防护机制使用.  -->
    {{ form.hidden_tag() }}
    {{ form.name.label }}{{ form.name(id='my-text-field') }}
    {{ form.submit() }}
</form>
```
```html
<!-- 使用flask-bootstrap, 效果与上方原生一样 -->
{% import "bootstrap/wth.html" as wtf %}
{{ wth.quick_form(form) }}
<!-- wtf.quick_form() 函数的参数为 Flask-WTF 表单对象 -->
```
**WTForms支持的HTML标准字段**
|函数|说明|
|-|-|
|BooleanField|复选框, True/False|
|DateField|文本, datetime.date格式|
|DateTimeField|文本字段, 值为 datetime.datetime 格式|
|DecimalField|文本字段, 值为 decimal.Decimal|
|FileField|文件上传字段|
|HiddenField|隐藏的文本字段|
|MultipleFileField|多文件上传字段|
|FieldList|一组指定类型的字段|
|FloatField|文本字段, 值为浮点数|
|FormField|把一个表单作为字段嵌入另一个表单|
|IntegerField|文本字段, 值为整数|
|PasswordField|密码文本字段|
|RadioField|一组单选按钮|
|SelectField|下拉列表|
|SelectMultipleField|下拉列表, 可选择多个值|
|SubmitField|表单提交按钮|
|StringField|文本字段|
|TextAreaField|多行文本字段|
**WTForms验证函数**
|函数|说明|
|-|-|
|DataRequired|确保转换类型后字段中有数据|
|Email|验证电子邮件地址|
|EqualTo|比较两个字段的值；常用于要求输入两次密码进行确认的情况|
|InputRequired|确保转换类型前字段中有数据|
|IPAddress|验证 IPv4 网络地址|
|Length|验证输入字符串的长度|
|MacAddress|验证 MAC 地址|
|NumberRange|验证输入的值在数字范围之内|
|Optional|允许字段中没有输入, 将跳过其他验证函数|
|Regexp|使用正则表达式验证输入值|
|URL|验证 URL|
|UUID|验证 UUID|
|AnyOf|确保输入值在一组可能的值中|
|NoneOf|确保输入值不在一组可能的值中|
**示例**
```py
@app.route('/index', methods=['GET', 'POST'])
def index1():
    name = None
    form = NameForm()
    if form.validate_on_submit():  # 数据能否被所有验证函数接受,validate_on_submit() 会调用名字字段上依附的DataRequired() 验证函数
        name = form.name.data
        form.name.data = ''  # 清空表单数据
    return render_template('index.html', form=form, name=name)
```
```html
<!-- 继承基类&使用web表单对象 -->
{% extends "base.html" %}
{% import "bootstrap/wtf.html" as wtf %}

{% block title %}Flasky{% endblock %}

{% block page_content %}
<div class="page-header">
    <h1>Hello, {% if name %}{{ name }}{% else %}Stranger{% endif %}!</h1>
</div>
{{ wtf.quick_form(form) }}
{% endblock %}
```

**结合重定向使用**
```py
@app.route('/', methods=['GET', 'POST'])
def index():
    form = NameForm()
    if form.validate_on_submit():
        session['name'] = form.name.data  # 将用户数据存于用户会话(seesion)中
        return redirect(url_for('index'))  # 若不进行重定向, 用户在表单页刷新时会有警告(表单内容未清空)
    return render_template('index.html', form=form, name=session.get('name'))  # session可以当成字典一样使用
```

### 消息闪现
后台代码需要执行`flash(msg)` 前端模板最好在基模板中渲染闪现消息`get_flashed_messages()`, 因为这样所有页面都能显示需要显示的消息
```py
@app.route('/', methods=['GET', 'POST'])
def index():
    form = NameForm()
    if form.validate_on_submit():
        old_name = session.get('name')
        if old_name is not None and old_name != form.name.data:
            flash('Looks like you have changed your name!')
        session['name'] = form.name.data
        return redirect(url_for('index'))
    return render_template('index.html', form=form, name=session.get('name'))
```
```html
{% for message in get_flashed_messages() %}
<div class="alert alert-warning">  
<!-- 使用 Bootstrap 提供的 CSS alert 样式渲染警告消息 -->
    <button type="button" class="close" data-dismiss="alert">&times;</button>
    {{ message }}
</div>
{% endfor %}
```

## 数据库

> SQL 数据库擅于用高效且紧凑的形式存储结构化数据. 这种数据库需要花费大量精力保证数据的一致性, 需要考虑停电或硬件失效. 为了达到这种程度的可靠性, 关系型数据库采用一种称为 ACID 的范式, 即atomicity(原子性). consistency(一致性). isolation(隔离性)和durability(持续性). NoSQL 数据库放宽了对 ACID 的要求, 从而获得性能上的优势. 对中小型应用来说, SQL 和 NoSQL 数据库都是很好的选择, 而且性能相当. 

> 数据库抽象层, 也称为对象关系映射器(ORM)或对象文档映射器(ODM)  
> 性能较原生指令差一些, 但是相对生产力有一个很大提升

### 非面向对象的使用
#### qlite使用
```py
@app.before_request 
def before_request():
    g.db=sqlite3.connect(app.config['DATABASE'])

@app.teardown_request
def teardown_request(exception):
    db=getattr(g, 'db', None)
    if db is not None: 
        db.close()
```

#### MySQL使用

```python
def connect_to_database(): 
    conn = pymysql.connect(host='localhost', user='root', pas sword='', db='lemon_tester', charset='utf8mb4',cursorclass=pymysql.cursors.Dictcursor)
    return conn.cursor()

@app.route("/")
def index(): 
    db=connect_to_database()
    db.execute(' SELECT * FROM project_info;')
    res=db.fetchal1()
    print(res)
    return 'hello'
```

### 数据库框架 Flask-SQLAlchemy
> Flask-SQLAlchemy 扩展包装了 SQLAlchemy 框架

安装库`pip install flask_sqlalchemy`
|数据库引擎|URL|
|-|-|
|MySql|mysql://username:password@hostname/database|
|sqlite(win)|sqlite:///c:/absolute/path/to/database|
|sqlite(unix)|sqlite:////absolute/path/to/database|
*username & password: 数据库的登录凭据；hostname: 服务器地址(远程或本地)；database: 指定需要使用的数据库*

#### 初始化配置数据库
```py
import os
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy


basedir = os.path.abspath(os.path.dirname(__file__))  # 动态获取工程根目录
app = Flask(__name__)

app.config['SQLALCHEMY_DATABASE_URI'] ='sqlite:///' + os.path.join(basedir, 'data.sqlite')  # 拼接数据库url
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)  # 创建数据库驱动实例
# 如果设定目录没有sqlite文件, 将会自动创建sqlite文件. 
```

### 定义模型
#### 常用的SQLAlchemy列类型
|类型名|python类型|说明|
|-|-|-|
|Integer|int|普通整数, 通常是32位|
|SmallInteger|int|取值范围小的整数, 通常是16位|
|BigInteger|int/long|不限制精度的整数|
|Float|float|浮点数|
|Numeric|decimal.Decimal|定点数|
|String|str|变长字符串|
|Text|str|变长字符串, 对较长或不限长度的字符串做了优化|
|Unicode|unicode|变长Unicode字符串|
|UnicodeText|unicode|变长Unicode字符串,对较长或不限长度的字符串做了优化|
|Boolean|bool|布尔值|
|Date|datetime.date|日期|
|Time|datetime.time|时间|
|DateTime|datetime.datetime|日期和时间|
|Interval|datetime.timedelta|时间间隔|
|Enum|str|一组字符串|
|PickleType|任何对象|自动使用pickle序列化|
|LargeBinary|str|二进制blob|
#### 常用的SQLAlchemy列选项
|选项名|说明|
|-|-|
|primary_key|列为表的主键|
|uniquey|列不允许出现重复值|
|indexy|为列创建索引, 提升查询效率|
|nullabley|允许使用空值|
|defaulty|默认值|
|comment|说明, 注释|
|index|索引|
|autoincrement|自增长|
|db.Foreignkey("project.id")|外键|

```py
class Role(db.Model):  # 继承驱动实例
    __tablename__ = 'roles'  # 定义表名, 若不定义默认为小写的类名
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)

    def __repr__(self):  # 给解释器打印自定义格式
        return '<Role %s>' % self.name

class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Interger, primary_key=True)
    username = db.Column(db.String(64), unique=True, index=True)
    # created = db.Column(db.DateTime, defaulty=datetime.now())  # 默认插入当前时间
    # remarks = db.Column(db.String(64), nullabley=True)

    def __repr__(self):  # 给解释器打印自定义格式
        return '<User %s>' % self.username
```
### 一对多关系
|选项名|说明|
|-|-|
|backref|在关系的另一个模型中添加反向引用|
|primaryjoin|明确指定两个模型之间使用的联结条件；只在模棱两可的关系中需要指定|
|lazy|指定如何加载相关记录, 可选值有 select (首次访问时按需加载). immediate (源对象加载后就加载). joined (加载记录, 但使用联结). subquery (立即加载, 但使用子查询), noload (永不加载)和 dynamic (不加载记录, 但提供加载记录的查询)|
|uselist|如果设为 False , 不使用列表, 而使用标量值|
|order_by|指定关系中记录的排序方式|
|secondary|指定多对多关系中关联表的名称|
|secondaryjoin|SQLAlchemy 无法自行决定时, 指定多对多关系中的二级联结条件|

#### backref
```py
class Role(db.Model):  # 一
    __tablename__ = 'roles'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)
    users = db.relationship('User', backref='role') 
     # 代表这个关系的面向对象视角, 返回与角色相关联的用户组成的列表(即“多”那一端)
     # db.relationship()第一个参数表明这个关系的另一端是哪个模型
     # backref 参数向 User 模型中添加一个 role属性, 从而定义反向关系;通过 User 实例的这个role属性可以获取对应的Role模型对象, 而不用再通过 role_id 外键获取

    def __repr__(self):
        return '<Role %s>' % self.name

class User(db.Model):  # 多
    __tablename__ = 'users'
    id = db.Column(db.Interger, primary_key=True)
    username = db.Column(db.String(64), unique=True, index=True)
    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))  
    # 定义外键, 传给db.ForeignKey() 的参数 'roles.id' 表明, 这列的值是 roles 表中相应行的 id 值. 

    def __repr__(self):
        return '<User %s>' % self.username
```
#### back_populates
```py
class Project(db.Mode1): 
    #这里的modules和Module里面的back_populaters='modules'相等
    modules=db.relationship('Module', back_populates='project')

class Module(db.Mode1): 
    #这里的project和Project 里面的back_populaters='project'相等
    project=db.relationship('Module', back_populates='modules')
```

backref vs back_populates
- `back_populates` 需要双向显示说明；backref 只需要指明一边隐式声明； 
- `back_populates` 更麻烦, backref更简单； 
- `back_populates` 更具有可读性, 能很快知道各个表之间的关系. 

### 一对一关系

### 多对多关系
多对多关系 Table 适用场景:  
1. 关系表只存储2个关联表的id作为外键, 没有其他信息
2. 关联表并不能作为模型操作. 

```py
xuanke=db.Table('xuanke', 
                db.column('user_id', db.Integer, db.Foreignkey('user.id')), 
                db.column('subject_id', db.Integer, db.Foreignkey('subject.id'))

#ORM
class User(db.Mode1): 
    id=db.column(db.Integer, primary_key=True)
    name=db.column(db.string(20))
    subjects=db.relationship('Subject', secondary=xuanke, backref=db.backref('user', lazy='dynamic'), lazy='dynamic')

# lazy查询的时候的数据加载状态select
# user =User.query.get(1)
# select:user.subjects ==>[Subjcet(), Subject()]
# dynamic:user.subjects.filter().all()==>query 对象

class Subject(db.Mode1): 
    id=db.column(db.Integer, primary_key=True)
    name=db.column(db.string(20))


User.subjects # --> 获取的是Xuanke
subject.students.student  # -->
```

多对多关系需要获取额外内容

```python
class Xuanke(db.Mode1): 
    student_id=db.column(db.Integer, db.Foreignkey('user.id'), primary_key=True)
    subject_id=db.Column(db.Integer, db.Foreignkey('subject.id'), primary_key=True)

class User(db.Model): 
    id=db.column(db.Integer, primary_key=True)
    name=db.column(db.string(20), nullable=False)
    subjects=db.relationship('Xuanke', backref='user')

class subject(db.Model): 
    id=db.column(db.Integer, primary_key=True)
    name=db.column(db.string(20), nullable=False)
    students=db.relationship('Xuanke', backref='subject')

user=User.query.get(1)
#获取选课
xuanke=user.subjects
#获取课程
for ke in xuanke: 
    print(ke.subject)
```

### 自引用关系

```python
class Follower(db.Mode1): 
    fensi_id=db.column(db.Integer, db.Foreignkey('user.id'), primary_key=True)
    guanzhuzhe_id=db.Column(db.Integer, db.Foreignkey('user.id'), primary_key=True)

class User(db.Mode1): 
    id=db.column(db.Integer, primary_key=True)
    name=db.column(db.string(20), nullable=False)
    fensis=db.relationship('Follower', foreign_keys=[Follower.guanzhuzhe_id], backref='guanzhuzhe')
    guanzhuzhes=db.relationship('Follower', foreign_keys=[Follower.fensi_id], backref='fensi')
```

### 关联查询

```python
m=db.session.query(Module,Project).filter(Project.id==Module.project_id==2).a11()
```
### 创建表
```powershell
# windows
set FLASK_APP=main.py
flask shell
# 进入flask shell
>>> from main import db
>>> db.create_all()
# 如果数据库表已经存在于数据库中, 那么db.create_all() 不会重新创建或者更新相应的表. 
```
*清空当前数据库结构*
```powershell
set FLASK_APP=main.py
flask shell
>>> from main import db
>>> db.drop_all()  # 清空当前数据库表结构
```
### 插入行
```py
# 进入flask shell 后
from main import Role, User  # 导入两个模型类

# 实例化
admin_role = Role(name='Admin')
tom_user = User(username='tom', role=admin_role)

print(admin_role)  # <Role 'Admin'>
print(tom_user)  # <User 'tom'>
print(admin_role.id)  # None
print(tom_user.id)  # None
# 此时实例并未提交至数据库,id一般设为主键后由数据库自行管理, 所以此时获取不到id


# 实例化数据库对象
db = SQLAlchemy()

# 添加到会话
# 方法一: 
db.session.add(admin_role)
db.session.add(tom_user)
# 方法二: 可添加多个对象
db.session.add_all([admin_role, tom_uesr])

# 提交会话
db.session.commit()

print(admin_role.id)  # 1
print(tom_user.id)  # 1
```
*数据库会话能保证数据库的一致性,提交操作使用原子方式把会话中的对象全部写入数据库,避免因部分更新导致数据库不一致*

会话回滚`db.session.rollback()`
```py
# 一. 未添加到数据库会话,回滚有效
admin_role.name = "hahahahahaha"
print(admin_role.name)  # "hahahahahaha"
db.session.rollback()
print(admin_role.name)  # "Admin"

# 二. 已添加到数据库会话,回滚有效
admin_role.name = "hahahahahaha"
db.session.add(admin_role)
print(admin_role.name)  # "hahahahahaha"
db.session.rollback()
print(admin_role.name)  # "Admin"

# 三. 已提交到数据库,回滚无效
admin_role.name = "hahahahahaha"
db.session.add(admin_role)
db.session.commit()
print(admin_role.name)  # "hahahahahaha"
db.session.rollback()
print(admin_role.name)  # "hahahahahaha"
```

### 修改行
```py
# 接上
admin_role.name = 'hahaha'
db.session.add(admin_role)
db.session.commit()
```

### 删除行
```py
db.session.delete(admin_role)
db.session.commit()
```

### 查询行
```py
# 1. 所有的all()
Role.query.all()
# 2. 第一个first()
users=User.query.first()
# 3. get()通过主键去获取
users= User.query.get(1)
#如果有多个主键
users=User.query.get((1, 5))
users=User.query.get({"id": 1, "project_id": 3})
# 4. filter_by()
admin=User.query.filter_by(username='admin').first()
# 5. filter()更加复杂的查询
User.query.filter(User.email.endswith('Qexample.com')).al1()
# 6. 按某种规则对用户排序: 
User.query.order_by(User.username.desc()).all()
[<User u'admin'>, <User u'guest'>, <user u'peter'>]
# 7. 限制返回用户的数量: 
User.query.order_by(user.username.desc()).1imit(1).all()
[<User u'admin'>]

admin_role.users  # 返回列表形式外键关联的user模型对象 [<User 'tom'>]
tom_user.role  # 返回外键关联的role模型对象 <Role 'Admin'>
# 因为Role 一对多 User 所以tom_user.role返回一个对象,admin_role.users 返回列表
```
|方法|说明|
|-|-|
|all()|以列表形式返回查询的所有结果|
|first()|返回查询的第一个结果, 如果没有结果, 则返回 None|
|first_or_404()|返回查询的第一个结果, 如果没有结果, 则终止请求, 返回 404 错误响应|
|get()|返回指定主键对应的行, 如果没有对应的行, 则返回 None|
|get_or_404()|返回指定主键对应的行, 如果没找到指定的主键, 则终止请求, 返回 404 错误响应|
|count()|返回查询结果的数量|
|paginate()|返回一个 Paginate 对象, 包含指定范围内的结果|


*过滤器*
|过滤器|说明|
|-|-|
|filter()|把过滤器添加到原查询上, 返回一个新查询|
|filter_by()|把等值过滤器添加到原查询上, 返回一个新查询|
|limit()|使用指定的值限制原查询返回的结果数量, 返回一个新查询|
|offest()|偏移原查询返回的结果, 返回一个新查询|
|order_by()|根据指定条件对原查询结果进行排序, 返回一个新查询|
|group_by()|根据指定条件对原查询结果进行分组, 返回一个新查询|
```py
User.query.filter_by(role=admin_role).all()  # [<User 'tom'>]列表, all()查询符合条件的全部,role=admin_role 通过反向定义, 查询Role模型的admin_role对象

str(User.query.filter_by(role=admin_role))  # 此时对象名变成了sql原生语句
# 'SELECT users.id AS users_id, users.username AS users_username, users.role_id AS users_role_id \nFROM users \nWHERE ? = users.role_id'

mode = Role.query.filter_by(name='Admin').first()  # <Role 'Admin'>
```
*lazy*
```py
admin_role.users  # [<User 'tom'>]
# 查询有个小问题. 执行user_role.users 表达式时, 隐式的查询会调用 all() 方法, 返回一个用户列表

# 在不需要主动查询时, 我们需要返回查询对象, 进行自定义操作
# 在定义模型时, 可以在外键属性处添加 lazy参数
users = db.relationship('User', backref='role', lazy='dynamic')
admin_role.users.users.order_by(User.username).all()
```

### 集成python shell
```py
@app.shell_context_processor
def make_shell_context():
    return dict(db=db, User=User, Role=Role)  # 除了默认引入的app外, 还会引入db User Role
# flask shell 命令将自动把这些对象导入shell
```

### 使用Flask-Migrate实现数据库迁移
*这个扩展是对 Alembic 的轻量级包装, 并与 flask 命令做了集成  
数据库迁移框架能跟踪数据库模式 的变化, 然后以增量的方式把变化应用到数据库中. *

安装: `pip install flask-migrate`
```py
# 初始化
from flask_migrate import Migrate


migrate = Migrate(app, db)
```
```sh
flask db init  # 添加数据库迁移支持目录
# 会在工程根目录创建migrate目录, 里面有迁移脚本
```
在migrations目录versions中有py脚本文件, 文件中有两个函数  
1. `upgrade()`函数把迁移中的改动应用到数据库中
2. `downgrade()`函数则将改动删除

Alembic 框架 具有添加和删除改动的能力, 意味着数据库可重设到修改历史的任意一点.   
**自动创建的迁移不一定总是正确的, 有可能会漏掉一些细节,需要进行手动检查**

    使用 Flask-Migrate 管理数据库模式变化的步骤如下. 
    (1) 对模型类做必要的修改. 
    (2) 执行 flask db migrate 命令, 自动创建一个迁移脚本. 
    (3) 检查自动生成的脚本, 根据对模型的实际改动进行调整. 
    (4) 把迁移脚本纳入版本控制. 
    (5) 执行 flask db upgrade 命令, 把迁移应用到数据库中. 
```sh
# shell
flask db migrate -m "initial migration"  # 创建迁移脚本, -m remark的意思

flask db upgrade # 进行数据库迁移
```
*标记现在数据库为已更新,若使用了upgrade时会自动标记,但如果是一开始db.create_all()时就需要标记了*
```sh
# shell
flask db stamp  # 标记现在数据库为已更新
```
    在前一个迁移脚本的基础上修改的步骤如下: 
    执行 flask db downgrade 命令, 还原前一个脚本对数据库的改动
    (注意, 这可能导致部分数据丢失). 
    (2) 删除前一个迁移脚本, 因为现在已经没什么用了. 
    (3) 执行 flask db migrate 命令生成一个新的数据库迁移脚本. 这个
    迁移脚本除了前面删除的那个脚本中的改动之外, 还包括这一次对模型
    的改动. 
    (4) 根据前面的说明, 检查并应用迁移脚本. 
```sh
# shell
flask db downgrade  # 还原到上一次对数据库的改动
```
## 使用Flask-Mail提供电子邮件支持
安装:`pip install flask-mail`

flask-mail支持使用jinja2模板渲染邮件正文

flask-mail smtp服务器配置
|配置|默认值|说明|
|-|-|-|
|MAIL_SERVER|localhost|电子邮箱服务器的主机名或ip地址|
|MAIL_PORT|25|电子邮箱服务器的端口|
|MAIL_USE_TLS|False|启用传输层安全协议(TLS)|
|MAIL_USE_SSL|False|启用安全套接层(SSL)协议|
|MAIL_USERNAME|None|邮件账户的用户名|
|MAIL_PASSWORD|None|邮件账户的密码|
```py
import os
from flask_mail import Mail


# 配置
app.config['MAIL_SERVER'] = 'xx.xx.com'
app.config['MAIL_PORT'] = 587
app.config['MAIL_USE_TLS'] = True
# app.config['MAIL_USE_SSL'] = True
app.config['MAIL_USERNAME'] = os.environ.get('MAIL_USERNAME')  # 从系统环境中获取敏感凭证
app.config['MAIL_PASSWORD'] = os.environ.get('MAIL_PASSWORD')

# 初始化flask-mail
mail = Mail(app)
```
向系统环境变量写入敏感凭证(习惯python语法的同学要注意, 写入环境'='不要带空格)
```sh
# unix
export MAIL_USERNAME='邮箱账号'
export MAIL_PASSWORD='邮箱密码'
```
```powershell
# windows
set MAIL_USERNAME='邮箱账号'
set MAIL_PASSWORD='邮箱密码'
```
**实例**
```py
# 我们可以封装一个发送邮件的模板
from flask_mail import Message


app.config['FLASK_MAIL_SUBJECT_PREFIX'] = '[邮件主题前缀]'
app,config['FLASK_MAIL_SENDER'] = '发件人'

def send_mail(to, subject, template, **kwargs):
    msg = Message(app.config[FLASK_MAIL_SUBJECT_PREFIX] + subject
                  sender=app,config['FLASK_MAIL_SENDER'], recipients=[to])  # 主题, 发件人, 收件人(收件人处接收参数为列表)
    msg.body = render_template(template + '.txt', **kwargs)
    msg.html = render_template(template + '.html', **kwargs)  # 因为设定形参时只能传一个模板名,所以在方法内做模板名称的拼接
    mail.send(msg)
```
```html
<!-- mail.html -->
User <b>{{ user.username }}</b> has joined.
```
mail.txt
```text
User {{ user.username }} has joined.
```
### 异步发邮件
为了不能让发邮件占据我们系统正常运行, 所以要做成异步的模式, 如果量大还要写入队列发送,两种低消耗方法
1. 协程 genvent库 genvent.swap(func, *args, **kwargs)
2. 多线程  Thread
```py
# 多线程
from threading import Thread


def send_async_email(app, msg):
    with app.app_context():  # , Flask-Mail 的 send() 函数使用 current_app , 因此必须激活应用上下文. 
        mail.send(msg)

# 上下文是与线程配套的, 在不同的线程中执行 mail.send() 函数时, 要使用app.app_context() 人工创建应用上下文. 

def send_mail(to, subject, template, **kwargs):
    msg = Message(app.config[FLASK_MAIL_SUBJECT_PREFIX] + subject
                  sender=app,config['FLASK_MAIL_SENDER'], recipients=[to])  # 主题, 发件人, 收件人(收件人处接收参数为列表)
    msg.body = render_template(template + '.txt', **kwargs)
    msg.html = render_template(template + '.html', **kwargs)  # 因为设定形参时只能传一个模板名,所以在方法内做模板名称的拼接
    thr = Thread(target=send_async_email, args=[app, msg])
    thr.start()
    return thr


# 协程
import gevent

def send_mail(to, subject, template, **kwargs):
    msg = Message(app.config[FLASK_MAIL_SUBJECT_PREFIX] + subject
                  sender=app,config['FLASK_MAIL_SENDER'], recipients=[to])  # 主题, 发件人, 收件人(收件人处接收参数为列表)
    msg.body = render_template(template + '.txt', **kwargs)
    msg.html = render_template(template + '.html', **kwargs)  # 因为设定形参时只能传一个模板名,所以在方法内做模板名称的拼接
    association = gevent.spawn(send_async_email, [app, msg])
    return association
```
## 大型应用的结构
Flask 应用的基本结构
```
|-flasky
    |-app/
        |-templates/
        |-static/
        |-main/
            |-__init__.py
            |-errors.py
            |-forms.py
            |-views.py
        |-__init__.py
        |-email.py
        |-models.py
|-migrations/
|-tests/
    |-__init__.py
    |-test*.py
|-venv/
|-requirements.txt
|-config.py
|-flasky.py
```
这种结构有 4 个顶级文件夹: 
- Flask 应用一般保存在名为 app 的包中；
- 和之前一样, 数据库迁移脚本在 migrations 文件夹中；
- 单元测试在 tests 包中编写；
- 和之前一样, Python 虚拟环境在 venv 文件夹中. 
- requirements.txt 列出了所有依赖包, 便于在其他计算机中重新生成相同的虚拟环境；
- `config.py` 存储配置；
- `flasky.py` 定义 Flask 应用实例, 同时还有一些辅助管理应用的任务. 

### 配置选项
```py
# 示例选自Flask-Web开发(狗书) p119
import os
basedir = os.path.abspath(os.path.dirname(__file__))


class Config:  # 将通用的配置项放在父类做属性, 并且指定默认参数
    # 密钥
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard to guess string'
    # 邮件
    MAIL_SERVER = os.environ.get('MAIL_SERVER', 'xx.xx.com')
    MAIL_PORT = int(os.environ.get('MAIL_PORT', '587'))
    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS', 'true').lower() in \
        ['true', 'on', '1']
    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')
    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')
    FLASKY_MAIL_SUBJECT_PREFIX = '[Flasky]'
    FLASKY_MAIL_SENDER = 'Flasky Admin <flasky@example.com>'
    FLASKY_ADMIN = os.environ.get('FLASKY_ADMIN')
    # 数据库
    SQLALCHEMY_TRACK_MODIFICATIONS = False

    @staticmethod
    def init_app(app):
        pass


# 将需要自定义的配置放置在各个子类
class DevelopmentConfig(Config):  # 开发环境的子类
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URL') or \
        'sqlite:///' + os.path.join(basedir, 'data-dev.sqlite')


class TestingConfig(Config):  # 测试环境的子类
    TESTING = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('TEST_DATABASE_URL') or \
        'sqlite://'


class ProductionConfig(Config):  # 生产环境的子类
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \
        'sqlite:///' + os.path.join(basedir, 'data.sqlite')


# 通过字典的方式存储相关类名, 方便引用
config = {
    'development': DevelopmentConfig,
    'testing': TestingConfig,
    'production': ProductionConfig,

    'default': DevelopmentConfig
}
```
### 应用包 application
应用包用于存放应用的所有代码. 模板和静态文件. 
#### 应用工厂函数
在app文件的__init__.py文件中定义工厂函数, 集中初始化相关配置

工厂函数好处: 
1. 将创建应用实例的过程交给工厂函数, 通过传入不同的配置, 我们可以创建不同环境下的应用
2. 在做测试时, 为每个实例分配分配不同的配置, 从而测试每一种不同的情况
3. 想创建实例时再创建实例
```py
from flask import Flask
from flask_bootstrap import Bootstrap
from flask_mail import Mail
from flask_moment import Moment
from flask_sqlalchemy import SQLAlchemy
from config import config

bootstrap = Bootstrap()
mail = Mail()
moment = Moment()
db = SQLAlchemy()


def create_app(config_name):  # param: 想要运行的环境
    app = Flask(__name__)
    app.config.from_object(config[config_name])  # 将config中所有的配置直接导入应用
    config[config_name].init_app(app)

    # 初始化拓展
    bootstrap.init_app(app)
    mail.init_app(app)
    moment.init_app(app)
    db.init_app(app)

    # 以蓝图的形式添加路由和自定义的错误页面
    from .main import main as main_blueprint
    app.register_blueprint(main_blueprint)  # 注册蓝图

    return app
```

### 在蓝本中实现应用功能
因为采用工厂函数集中初始化的原因, 定义路由和错误响应页面变得不是特别方便. 这时使用蓝本是一个更好的解决办法. 

> 蓝本和应用类似, 也可以定义路由和错误处理程序. 不同的是, 在蓝本中定义的路由和错误处理程序处于休眠状态, 直到蓝本注册到应用上之后, 它们才真正成为应用的一部分. 使用位于全局作用域中的蓝本时, 定义路由和错误处理程序的方法几乎与单脚本应用一样. 

> 与应用一样, 蓝本可以在单个文件中定义, 也可使用更结构化的方式在
包中的多个模块中创建. 

在app包中创建一个子包(相当于子应用), 在子包的__init__.py文件中创建蓝本
```py
from flask import Blueprint

main = Blueprint('main', __name__)  #实例化一个 Blueprint 类对象; param: (必传)蓝本的名称和蓝本所在的包或模块,与应用一样, 多数情况下第二个参数使用 Python 的 __name__ 变量即可. 

# 为避免发生循环导入 于是将导入路由和错误响应放在最后. 
# 因为下面两个模块引用了main, 只有等main创建后再导入, 才不会造成循环导入
from . import views, errors
```
**注意: 原来单脚本时路由和错误响应都是使用app作为应用, 现在放在蓝本下时应改为main作为应用对象**
```py
# app/main/errors.py
from flask import render_template
from . import main


# 在蓝本中定义错误响应有一定的不同,若使用errorhandler装饰器的话, 只有在蓝本内部的错误才会触发程序, 如果需要注册全局应用的错误程序, 需要使用app_errorhandeler装饰器
@main.app_errorhandler(404)  
def page_not_found(e):
    return render_template('404.html'), 404


@main.app_errorhandler(500)
def internal_server_error(e):
    return render_template('500.html'), 500

```

```py
# app/main/views.py
from flask import render_template, session, redirect, url_for, current_app
from .. import db
from ..models import User
from ..email import send_email
from . import main
from .forms import NameForm


@main.route('/', methods=['GET', 'POST'])
def index():
    form = NameForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.name.data).first()
        if user is None:
            user = User(username=form.name.data)
            db.session.add(user)
            db.session.commit()
            session['known'] = False
            if current_app.config['FLASKY_ADMIN']:
                send_email(current_app.config['FLASKY_ADMIN'], 'New User',
                           'mail/new_user', user=user)
        else:
            session['known'] = True
        session['name'] = form.name.data
        return redirect(url_for('.index'))  # 在蓝图中端点名不再是类名, 而是main.index(蓝本名.类名), 在同一蓝本中可以简写成.index
    return render_template('index.html',
                           form=form, name=session.get('name'),
                           known=session.get('known', False))
```
*这意味着, 同一蓝本中的重定向可以使用简写形式(.index), 但跨蓝本的重定向必须使用带有蓝本名的完全限定端点名(main.index). *

### 应用脚本

```py
# 主脚本
import os
from flask_migrate import Migrate
from app import create_app, db
from app.models import User, Role

app = create_app(os.getenv('FLASK_CONFIG') or 'default')  # 从环境变量中获取配置, 创建指定配置的应用实例. 若没有则使用默认配置
migrate = Migrate(app, db)


@app.shell_context_processor
def make_shell_context():
    return dict(db=db, User=User, Role=Role)
```
### 需求文件
```sh
# 生成需求文件
pip freeze > requirements.txt
# 安装需求文件
pip install -r requirements.txt
```
### 单元测试
```py
import unittest
from flask import current_app
from app import create_app, db


class BasicsTestCase(unittest.TestCase):
    def setUp(self):
        self.app = create_app('testing')  # 初始化环境
        self.app_context = self.app.app_context()  # 激活上下文
        self.app_context.push()  # 上下文入栈
        db.create_all()  # 创建数据库

    def tearDown(self):
        db.session.remove()  # 移除会话
        db.drop_all()  # 删除数据库
        self.app_context.pop()  # 上下文出栈

    def test_app_exists(self):
        self.assertFalse(current_app is None)  # 确保应用实例存在

    def test_app_is_testing(self):
        self.assertTrue(current_app.config['TESTING'])  # 确保应用在测试配置中运行

```
```py
# 启动程序
import os
import click
from flask_migrate import Migrate
from app import create_app, db
from app.models import User, Role

app = create_app(os.getenv('FLASK_CONFIG') or 'default')
migrate = Migrate(app, db)


@app.shell_context_processor  
def make_shell_context():
    return dict(db=db, User=User, Role=Role)


@app.cli.command()  # 被装饰的函数名就是命令名
@click.argument('test_names', nargs=-1)
def test(test_names):
    """Run the unit tests."""
    import unittest
    if test_names:
        tests = unittest.TestLoader().loadTestsFromNames(test_names)
    else:
        tests = unittest.TestLoader().discover('tests')
    unittest.TextTestRunner(verbosity=2).run(tests)
```
```sh
flask test
# 使用@app.cli.command()装饰器装饰的函数, 可直接在终端中启动
```
### 创建数据库
有两种方法: 

一. Flask-migrate跟踪迁移
```sh
flask db upgrade
```
二. SQLAlchemy自带的
```py
db = SQLAlchemy()
db.create_all()
```
# 实例
## 用户身份验证
**flask的身份验证拓展库**
- Flask-Login:管理已登录用户的用户会话
- Werkzeug:计算密码散列值并进行核对
- itsdangerous :生成并核对加密安全令牌
### 密码安全性
**若想保证数据库中用户密码的安全,关键在于不存储密码本身,而是存储密码的散列值**

#### 使用Werkzeug计算密码散列值
*计算密码散列值的函数接收密码作为输入,添加随机内容(盐值 )之后,使用多种单向加密算法转换密码,最终得到一个和原始密码没有关系的字符序列,而且无法还原成原始密码. 核对密码时,密码散列值可代替原始密码,因为计算散列值的函数是可复现的:只要输入(密码和盐值)一样,结果就一样. *
```py
from werkzeug.security import generate_password_hash, check_password_hash


generate_password_hash(password, method='pbkdf2:sha256',salt_length=8)
# 这个函数的输入为原始密码,返回密码散列值的字符串形式,供存入用户数据库. method 和 salt_length 的默认值就能满足大多数需求. 

check_password_hash(hash, password)
# 这个函数的参数是从数据库中取回的密码散列值和用户输入的密码. 返回值为 True 时表明用户输入的密码正确. 
```
在数据库模型类上使用散列值方法
```py
class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, index=True)
    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))
    password_hash = db.Column(db.String(128))

    # 只写不读
    @property
    def password(self):
        raise AttributeError('password is not a readable attribute')

    @password.setter
    def password(self, password):
        self.password_hash = generate_password_hash(password)  # 将散列写入

    def verify_password(self, password):
        return check_password_hash(self.password_hash, password)  # 传入密码与存储的散列密码比对

    def __repr__(self):
        return '<User %r>' % self.username

```
针对散列的单元测试
```py
import unittest
from app import create_app, db
from app.models import User


class UserModelTestCase(unittest.TestCase):
    def setUp(self):
        self.app = create_app('testing')
        self.app_context = self.app.app_context()
        self.app_context.push()
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()
        self.app_context.pop()

    def test_password_setter(self):
        u = User(password='cat')
        self.assertTrue(u.password_hash is not None)

    def test_no_password_getter(self):
        u = User(password='cat')
        with self.assertRaises(AttributeError):
            u.password

    def test_password_verification(self):
        u = User(password='cat')
        self.assertTrue(u.verify_password('cat'))
        self.assertFalse(u.verify_password('dog'))

    def test_password_salts_are_random(self):
        u = User(password='cat')
        u2 = User(password='cat')
        self.assertTrue(u.password_hash != u2.password_hash)
```
### 创建身份验证的蓝本
在app包下创建auth子包,存放auth蓝本
```py
# app/auth/__init__.py  auth包的构造函数
from flask import Blueprint

auth = Blueprint('auth', __name__)

from . import views  # 该蓝本的路由
```
    模板文件有两种存放方式:
    1. 在总的template目录下按蓝图创建目录存放
    2. 在蓝本目录下创建template(应用会先搜索应用的模板目录,然后再搜索蓝本的模板目录)
```py
#  app/auth/views.py
from flask import render_template
from . import auth


@auth.route('/login')
def login():
    return render_template('auth/login.html') 
```
要在app目录的__init__.py中注册蓝图
```py
from .auth import auth as auth_blueprint
    app.register_blueprint(auth_blueprint, url_prefix='/auth')  # 指定了url_prefix后该蓝本的path前会加/auth
    # http://localhost:5000/auth/login
```
### 使用flask-login验证用户身份
安装:`pip install flask-login`

**如果要使用这个拓展,需要应用的相关模型实现以下方法/属性**
|属性/方法|说明|
|-|-|
|is_authenticated|如果用户提供的登录凭据有效,必须返回 True ,否则返回 False|
|is_active|如果允许用户登录,必须返回 True ,否则返回 False . 如果想禁用账户,可以返回 False|
|is_anonymous|对普通用户必须始终返回 False ,如果是表示匿名用户的特殊用户对象,应该返回 True|
|get_id|必须返回用户的唯一标识符,使用 Unicode 编码字符串|
**也可以通过集成flask-login里面的UserMixin类,已经默认实现这些功能了**
```py
from . import db, login_manager
from flask_login import UserMixin


class User(UserMixin, db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(64), unique=True, index=True)
    username = db.Column(db.String(64), unique=True, index=True)
    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))
    password_hash = db.Column(db.String(128))

# 装饰器把这个函数注册给 Flask-Login,在这个扩展需要获取已登录用户的信息时调用,返回用户对象
@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))
```
在`app/__init__.py`中
```py
from flask_login import LoginManager

login_manager = LoginManager
login_manager.login_view = 'auth.login'  # 无权限访问时,重定向到这个端点

def create_app(config_name):
    # ...
    login_manager.init_app(app)  # 初始化
    # ...
```
#### 保护路由
```py
@auth.route('/logout')  # 必须先路由
@login_required  # 禁止未授权的用户访问, 重定向到登录页
def logout():
    logout_user()
    flash('You have been logged out.')
    return redirect(url_for('main.index'))
```
#### 登录表单
```py
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, BooleanField, SubmitField
from wtforms.validators import DataRequired, Length, Email


class LoginForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired(), Length(1, 64), Email()])  # 错误msg,验证函数
    password = PasswordField('Password', validators=[DataRequired()])
    remember_me = BooleanField('Keep me logged in')
    submit = SubmitField('Log In')
```
```py
current_user.is_authenticated  # 由flask-login定义,为当前登录的用户对象
# 通过 current_user.is_authenticated 表达式就能判断当前用户是否登录
```
```py
@auth.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():  # 验证表单数据
        user = User.query.filter_by(email=form.email.data.lower()).first()
        if user is not None and user.verify_password(form.password.data):  # 判断账号和密码
            login_user(user, form.remember_me.data)  #　保持登录勾选, 在用户会话中把用户标记为已登录
            # cookie 有效期默认一年
            next = request.args.get('next')  # 读取原url,url确保是相对URL
            if next is None or not next.startswith('/'):
                next = url_for('main.index')
            return redirect(next)
        flash('Invalid email or password.')
    return render_template('auth/login.html', form=form)
```
### 退出登录
```py
@auth.route('/logout')
@login_required
def logout():
    logout_user()  # 删除并重设用户会话
    flash('You have been logged out.')
    return redirect(url_for('main.index'))
```
```py

```
```py

```


```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```
```py

```

# 其他插件
## 文件上传
文件上传: 可使用`flask-upload`

有一条原则是“永远不要信任用户输入”. 这条原则同样适用已上传文件的文件名. 所有提交的表单数据可能是伪造的, 文件名也可以是危险的. 比如说上传一个文件通过相对路径来替换你系统的文件. 此时要谨记: 在把文件保存到文件系统之前总是要使用这个函数对文件名进行安检. 

所以在保存的时候必须使用`from werkzeug.utils import secure_filename`对文件进行处理
```py
from flask import Flask, request
from werkzeug.utils import secure_filename

app = Flask(__name__)  # 定义名字
app.config["MAX_CONTENT_LENGTH"] = 1024*1024  # 413 Request Entity Too Large


@app.route("/", methods=["GET", "POST"])
def root():
    file = request.files.get("name")  # 文件对象
    print(file)
    print(file.filename)  # 文件名
    if file.filename in ("png"):  # 限制文件格式
        file.save(secure_filename(file.filename))
        return "GG"
    if request.method == "GET":
        print(request.args)  # ImmutableMultiDict([('user', 'hahah')])
    elif request.method == "POST":
        print(request.json)  # {'user': 'hahahaha'}
    return "测试test"


# 访问文件
@app.route("/read", methods=["GET", "POST"])
def root():
    return send_from_directory(os.path.dirname(__name__), "ludashi.jpg")


if __name__ == '__main__':
    app.run(debug=True)
```

# RESTful API风格
http://www.pythondoc.com/flask-restful/first.html
# 部署

## docker
dockerfile
```dockerfile
FROM python:3.6-alpine  
# 指定一个基容器镜像
# 这里使用的是 3.6 版解释器,基于 Alpine Linux 发行版构建. 容器镜像经常使用 AlpineLinux,因为它体量小. 

ENV FLASK_APP flasky.py
ENV FLASK_CONFIG production
# ENV定义运行时环境变量,变量名及其值


RUN adduser -D flasky  # 容器中创建一个名为 flasky 的用户 -D 参数禁止命令提示用户输入密码
USER flasky  # 命令选择以哪个用户的身份运行容器 默认root

WORKDIR /home/flasky  # 定义应用所在的顶层目录

COPY requirements requirements  # 从本地文件系统中把文件复制到容器的文件系统中
RUN python -m venv venv  # 创建虚拟环境
RUN venv/bin/pip install -r requirements/docker.txt # 选择虚拟环境进行安装依赖库

COPY app app  # 只需复制生产环境需要的文件
COPY migrations migrations
COPY flasky.py config.py boot.sh ./

# run-time configuration
EXPOSE 5000  # 定义服务器安装在容器的哪个端口上
ENTRYPOINT ["./boot.sh"]  # 指定启动容器时如何运行应用
```
```sh
python -m venv venv
# -m 为python3.3之后创建轻量虚拟环境的参数
# 第一个参数为 虚拟环境 名称
# 第二个参数为 虚拟环境的位置  venv目录的意思
```
boot.sh
```sh
#!/bin/sh
source venv/bin/activate  # 初始化环境
flask deploy  # 运行部署程序
exec gunicorn -b :5000 --access-logfile - --error-logfile - flasky:app  # 启动 Gunicorn 服务器
# 监听 5000 端口 --access 访问日志 --error错误日志
# exec 会代替原有shell进程,运行exec的命令. Docker 会特别留意启动容器的进程, 如果该进程停止, 容器也会停止. 使用exec替代后, Docker便一直监听该进程
```
docker mysql 
```sh
docker run --name mysql -d -e MYSQL_RANDOM_ROOT_PASSWORD=yes -e MYSQL_DATABASE=flasky -e MYSQL_USER=flasky -e MYSQL_PASSWORD=<database-password> mysql/mysql-server:5.7
# --name mysql创建一个名为mysql的容器；
# MYSQL_RANDOM_ROOT_PASSWORD 随机创建root用户密码 密码可以使用docker log mysql在日志中查看；
# MYSQL_DATABASE 创建数据库(名)；
# MYSQL_USER 创建数据库用户；
# MYSQL_PASSWORD 创建数据库密码；
# 最后是指定要使用的镜像
```
服务容器关联数据库容器
```sh
docker run -d -p 8000:5000 --link mysql:dbserver -e DATABASE_URL=mysql+pymysql://flasky:<database-password>@dbserver/flasky -e MAIL_USERNAME=<your-gmail-username> -e MAIL_PASSWORD=<your-gmail-password> flasky:latest
# . --link 选项把这个新容器与一个现有的容器连接起来. value是以冒号分隔的两个名称:一个是目标容器的名称或 IDID, 另一个是设定在当前容器中访问目标容器所用的别名.目标容器名为mysql, 在当前容器中访问目标容器可通过别名(dbserver)访问
# DATABASE_URL 设定数据库url环境变量, falsky为之前设定的数据库用户名, dbserver为主机ip, 用别名时Docker会解析成ip
```